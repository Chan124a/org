* 创建仓库
什么是版本库呢？版本库又名仓库，英文名repository，你可以简单理解成一个目录，这个目录里面的所有文件都可以被Git管理起来，每个文件的修改、删除，Git都能跟踪，以便任何时刻都可以追踪历史，或者在将来某个时刻可以“还原”。

所以，创建一个版本库非常简单，首先，选择一个合适的地方，创建一个空目录：
#+BEGIN_SRC bash
$ mkdir learngit
$ cd learngit
$ pwd
/Users/michael/learngit
#+END_SRC
第二步，通过git init命令把这个目录变成Git可以管理的仓库：
#+BEGIN_SRC bash
$ git init
Initialized empty Git repository in /Users/michael/learngit/.git/
#+END_SRC
瞬间Git就把仓库建好了，而且告诉你是一个空的仓库（empty Git repository）

可以发现当前目录下多了一个.git的目录，这个目录是Git来跟踪管理版本库的

如果你没有看到.git目录，那是因为这个目录默认是隐藏的，用ls -ah命令就可以看见。

* 把文件gi添加到仓库
第一步，用命令git add告诉Git，把文件添加到仓库：
#+BEGIN_SRC bash
$ git add readme.txt
#+END_SRC
执行上面的命令，没有任何显示，这就对了，Unix的哲学是“没有消息就是好消息”，说明添加成功。

第二步，用命令git commit告诉Git，把文件提交到仓库：
#+BEGIN_SRC bash
$ git commit -m "wrote a readme file"
[master (root-commit) eaadf4e] wrote a readme file
 1 file changed, 2 insertions(+)
 create mode 100644 readme.txt
#+END_SRC
git commit命令，-m后面输入的是本次提交的说明

commit可以一次提交很多文件，所以你可以多次add不同的文件
* 版本回退
- HEAD指向的版本就是当前版本，因此，Git允许我们在版本的历史之间穿梭，使用命令git reset --hard commit_id。
- 穿梭前，用git log可以查看提交历史，以便确定要回退到哪个版本。
- 要重返未来，用git reflog查看命令历史，以便确定要回到未来的哪个版本。


版本1：wrote a readme file
#+BEGIN_EXAMPLE
Git is a version control system.
Git is free software.
#+END_EXAMPLE
版本2：add distributed
#+BEGIN_EXAMPLE
Git is a distributed version control system.
Git is free software.
#+END_EXAMPLE
版本3：append GPL
#+BEGIN_EXAMPLE
Git is a distributed version control system.
Git is free software distributed under the GPL.
#+END_EXAMPLE
在Git中，我们用git log命令查看历史记录：
#+BEGIN_SRC bash
$ git log
commit 1094adb7b9b3807259d8cb349e7df1d4d6477073 (HEAD -> master)
Author: Michael Liao <askxuefeng@gmail.com>
Date:   Fri May 18 21:06:15 2018 +0800

    append GPL

commit e475afc93c209a690c39c13a46716e8fa000c366
Author: Michael Liao <askxuefeng@gmail.com>
Date:   Fri May 18 21:03:36 2018 +0800

    add distributed

commit eaadf4e385e865d25c48e7ca9c8395c3f7dfaef0
Author: Michael Liao <askxuefeng@gmail.com>
Date:   Fri May 18 20:59:18 2018 +0800

    wrote a readme file
#+END_SRC
git log命令显示从最近到最远的提交日志，我们可以看到3次提交，最近的一次是append GPL，上一次是add distributed，最早的一次是wrote a readme file。

如果嫌输出信息太多，看得眼花缭乱的，可以试试加上--pretty=oneline参数：
#+BEGIN_SRC bash
$ git log --pretty=oneline
1094adb7b9b3807259d8cb349e7df1d4d6477073 (HEAD -> master) append GPL
e475afc93c209a690c39c13a46716e8fa000c366 add distributed
eaadf4e385e865d25c48e7ca9c8395c3f7dfaef0 wrote a readme file
#+END_SRC
这里一大串类似1094adb...的是commit id（版本号）

在Git中，用HEAD表示当前版本，也就是最新的提交1094adb...（注意我的提交ID和你的肯定不一样），上一个版本就是HEAD^，上上一个版本就是HEAD^^，当然往上100个版本写100个^比较容易数不过来，所以写成HEAD~100。

现在，我们要把当前版本append GPL回退到上一个版本add distributed，就可以使用git reset命令：
#+BEGIN_SRC bash
$ git reset --hard HEAD^
HEAD is now at e475afc add distributed
#+END_SRC
看看readme.txt的内容是不是版本add distributed：
#+BEGIN_SRC bash
$ cat readme.txt
Git is a distributed version control system.
Git is free software.
#+END_SRC
果然被还原了。

我们用git log再看看现在版本库的状态：
#+BEGIN_SRC bash
$ git log
commit e475afc93c209a690c39c13a46716e8fa000c366 (HEAD -> master)
Author: Michael Liao <askxuefeng@gmail.com>
Date:   Fri May 18 21:03:36 2018 +0800

    add distributed

commit eaadf4e385e865d25c48e7ca9c8395c3f7dfaef0
Author: Michael Liao <askxuefeng@gmail.com>
Date:   Fri May 18 20:59:18 2018 +0800

    wrote a readme file
#+END_SRC
最新的那个版本append GPL已经看不到了！好比你从21世纪坐时光穿梭机来到了19世纪，想再回去已经回不去了，肿么办？

办法其实还是有的，只要上面的命令行窗口还没有被关掉，你就可以顺着往上找啊找啊，找到那个append GPL的commit id是1094adb...，于是就可以指定回到未来的某个版本：
#+BEGIN_SRC bash
$ git reset --hard 1094a
HEAD is now at 83b0afe append GPL
#+END_SRC
版本号没必要写全，前几位就可以了，Git会自动去找。当然也不能只写前一两位，因为Git可能会找到多个版本号，就无法确定是哪一个了。

看看readme.txt的内容：
#+BEGIN_SRC bash
$ cat readme.txt
Git is a distributed version control system.
Git is free software distributed under the GPL.
#+END_SRC
Git的版本回退速度非常快，因为Git在内部有个指向当前版本的HEAD指针，当你回退版本的时候，Git仅仅是把HEAD从指向append GPL：
#+BEGIN_EXAMPLE
┌────┐
│HEAD│
└────┘
   │
   └──> ○ append GPL
        │
        ○ add distributed
        │
        ○ wrote a readme 
#+END_EXAMPLE
改为指向add distributed：
#+BEGIN_EXAMPLE
┌────┐
│HEAD│
└────┘
   │
   │    ○ append GPL
   │    │
   └──> ○ add distributed
        │
        ○ wrote a readme file
#+END_EXAMPLE
然后顺便把工作区的文件更新了。所以你让HEAD指向哪个版本号，你就把当前版本定位在哪。

Git提供了一个命令git reflog用来记录你的每一次命令,我们可以用于查看commit id：
#+BEGIN_SRC bash
$ git reflog
e475afc HEAD@{1}: reset: moving to HEAD^
1094adb (HEAD -> master) HEAD@{2}: commit: append GPL
e475afc HEAD@{3}: commit: add distributed
eaadf4e HEAD@{4}: commit (initial): wrote a readme file
#+END_SRC

* 工作区和暂存区
Git和其他版本控制系统如SVN的一个不同之处就是有暂存区的概念。

工作区:就是你在电脑里能看到的目录，比如我的learngit文件夹就是一个工作区：

版本库（Repository）
工作区有一个隐藏目录.git，这个不算工作区，而是Git的版本库。

Git的版本库里存了很多东西，其中最重要的就是称为stage（或者叫index）的暂存区，还有Git为我们自动创建的第一个分支master，以及指向master的一个指针叫HEAD。
#+DOWNLOADED: file:F%3A/org/%E5%9B%BE%E7%89%87/0.jpg @ 2020-09-10 16:22:36
[[file:%E5%B7%A5%E4%BD%9C%E5%8C%BA%E5%92%8C%E6%9A%82%E5%AD%98%E5%8C%BA/2020-09-10_16-22-36_0.jpg]]
前面讲了我们把文件往Git版本库里添加的时候，是分两步执行的：

第一步是用git add把文件添加进去，实际上就是把文件修改添加到暂存区；

第二步是用git commit提交更改，实际上就是把暂存区的所有内容提交到当前分支。

因为我们创建Git版本库时，Git自动为我们创建了唯一一个master分支，所以，现在，git commit就是往master分支上提交更改。

你可以简单理解为，需要提交的文件修改通通放到暂存区，然后，一次性提交暂存区的所有修改。

现在，我们再练习一遍，先对readme.txt做个修改，比如加上一行内容：
#+BEGIN_SRC bash
Git is a distributed version control system.
Git is free software distributed under the GPL.
Git has a mutable index called stage.
#+END_SRC
然后，在工作区新增一个LICENSE文本文件（内容随便写）。

先用git status查看一下状态：
#+BEGIN_SRC bash
$ git status
On branch master
Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git checkout -- <file>..." to discard changes in working directory)

	modified:   readme.txt

Untracked files:
  (use "git add <file>..." to include in what will be committed)

	LICENSE

no changes added to commit (use "git add" and/or "git commit -a")
#+END_SRC
Git非常清楚地告诉我们，readme.txt被修改了，而LICENSE还从来没有被添加过，所以它的状态是Untracked。

现在，使用两次命令git add，把readme.txt和LICENSE都添加后，用git status再查看一下：
#+BEGIN_SRC bash
$ git status
On branch master
Changes to be committed:
  (use "git reset HEAD <file>..." to unstage)

	new file:   LICENSE
	modified:   readme.txt
#+END_SRC
现在，暂存区的状态就变成这样了：
#+DOWNLOADED: file:F%3A/org/%E5%9B%BE%E7%89%87/0%20%281%29.jpg @ 2020-09-10 16:25:44
[[file:%E5%B7%A5%E4%BD%9C%E5%8C%BA%E5%92%8C%E6%9A%82%E5%AD%98%E5%8C%BA/2020-09-10_16-25-44_0%2520%25281%2529.jpg]]
所以，git add命令实际上就是把要提交的所有修改放到暂存区（Stage），然后，执行git commit就可以一次性把暂存区的所有修改提交到分支。
#+BEGIN_SRC bash
$ git commit -m "understand how stage works"
[master e43a48b] understand how stage works
 2 files changed, 2 insertions(+)
 create mode 100644 LICENSE
#+END_SRC
一旦提交后，如果你又没有对工作区做任何修改，那么工作区就是“干净”的：
#+BEGIN_SRC bash
$ git status
On branch master
nothing to commit, working tree clean
#+END_SRC
现在版本库变成了这样，暂存区就没有任何内容了：
#+DOWNLOADED: file:F%3A/org/%E5%9B%BE%E7%89%87/0%20%282%29.jpg @ 2020-09-10 16:27:22
[[file:%E5%B7%A5%E4%BD%9C%E5%8C%BA%E5%92%8C%E6%9A%82%E5%AD%98%E5%8C%BA/2020-09-10_16-27-22_0%2520%25282%2529.jpg]]

* 管理修改
为什么Git比其他版本控制系统设计得优秀?因为Git跟踪并管理的是修改，而非文件

Git管理的是修改，当你用git add命令后，在工作区的第一次修改被放入暂存区，准备提交，但是，在工作区的第二次修改并没有放入暂存区，所以，git commit只负责把暂存区的修改提交了，也就是第一次的修改被提交了，第二次的修改不会被提交。

~git diff HEAD -- readme.txt~ 命令可以查看工作区和版本库里面最新版本的区别：
#+BEGIN_SRC bash
$ git diff HEAD -- readme.txt 
diff --git a/readme.txt b/readme.txt
index 76d770f..a9c5755 100644
--- a/readme.txt
+++ b/readme.txt
@@ -1,4 +1,4 @@
 Git is a distributed version control system.
 Git is free software distributed under the GPL.
 Git has a mutable index called stage.
-Git tracks changes.
+Git tracks changes of files.
#+END_SRC
** 实例
第一步，对readme.txt做一个修改，比如加一行内容：
#+BEGIN_SRC bash
$ cat readme.txt
Git is a distributed version control system.
Git is free software distributed under the GPL.
Git has a mutable index called stage.
Git tracks changes.
#+END_SRC
然后，添加：
#+BEGIN_SRC bash
$ git add readme.txt
$ git status
# On branch master
# Changes to be committed:
#   (use "git reset HEAD <file>..." to unstage)
#
#       modified:   readme.txt
#
#+END_SRC
然后，再修改readme.txt：
#+BEGIN_SRC bash
$ cat readme.txt 
Git is a distributed version control system.
Git is free software distributed under the GPL.
Git has a mutable index called stage.
Git tracks changes of files.
#+END_SRC
提交：
#+BEGIN_SRC bash
$ git commit -m "git tracks changes"
[master 519219b] git tracks changes
 1 file changed, 1 insertion(+)
#+END_SRC
提交后，再看看状态：
#+BEGIN_SRC bash
$ git status
On branch master
Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git checkout -- <file>..." to discard changes in working directory)

	modified:   readme.txt

no changes added to commit (use "git add" and/or "git commit -a")
#+END_SRC
咦，怎么第二次的修改没有被提交？

别激动，我们回顾一下操作过程：

第一次修改 -> git add -> 第二次修改 -> git commit

你看，我们前面讲了，Git管理的是修改，当你用git add命令后，在工作区的第一次修改被放入暂存区，准备提交，但是，在工作区的第二次修改并没有放入暂存区，所以，git commit只负责把暂存区的修改提交了，也就是第一次的修改被提交了，第二次的修改不会被提交。
* 撤销修改
~git checkout -- file~ 可以丢弃工作区的修改

命令git checkout -- readme.txt意思就是，把readme.txt文件在工作区的修改全部撤销，这里有两种情况：
- 一种是readme.txt自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态；
- 一种是readme.txt已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态。

总之，就是让这个文件回到最近一次git commit或git add时的状态。

git checkout -- file命令中的--很重要，没有--，就变成了“切换到另一个分支”的命令

用命令git reset HEAD <file>可以把暂存区的修改撤销掉（unstage），重新放回工作区：
#+BEGIN_SRC bash
$ git reset HEAD readme.txt
Unstaged changes after reset:
M	readme.txt
#+END_SRC
git reset命令既可以回退版本，也可以把暂存区的修改回退到工作区。当我们用HEAD时，表示最新的版本。

小结:
- 场景1：当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，用命令git checkout -- file。
- 场景2：当你不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改，分两步，第一步用命令git reset HEAD <file>，就回到了场景1，第二步按场景1操作。
- 场景3：已经提交了不合适的修改到版本库时，想要撤销本次提交，参考版本回退一节，不过前提是没有推送到远程库。
* 删除文件
在Git中，删除也是一个修改操作，我们实战一下，先添加一个新文件test.txt到Git并且提交：
#+BEGIN_SRC bash
$ git add test.txt

$ git commit -m "add test.txt"
[master b84166e] add test.txt
 1 file changed, 1 insertion(+)
 create mode 100644 test.txt
#+END_SRC
一般情况下，你通常直接在文件管理器中把没用的文件删了，或者用rm命令删了：
#+BEGIN_SRC bash
$ rm test.txt
#+END_SRC
这个时候，Git知道你删除了文件，因此，工作区和版本库就不一致了，git status命令会立刻告诉你哪些文件被删除了：
#+BEGIN_SRC bash
$ git status
On branch master
Changes not staged for commit:
  (use "git add/rm <file>..." to update what will be committed)
  (use "git checkout -- <file>..." to discard changes in working directory)

	deleted:    test.txt

no changes added to commit (use "git add" and/or "git commit -a")
#+END_SRC
现在你有两个选择，一是确实要从版本库中删除该文件，那就用命令git rm删掉，并且git commit：
#+BEGIN_SRC bash
$ git rm test.txt
rm 'test.txt'

$ git commit -m "remove test.txt"
[master d46f35e] remove test.txt
 1 file changed, 1 deletion(-)
 delete mode 100644 test.txt
#+END_SRC
现在，文件就从版本库中被删除了。

另一种情况是删错了，因为版本库里还有呢，所以可以很轻松地把误删的文件恢复到最新版本：
#+BEGIN_SRC bash
$ git checkout -- test.txt
#+END_SRC
git checkout其实是用版本库里的版本替换工作区的版本，无论工作区是修改还是删除，都可以“一键还原”。
* 使用git（同一账号）在多台电脑协同做工
1、在你想要协同的工作文件夹中打开Git Bash Here，创建一个SSH key，这里用到了非对称公钥加密体系，生成的公钥放到github的网站上，二生成的私钥放在自己的电脑上，每当需要将文件上传到github上时，服务器就会用事先的公钥与你给出的私钥进行验证，验证是否是真正的用户在操作（原理类似于数字签名）。通过如下命令生成公私钥：
#+BEGIN_SRC bash
ssh-keygen -t rsa -C "你的github邮箱"
#+END_SRC
期间会要求你输入密码，并会给出存放生成的公钥在哪一个文件夹中。我们在这个文件夹中的id_rsa.pub中获得我们账户的公钥。如果一切顺利的话，可以在用户主目录里找到.ssh目录，里面有id_rsa和id_rsa.pub两个文件，这两个就是SSH Key的秘钥对，id_rsa是私钥，不能泄露出去，id_rsa.pub是公钥，可以放心地告诉任何人。

#+DOWNLOADED: file:F%3A/org/%E5%9B%BE%E7%89%87/1803727-20200125171126826-2087303938.jpg @ 2020-09-10 20:12:17
[[file:%E4%BD%BF%E7%94%A8git%EF%BC%88%E5%90%8C%E4%B8%80%E8%B4%A6%E5%8F%B7%EF%BC%89%E5%9C%A8%E5%A4%9A%E5%8F%B0%E7%94%B5%E8%84%91%E5%8D%8F%E5%90%8C%E5%81%9A%E5%B7%A5/2020-09-10_20-12-17_1803727-20200125171126826-2087303938.jpg]]
2、将公钥添加到github自己的网站设置上，注意格式（打开的id_rsa.hub文件中不要将最后的邮箱也复制上去，这一点注意看github上的添加英文提醒）点“Add SSH Key”，填上任意Title，在Key文本框里粘贴id_rsa.pub文件的内容：
#+DOWNLOADED: file:F%3A/org/%E5%9B%BE%E7%89%87/1803727-20200125171143306-574498943.png @ 2020-09-10 20:12:27
[[file:%E4%BD%BF%E7%94%A8git%EF%BC%88%E5%90%8C%E4%B8%80%E8%B4%A6%E5%8F%B7%EF%BC%89%E5%9C%A8%E5%A4%9A%E5%8F%B0%E7%94%B5%E8%84%91%E5%8D%8F%E5%90%8C%E5%81%9A%E5%B7%A5/2020-09-10_20-12-27_1803727-20200125171143306-574498943.png]]
3、然后我们在自己希望上传的文档的文件夹中打开git bash，初始化git仓库并作出添加提交，并需要进行一定的配置等命令，输入命令：
#+BEGIN_SRC bash 
git init

git config --global user.name"自己账户的名字，建议就是github上的账户名，这样好记"
git config --global user.email"自己账户的邮箱地址，建议也是用GitHub上的那个"

git config --global -l //这条命令是用来查看上面的信息是否之前已经被输入了，自己检查下

git add .   //将所有的文件加入到index进行缓存
git commit -m "你想加入的备注"  //将所有的文件提交到仓库当中
#+END_SRC
4、在github上创建一个仓库，获得相应的url。在本地的git bash中输入命令使之与远程仓库进行关联，并将文件上传到github上，具体命令如下：
#+BEGIN_SRC bash
git remote add origin <你github上仓库的url>
git push -u origin master //将主分支本地的内容推送到GitHub上的远程仓库上
#+END_SRC
5、以上的工作都是在某一台电脑上执行的，假设这台电脑是自己的笔记本，此时我们需要使用自己的台式机对该项目文件进行工作，此时就需要在另一台电脑上重复执行步骤1，生成一个公私钥在台式机上，并将公钥提交到github上去，并做好config --global的配置。这样github即使来自两台电脑对同一仓库的提交，都会认为确实是同一个用户在执行合法的操作，这样使用笔记本是可以提交工作，使用台式机时也可以提交工作。具体命令如下：
#+BEGIN_SRC bash
//假设前面已经完成了公私钥、config的配置

git clone <你在GitHub上仓库的url>   //将远程仓库克隆到另一台电脑上



//之后你就可以在这台电脑上进行修改，仿佛就是在原来的电脑上使用一样

//在做出修改后同样做出提交工作
git add .
git commit -m "XX"
git push origin master
#+END_SRC
6、有一点需要注意的是当github远程仓库有最新的版本时，本地仓库若不更新就直接做出修改然后试图上传到远程时，就会出现冲突conflict。这种情况最好的解决方法就是对本地仓库先更新再修改上传，可以使用如下命令进行下拉更新:
#+BEGIN_SRC bash 
git pull origin master  //进行下拉更新

//然后再修改提交
#+END_SRC

* 添加远程库
首先，登陆GitHub，然后，在右上角找到“Create a new repo”按钮，创建一个新的仓库

在Repository name填入learngit，其他保持默认设置，点击“Create repository”按钮，就成功地创建了一个新的Git仓库：

目前，在GitHub上的这个learngit仓库还是空的，GitHub告诉我们，可以从这个仓库克隆出新的仓库，也可以把一个已有的本地仓库与之关联，然后，把本地仓库的内容推送到GitHub仓库。

现在，我们根据GitHub的提示，在本地的learngit仓库下运行命令：
#+BEGIN_SRC bash
git remote add origin https://github.com/Chan124a/leetcode-problems.git
git branch -M master
git push -u origin master
#+END_SRC
添加后，远程库的名字就是origin，这是Git默认的叫法，也可以改成别的，但是origin这个名字一看就知道是远程库。

下一步，就可以把本地库的所有内容推送到远程库上：
#+BEGIN_SRC bash
$ git push -u origin master
Counting objects: 20, done.
Delta compression using up to 4 threads.
Compressing objects: 100% (15/15), done.
Writing objects: 100% (20/20), 1.64 KiB | 560.00 KiB/s, done.
Total 20 (delta 5), reused 0 (delta 0)
remote: Resolving deltas: 100% (5/5), done.
To github.com:michaelliao/learngit.git
 * [new branch]      master -> master
Branch 'master' set up to track remote branch 'master' from 'origin'.
#+END_SRC
把本地库的内容推送到远程，用git push命令，实际上是把当前分支master推送到远程。

由于远程库是空的，我们第一次推送master分支时，加上了-u参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令。

推送成功后，可以立刻在GitHub页面中看到远程库的内容已经和本地一模一样

从现在起，只要本地作了提交，就可以通过命令：
#+BEGIN_SRC bash
$ git push origin master
#+END_SRC

小结:

要关联一个远程库，使用命令git remote add origin git@server-name:path/repo-name.git；

关联后，使用命令git push -u origin master第一次推送master分支的所有内容；

此后，每次本地提交后，只要有必要，就可以使用命令git push origin master推送最新修改；
* 从远程库克隆
要克隆一个仓库，首先必须知道仓库的地址，然后使用git clone命令克隆。

Git支持多种协议，包括https，但ssh协议速度最快。
* 创建与合并分支
** 原理解释

在版本回退里，你已经知道，每次提交，Git都把它们串成一条时间线，这条时间线就是一个分支。截止到目前，只有一条时间线，在Git里，这个分支叫主分支，即master分支。HEAD严格来说不是指向提交，而是指向master，master才是指向提交的，所以，HEAD指向的就是当前分支。

一开始的时候，master分支是一条线，Git用master指向最新的提交，再用HEAD指向master，就能确定当前分支，以及当前分支的提交点：
#+DOWNLOADED: file:F%3A/org/%E5%9B%BE%E7%89%87/0.png @ 2020-09-10 18:58:30
[[file:%E5%88%9B%E5%BB%BA%E4%B8%8E%E5%90%88%E5%B9%B6%E5%88%86%E6%94%AF/2020-09-10_18-58-30_0.png]]
每次提交，master分支都会向前移动一步，这样，随着你不断提交，master分支的线也越来越长。

当我们创建新的分支，例如dev时，Git新建了一个指针叫dev，指向master相同的提交，再把HEAD指向dev，就表示当前分支在dev上：
#+DOWNLOADED: file:F%3A/org/%E5%9B%BE%E7%89%87/l.png @ 2020-09-10 18:59:00
[[file:%E5%88%9B%E5%BB%BA%E4%B8%8E%E5%90%88%E5%B9%B6%E5%88%86%E6%94%AF/2020-09-10_18-59-00_l.png]]
Git创建一个分支很快，因为除了增加一个dev指针，改改HEAD的指向，工作区的文件都没有任何变化！

不过，从现在开始，对工作区的修改和提交就是针对dev分支了，比如新提交一次后，dev指针往前移动一步，而master指针不变：
#+DOWNLOADED: file:F%3A/org/%E5%9B%BE%E7%89%87/l%20%281%29.png @ 2020-09-10 18:59:36
[[file:%E5%88%9B%E5%BB%BA%E4%B8%8E%E5%90%88%E5%B9%B6%E5%88%86%E6%94%AF/2020-09-10_18-59-36_l%2520%25281%2529.png]]
假如我们在dev上的工作完成了，就可以把dev合并到master上。Git怎么合并呢？最简单的方法，就是直接把master指向dev的当前提交，就完成了合并：
#+DOWNLOADED: file:F%3A/org/%E5%9B%BE%E7%89%87/0%20%281%29.png @ 2020-09-10 18:59:53
[[file:%E5%88%9B%E5%BB%BA%E4%B8%8E%E5%90%88%E5%B9%B6%E5%88%86%E6%94%AF/2020-09-10_18-59-53_0%2520%25281%2529.png]]
所以Git合并分支也很快！就改改指针，工作区内容也不变！

合并完分支后，甚至可以删除dev分支。删除dev分支就是把dev指针给删掉，删掉后，我们就剩下了一条master分支：
#+DOWNLOADED: file:F%3A/org/%E5%9B%BE%E7%89%87/0%20%282%29.png @ 2020-09-10 19:00:14
[[file:%E5%88%9B%E5%BB%BA%E4%B8%8E%E5%90%88%E5%B9%B6%E5%88%86%E6%94%AF/2020-09-10_19-00-14_0%2520%25282%2529.png]]
** 创建与合并命令
- 查看分支：git branch
- 创建分支：git branch <name>
- 切换分支：git checkout <name>或者git switch <name>
- 创建+切换分支：git checkout -b <name>或者git switch -c <name>
- 合并某分支到当前分支：git merge <name>
- 删除分支：git branch -d <name>
** 实例
首先，我们创建dev分支，然后切换到dev分支：
#+BEGIN_SRC bash
$ git checkout -b dev
Switched to a new branch 'dev'
#+END_SRC
git checkout命令加上-b参数表示创建并切换，相当于以下两条命令：
#+BEGIN_SRC bash
$ git branch dev
$ git checkout dev
Switched to branch 'dev'
#+END_SRC
然后，用git branch命令查看当前分支：
#+BEGIN_SRC bash
 $ git branch
 * dev
  master
#+END_SRC
git branch命令会列出所有分支，当前分支前面会标一个*号。

然后，我们就可以在dev分支上正常提交，比如对readme.txt做个修改，加上一行：
#+BEGIN_SRC txt
Creating a new branch is quick.
#+END_SRC
然后提交：
#+BEGIN_SRC bash
$ git add readme.txt 
$ git commit -m "branch test"
[dev b17d20e] branch test
 1 file changed, 1 insertion(+)
#+END_SRC
现在，dev分支的工作完成，我们就可以切换回master分支：
#+BEGIN_SRC bash
$ git checkout master
Switched to branch 'master'
#+END_SRC

切换回master分支后，再查看一个readme.txt文件，刚才添加的内容不见了！因为那个提交是在dev分支上，而master分支此刻的提交点并没有变：

#+DOWNLOADED: file:F%3A/org/%E5%9B%BE%E7%89%87/0%20%283%29.png @ 2020-09-10 19:06:55
[[file:dev/2020-09-10_19-06-55_0%2520%25283%2529.png]]
现在，我们把dev分支的工作成果合并到master分支上：
#+BEGIN_SRC bash
$ git merge dev
Updating d46f35e..b17d20e
Fast-forward
 readme.txt | 1 +
 1 file changed, 1 insertion(+)
#+END_SRC
git merge命令用于合并指定分支到当前分支。合并后，再查看readme.txt的内容，就可以看到，和dev分支的最新提交是完全一样的。

注意到上面的Fast-forward信息，Git告诉我们，这次合并是“快进模式”，也就是直接把master指向dev的当前提交，所以合并速度非常快。

当然，也不是每次合并都能Fast-forward，我们后面会讲其他方式的合并。

合并完成后，就可以放心地删除dev分支了：
#+BEGIN_SRC bash
$ git branch -d dev
Deleted branch dev (was b17d20e).
#+END_SRC
删除后，查看branch，就只剩下master分支了：
#+BEGIN_SRC bash
 $ git branch
 * master
#+END_SRC

我们注意到切换分支使用git checkout <branch>，而前面讲过的撤销修改则是git checkout -- <file>，同一个命令，有两种作用，确实有点令人迷惑。

实际上，切换分支这个动作，用switch更科学。因此，最新版本的Git提供了新的git switch命令来切换分支：

创建并切换到新的dev分支，可以使用：
#+BEGIN_SRC bash
$ git switch -c dev
#+END_SRC
直接切换到已有的master分支，可以使用：
#+BEGIN_SRC bash
$ git switch master
#+END_SRC
使用新的git switch命令，比git checkout要更容易理解。
* 解决冲突
准备新的feature1分支，继续我们的新分支开发：
#+BEGIN_SRC bash
$ git switch -c feature1
Switched to a new branch 'feature1'
#+END_SRC
修改readme.txt最后一行，改为：
#+BEGIN_EXAMPLE
Creating a new branch is quick AND simple.
#+END_EXAMPLE
在feature1分支上提交：
#+BEGIN_SRC bash
$ git add readme.txt

$ git commit -m "AND simple"
[feature1 14096d0] AND simple
 1 file changed, 1 insertion(+), 1 deletion(-)
#+END_SRC
切换到master分支：
#+BEGIN_SRC bash
$ git switch master
Switched to branch 'master'
Your branch is ahead of 'origin/master' by 1 commit.
  (use "git push" to publish your local commits)
#+END_SRC
Git还会自动提示我们当前master分支比远程的master分支要超前1个提交。

在master分支上把readme.txt文件的最后一行改为：
#+BEGIN_EXAMPLE
Creating a new branch is quick & simple.
#+END_EXAMPLE
提交：
#+BEGIN_SRC bash
$ git add readme.txt 
$ git commit -m "& simple"
[master 5dc6824] & simple
 1 file changed, 1 insertion(+), 1 deletion(-)
#+END_SRC
现在，master分支和feature1分支各自都分别有新的提交，变成了这样：

#+DOWNLOADED: file:F%3A/org/%E5%9B%BE%E7%89%87/0%20%284%29.png @ 2020-09-10 19:19:11
[[file:%E8%A7%A3%E5%86%B3%E5%86%B2%E7%AA%81/2020-09-10_19-19-11_0%2520%25284%2529.png]]
这种情况下，Git无法执行“快速合并”，只能试图把各自的修改合并起来，但这种合并就可能会有冲突，我们试试看：
#+BEGIN_SRC bash
$ git merge feature1
Auto-merging readme.txt
CONFLICT (content): Merge conflict in readme.txt
Automatic merge failed; fix conflicts and then commit the result.
#+END_SRC
果然冲突了！Git告诉我们，readme.txt文件存在冲突，必须手动解决冲突后再提交。git status也可以告诉我们冲突的文件：
#+BEGIN_SRC bash
$ git status
On branch master
Your branch is ahead of 'origin/master' by 2 commits.
  (use "git push" to publish your local commits)

You have unmerged paths.
  (fix conflicts and run "git commit")
  (use "git merge --abort" to abort the merge)

Unmerged paths:
  (use "git add <file>..." to mark resolution)

	both modified:   readme.txt

no changes added to commit (use "git add" and/or "git commit -a")
#+END_SRC
我们可以直接查看readme.txt的内容：
#+BEGIN_SRC bash
Git is a distributed version control system.
Git is free software distributed under the GPL.
Git has a mutable index called stage.
Git tracks changes of files.
<<<<<<< HEAD
Creating a new branch is quick & simple.
=======
Creating a new branch is quick AND simple.
>>>>>>> feature1
#+END_SRC
Git用 ~<<<<<<<,=======,>>>>>>>~ 标记出不同分支的内容，我们修改如下后保存：
#+BEGIN_EXAMPLE
Creating a new branch is quick and simple.
#+END_EXAMPLE
再提交：
#+BEGIN_SRC bash
$ git add readme.txt 
$ git commit -m "conflict fixed"
[master cf810e4] conflict fixed
#+END_SRC
现在，master分支和feature1分支变成了下图所示：
#+DOWNLOADED: file:F%3A/org/%E5%9B%BE%E7%89%87/0%20%285%29.png @ 2020-09-10 19:26:26
[[file:%E8%A7%A3%E5%86%B3%E5%86%B2%E7%AA%81/2020-09-10_19-26-26_0%2520%25285%2529.png]]
用带参数的用git log --graph命令可以看到分支合并图:
#+BEGIN_SRC bash
 $ git log --graph --pretty=oneline --abbrev-commit
 *   cf810e4 (HEAD -> master) conflict fixed
 |\  
 | * 14096d0 (feature1) AND simple
 * | 5dc6824 & simple
 |/  
 * b17d20e branch test
 * d46f35e (origin/master) remove test.txt
 * b84166e add test.txt
 * 519219b git tracks changes
 * e43a48b understand how stage works
 * 1094adb append GPL
 * e475afc add distributed
 * eaadf4e wrote a readme file
#+END_SRC
最后，删除feature1分支：
#+BEGIN_SRC 
$ git branch -d feature1
Deleted branch feature1 (was 14096d0).
#+END_SRC
工作完成。

1、在你想要协同的工作文件夹中打开Git Bash Here，创建一个SSH key，这里用到了非对称公钥加密体系，生成的公钥放到github的网站上，二生成的私钥放在自己的电脑上，每当需要将文件上传到github上时，服务器就会用事先的公钥与你给出的私钥进行验证，验证是否是真正的用户在操作（原理类似于数字签名）。通过如下命令生成公私钥：
#+BEGIN_SRC bash
ssh-keygen -t rsa -C "你的github邮箱"
#+END_SRC
期间会要求你输入密码，并会给出存放生成的公钥在哪一个文件夹中。我们在这个文件夹中的id_rsa.pub中获得我们账户的公钥。
#+DOWNLOADED: file:F%3A/org/%E5%9B%BE%E7%89%87/1803727-20200125171126826-2087303938.jpg @ 2020-09-10 20:03:57
[[file:%E8%A7%A3%E5%86%B3%E5%86%B2%E7%AA%81/2020-09-10_20-03-57_1803727-20200125171126826-2087303938.jpg]]
2、将公钥添加到github自己的网站设置上，注意格式（打开的id_rsa.hub文件中不要将最后的邮箱也复制上去，这一点注意看github上的添加英文提醒）
#+DOWNLOADED: file:F%3A/org/%E5%9B%BE%E7%89%87/1803727-20200125171143306-574498943.png @ 2020-09-10 20:04:21
[[file:%E8%A7%A3%E5%86%B3%E5%86%B2%E7%AA%81/2020-09-10_20-04-21_1803727-20200125171143306-574498943.png]]
* 多人协作
- 查看远程库信息，使用git remote -v；
- 本地新建的分支如果不推送到远程，对其他人就是不可见的；
- 从本地推送分支，使用git push origin branch-name，如果推送失败，先用git pull抓取远程的新提交；
- 在本地创建和远程分支对应的分支，使用git checkout -b branch-name origin/branch-name，本地和远程分支的名称最好一致；
- 建立本地分支和远程分支的关联，使用git branch --set-upstream branch-name origin/branch-name；
- 从远程抓取分支，使用git pull，如果有冲突，要先处理冲突。

当你从远程仓库克隆时，实际上Git自动把本地的master分支和远程的master分支对应起来了，并且，远程仓库的默认名称是origin。

要查看远程库的信息，用git remote：
#+BEGIN_SRC bash
$ git remote
origin
#+END_SRC
或者，用git remote -v显示更详细的信息：
#+BEGIN_SRC bash
$ git remote -v
origin  git@github.com:michaelliao/learngit.git (fetch)
origin  git@github.com:michaelliao/learngit.git (push)
#+END_SRC
上面显示了可以抓取和推送的origin的地址。如果没有推送权限，就看不到push的地址。
** 推送分支
推送分支，就是把该分支上的所有本地提交推送到远程库。推送时，要指定本地分支，这样，Git就会把该分支推送到远程库对应的远程分支上：
#+BEGIN_SRC bash
$ git push origin master
#+END_SRC
如果要推送其他分支，比如dev，就改成：
#+BEGIN_SRC bash
$ git push origin dev
#+END_SRC
但是，并不是一定要把本地分支往远程推送，那么，哪些分支需要推送，哪些不需要呢？
- master分支是主分支，因此要时刻与远程同步；
- dev分支是开发分支，团队所有成员都需要在上面工作，所以也需要与远程同步；
- bug分支只用于在本地修复bug，就没必要推到远程了，除非老板要看看你每周到底修复了几个bug；
- feature分支是否推到远程，取决于你是否和你的小伙伴合作在上面开发。

总之，就是在Git中，分支完全可以在本地自己藏着玩，是否推送，视你的心情而定！
** 抓取分支
多人协作时，大家都会往master和dev分支上推送各自的修改。

现在，模拟一个你的小伙伴，可以在另一台电脑（注意要把SSH Key添加到GitHub）或者同一台电脑的另一个目录下克隆：
#+BEGIN_SRC bash
$ git clone git@github.com:michaelliao/learngit.git
Cloning into 'learngit'...
remote: Counting objects: 40, done.
remote: Compressing objects: 100% (21/21), done.
remote: Total 40 (delta 14), reused 40 (delta 14), pack-reused 0
Receiving objects: 100% (40/40), done.
Resolving deltas: 100% (14/14), done.
#+END_SRC
当你的小伙伴从远程库clone时，默认情况下，你的小伙伴只能看到本地的master分支。不信可以用git branch命令看看：
#+BEGIN_SRC bash
 $ git branch
 * master
#+END_SRC
现在，你的小伙伴要在dev分支上开发，就必须创建远程origin的dev分支到本地，于是他用这个命令创建本地dev分支：
#+BEGIN_SRC bash
$ git checkout -b dev origin/dev
#+END_SRC
现在，他就可以在dev上继续修改，然后，时不时地把dev分支push到远程：
#+BEGIN_SRC bash
$ git add env.txt

$ git commit -m "add env"
[dev 7a5e5dd] add env
 1 file changed, 1 insertion(+)
 create mode 100644 env.txt

$ git push origin dev
Counting objects: 3, done.
Delta compression using up to 4 threads.
Compressing objects: 100% (2/2), done.
Writing objects: 100% (3/3), 308 bytes | 308.00 KiB/s, done.
Total 3 (delta 0), reused 0 (delta 0)
To github.com:michaelliao/learngit.git
   f52c633..7a5e5dd  dev -> dev
#+END_SRC
你的小伙伴已经向origin/dev分支推送了他的提交，而碰巧你也对同样的文件作了修改，并试图推送：
#+BEGIN_SRC bash 
$ cat env.txt
env

$ git add env.txt

$ git commit -m "add new env"
[dev 7bd91f1] add new env
 1 file changed, 1 insertion(+)
 create mode 100644 env.txt

$ git push origin dev
To github.com:michaelliao/learngit.git
 ! [rejected]        dev -> dev (non-fast-forward)
error: failed to push some refs to 'git@github.com:michaelliao/learngit.git'
hint: Updates were rejected because the tip of your current branch is behind
hint: its remote counterpart. Integrate the remote changes (e.g.
hint: 'git pull ...') before pushing again.
hint: See the 'Note about fast-forwards' in 'git push --help' for details.
#+END_SRC
推送失败，因为你的小伙伴的最新提交和你试图推送的提交有冲突，解决办法也很简单，Git已经提示我们，先用git pull把最新的提交从origin/dev抓下来，然后，在本地合并，解决冲突，再推送：
#+BEGIN_SRC bash
$ git pull
There is no tracking information for the current branch.
Please specify which branch you want to merge with.
See git-pull(1) for details.

    git pull <remote> <branch>

If you wish to set tracking information for this branch you can do so with:

    git branch --set-upstream-to=origin/<branch> dev
#+END_SRC
git pull也失败了，原因是没有指定本地dev分支与远程origin/dev分支的链接，根据提示，设置dev和origin/dev的链接：
#+BEGIN_SRC bash
$ git branch --set-upstream-to=origin/dev dev
Branch 'dev' set up to track remote branch 'dev' from 'origin'.
#+END_SRC
再pull：
#+BEGIN_SRC bash
$ git pull
Auto-merging env.txt
CONFLICT (add/add): Merge conflict in env.txt
Automatic merge failed; fix conflicts and then commit the result.
#+END_SRC
这回git pull成功，但是合并有冲突，需要手动解决，解决的方法和分支管理中的解决冲突完全一样。解决后，提交，再push：
#+BEGIN_SRC bash
$ git commit -m "fix env conflict"
[dev 57c53ab] fix env conflict

$ git push origin dev
Counting objects: 6, done.
Delta compression using up to 4 threads.
Compressing objects: 100% (4/4), done.
Writing objects: 100% (6/6), 621 bytes | 621.00 KiB/s, done.
Total 6 (delta 0), reused 0 (delta 0)
To github.com:michaelliao/learngit.git
   7a5e5dd..57c53ab  dev -> dev
#+END_SRC
因此，多人协作的工作模式通常是这样：

- 首先，可以试图用git push origin <branch-name>推送自己的修改；
- 如果推送失败，则因为远程分支比你的本地更新，需要先用git pull试图合并；
- 如果合并有冲突，则解决冲突，并在本地提交；
- 没有冲突或者解决掉冲突后，再用git push origin <branch-name>推送就能成功！

如果git pull提示no tracking information，则说明本地分支和远程分支的链接关系没有创建，用命令git branch --set-upstream-to <branch-name> origin/<branch-name>。

这就是多人协作的工作模式，一旦熟悉了，就非常简单。
* Git 基础 - 远程仓库的使用
** 远程仓库的使用
为了能在任意 Git 项目上协作，你需要知道如何管理自己的远程仓库。 远程仓库是指托管在因特网或其他网络中的你的项目的版本库。 你可以有好几个远程仓库，通常有些仓库对你只读，有些则可以读写。 与他人协作涉及管理远程仓库以及根据需要推送或拉取数据。 管理远程仓库包括了解如何添加远程仓库、移除无效的远程仓库、管理不同的远程分支并定义它们是否被跟踪等等。 在本节中，我们将介绍一部分远程管理的技能。
#+BEGIN_EXAMPLE
远程仓库可以在你的本地主机上

你完全可以在一个“远程”仓库上工作，而实际上它在你本地的主机上。 词语“远程”未必表示仓库在网络或互联网上的其它位置，而只是表示它在别处。 在这样的远程仓库上工作，仍然需要和其它远程仓库上一样的标准推送、拉取和抓取操作。
#+END_EXAMPLE
** 查看远程仓库
如果想查看你已经配置的远程仓库服务器，可以运行 git remote 命令。 它会列出你指定的每一个远程服务器的简写。 如果你已经克隆了自己的仓库，那么至少应该能看到 origin ——这是 Git 给你克隆的仓库服务器的默认名字：
#+BEGIN_SRC bash
$ git clone https://github.com/schacon/ticgit
Cloning into 'ticgit'...
remote: Reusing existing pack: 1857, done.
remote: Total 1857 (delta 0), reused 0 (delta 0)
Receiving objects: 100% (1857/1857), 374.35 KiB | 268.00 KiB/s, done.
Resolving deltas: 100% (772/772), done.
Checking connectivity... done.
$ cd ticgit
$ git remote
origin
#+END_SRC
你也可以指定选项 -v，会显示需要读写远程仓库使用的 Git 保存的简写与其对应的 URL。
#+BEGIN_SRC bash
$ git remote -v
origin	https://github.com/schacon/ticgit (fetch)
origin	https://github.com/schacon/ticgit (push)
#+END_SRC
如果你的远程仓库不止一个，该命令会将它们全部列出。 例如，与几个协作者合作的，拥有多个远程仓库的仓库看起来像下面这样：
#+BEGIN_SRC bash
$ cd grit
$ git remote -v
bakkdoor  https://github.com/bakkdoor/grit (fetch)
bakkdoor  https://github.com/bakkdoor/grit (push)
cho45     https://github.com/cho45/grit (fetch)
cho45     https://github.com/cho45/grit (push)
defunkt   https://github.com/defunkt/grit (fetch)
defunkt   https://github.com/defunkt/grit (push)
koke      git://github.com/koke/grit.git (fetch)
koke      git://github.com/koke/grit.git (push)
origin    git@github.com:mojombo/grit.git (fetch)
origin    git@github.com:mojombo/grit.git (push)
#+END_SRC
这表示我们能非常方便地拉取其它用户的贡献。我们还可以拥有向他们推送的权限，这里暂不详述。

注意这些远程仓库使用了不同的协议。
** 添加远程仓库
我们在之前的章节中已经提到并展示了 git clone 命令是如何自行添加远程仓库的， 不过这里将告诉你如何自己来添加它。 运行 git remote add <shortname> <url> 添加一个新的远程 Git 仓库，同时指定一个方便使用的简写：
#+BEGIN_SRC bash
$ git remote
origin
$ git remote add pb https://github.com/paulboone/ticgit
$ git remote -v
origin	https://github.com/schacon/ticgit (fetch)
origin	https://github.com/schacon/ticgit (push)
pb	https://github.com/paulboone/ticgit (fetch)
pb	https://github.com/paulboone/ticgit (push)
#+END_SRC
现在你可以在命令行中使用字符串 pb 来代替整个 URL。 例如，如果你想拉取 Paul 的仓库中有但你没有的信息，可以运行 git fetch pb：
#+BEGIN_SRC bash
$ git fetch pb
remote: Counting objects: 43, done.
remote: Compressing objects: 100% (36/36), done.
remote: Total 43 (delta 10), reused 31 (delta 5)
Unpacking objects: 100% (43/43), done.
From https://github.com/paulboone/ticgit
 * [new branch]      master     -> pb/master
 * [new branch]      ticgit     -> pb/ticgit
#+END_SRC
现在 Paul 的 master 分支可以在本地通过 pb/master 访问到——你可以将它合并到自己的某个分支中， 或者如果你想要查看它的话，可以检出一个指向该点的本地分支。 
** 从远程仓库中抓取与拉取
就如刚才所见，从远程仓库中获得数据，可以执行：
#+BEGIN_SRC bash
$ git fetch <remote>
#+END_SRC
这个命令会访问远程仓库，从中拉取所有你还没有的数据。 执行完成后，你将会拥有那个远程仓库中所有分支的引用，可以随时合并或查看。

如果你使用 clone 命令克隆了一个仓库，命令会自动将其添加为远程仓库并默认以 “origin” 为简写。 所以，git fetch origin 会抓取克隆（或上一次抓取）后新推送的所有工作。 必须注意 git fetch 命令只会将数据下载到你的本地仓库——它并不会自动合并或修改你当前的工作。 当准备好时你必须手动将其合并入你的工作。

如果你的当前分支设置了跟踪远程分支（阅读下一节和 Git 分支 了解更多信息）， 那么可以用 git pull 命令来自动抓取后合并该远程分支到当前分支。 这或许是个更加简单舒服的工作流程。默认情况下，git clone 命令会自动设置本地 master 分支跟踪克隆的远程仓库的 master 分支（或其它名字的默认分支）。 运行 git pull 通常会从最初克隆的服务器上抓取数据并自动尝试合并到当前所在的分支。
** 推送到远程仓库
当你想分享你的项目时，必须将其推送到上游。 这个命令很简单：git push <remote> <branch>。 当你想要将 master 分支推送到 origin 服务器时（再次说明，克隆时通常会自动帮你设置好那两个名字）， 那么运行这个命令就可以将你所做的备份到服务器：
#+BEGIN_SRC bash
$ git push origin master
#+END_SRC
只有当你有所克隆服务器的写入权限，并且之前没有人推送过时，这条命令才能生效。 当你和其他人在同一时间克隆，他们先推送到上游然后你再推送到上游，你的推送就会毫无疑问地被拒绝。 你必须先抓取他们的工作并将其合并进你的工作后才能推送。 
** 查看某个远程仓库
如果想要查看某一个远程仓库的更多信息，可以使用 git remote show <remote> 命令。 如果想以一个特定的缩写名运行这个命令，例如 origin，会得到像下面类似的信息：
#+BEGIN_SRC bash
 $ git remote show origin
 * remote origin
   Fetch URL: https://github.com/schacon/ticgit
   Push  URL: https://github.com/schacon/ticgit
   HEAD branch: master
   Remote branches:
     master                               tracked
     dev-branch                           tracked
   Local branch configured for 'git pull':
     master merges with remote master
   Local ref configured for 'git push':
     master pushes to master (up to date)
#+END_SRC

它同样会列出远程仓库的 URL 与跟踪分支的信息。 这些信息非常有用，它告诉你正处于 master 分支，并且如果运行 git pull， 就会抓取所有的远程引用，然后将远程 master 分支合并到本地 master 分支。 它也会列出拉取到的所有远程引用。

这是一个经常遇到的简单例子。 如果你是 Git 的重度使用者，那么还可以通过 git remote show 看到更多的信息。
#+BEGIN_SRC bash
 $ git remote show origin
 * remote origin
   URL: https://github.com/my-org/complex-project
   Fetch URL: https://github.com/my-org/complex-project
   Push  URL: https://github.com/my-org/complex-project
   HEAD branch: master
   Remote branches:
     master                           tracked
     dev-branch                       tracked
     markdown-strip                   tracked
     issue-43                         new (next fetch will store in remotes/origin)
     issue-45                         new (next fetch will store in remotes/origin)
     refs/remotes/origin/issue-11     stale (use 'git remote prune' to remove)
   Local branches configured for 'git pull':
     dev-branch merges with remote dev-branch
     master     merges with remote master
   Local refs configured for 'git push':
     dev-branch                     pushes to dev-branch                     (up to date)
     markdown-strip                 pushes to markdown-strip                 (up to date)
     master                         pushes to master                         (up to date)
#+END_SRC

这个命令列出了当你在特定的分支上执行 git push 会自动地推送到哪一个远程分支。 它也同样地列出了哪些远程分支不在你的本地，哪些远程分支已经从服务器上移除了， 还有当你执行 git pull 时哪些本地分支可以与它跟踪的远程分支自动合并。
** 远程仓库的重命名与移除
你可以运行 git remote rename 来修改一个远程仓库的简写名。 例如，想要将 pb 重命名为 paul，可以用 git remote rename 这样做：
#+BEGIN_SRC bash
$ git remote rename pb paul
$ git remote
origin
paul
#+END_SRC
值得注意的是这同样也会修改你所有远程跟踪的分支名字。 那些过去引用 pb/master 的现在会引用 paul/master。

如果因为一些原因想要移除一个远程仓库——你已经从服务器上搬走了或不再想使用某一个特定的镜像了， 又或者某一个贡献者不再贡献了——可以使用 git remote remove 或 git remote rm ：
#+BEGIN_SRC bash
$ git remote remove paul
$ git remote
origin
#+END_SRC

一旦你使用这种方式删除了一个远程仓库，那么所有和这个远程仓库相关的远程跟踪分支以及配置信息也会一起被删除。
* git命令
一般来说，日常使用只要记住下图6个命令，就可以了
#+DOWNLOADED: file:F%3A/org/%E5%9B%BE%E7%89%87/bg2015120901.png @ 2020-09-11 12:42:17
[[file:git%E5%91%BD%E4%BB%A4/2020-09-11_12-42-16_bg2015120901.png]]
** 新建代码库
#+BEGIN_SRC bash
# 在当前目录新建一个Git代码库
$ git init

# 新建一个目录，将其初始化为Git代码库
$ git init [project-name]

# 下载一个项目和它的整个代码历史
$ git clone [url]
#+END_SRC
** 配置
Git的设置文件为.gitconfig，它可以在用户主目录下（全局配置），也可以在项目目录下（项目配置）。
#+BEGIN_SRC bash
# 显示当前的Git配置
$ git config --list

# 编辑Git配置文件
$ git config -e [--global]

# 设置提交代码时的用户信息
$ git config [--global] user.name "[name]"
$ git config [--global] user.email "[email address]"
#+END_SRC
** 增加/删除文件
#+BEGIN_SRC bash
# 添加指定文件到暂存区
$ git add [file1] [file2] ...

# 添加指定目录到暂存区，包括子目录
$ git add [dir]

# 添加当前目录的所有文件到暂存区
$ git add .

# 添加每个变化前，都会要求确认
# 对于同一个文件的多处变化，可以实现分次提交
$ git add -p

# 删除工作区文件，并且将这次删除放入暂存区
$ git rm [file1] [file2] ...

# 停止追踪指定文件，但该文件会保留在工作区
$ git rm --cached [file]

# 改名文件，并且将这个改名放入暂存区
$ git mv [file-original] [file-renamed]
#+END_SRC
** 代码提交
#+BEGIN_SRC bash 
# 提交暂存区到仓库区
$ git commit -m [message]

# 提交暂存区的指定文件到仓库区
$ git commit [file1] [file2] ... -m [message]

# 提交工作区自上次commit之后的变化，直接到仓库区
$ git commit -a

# 提交时显示所有diff信息
$ git commit -v

# 使用一次新的commit，替代上一次提交
# 如果代码没有任何新变化，则用来改写上一次commit的提交信息
$ git commit --amend -m [message]

# 重做上一次commit，并包括指定文件的新变化
$ git commit --amend [file1] [file2] ...
#+END_SRC
** 分支
#+BEGIN_SRC bash
# 列出所有本地分支
$ git branch

# 列出所有远程分支
$ git branch -r

# 列出所有本地分支和远程分支
$ git branch -a

# 新建一个分支，但依然停留在当前分支
$ git branch [branch-name]

# 新建一个分支，并切换到该分支
$ git checkout -b [branch]

# 新建一个分支，指向指定commit
$ git branch [branch] [commit]

# 新建一个分支，与指定的远程分支建立追踪关系
$ git branch --track [branch] [remote-branch]

# 切换到指定分支，并更新工作区
$ git checkout [branch-name]

# 切换到上一个分支
$ git checkout -

# 建立追踪关系，在现有分支与指定的远程分支之间
$ git branch --set-upstream [branch] [remote-branch]

# 合并指定分支到当前分支
$ git merge [branch]

# 选择一个commit，合并进当前分支
$ git cherry-pick [commit]

# 删除分支
$ git branch -d [branch-name]

# 删除远程分支
$ git push origin --delete [branch-name]
$ git branch -dr [remote/branch]
#+END_SRC
** 标签
#+BEGIN_SRC bash
# 列出所有tag
$ git tag

# 新建一个tag在当前commit
$ git tag [tag]

# 新建一个tag在指定commit
$ git tag [tag] [commit]

# 删除本地tag
$ git tag -d [tag]

# 删除远程tag
$ git push origin :refs/tags/[tagName]

# 查看tag信息
$ git show [tag]

# 提交指定tag
$ git push [remote] [tag]

# 提交所有tag
$ git push [remote] --tags

# 新建一个分支，指向某个tag
$ git checkout -b [branch] [tag]
#+END_SRC
** 查看信息
#+BEGIN_SRC bash 
# 显示有变更的文件
$ git status

# 显示当前分支的版本历史
$ git log

# 显示commit历史，以及每次commit发生变更的文件
$ git log --stat

# 搜索提交历史，根据关键词
$ git log -S [keyword]

# 显示某个commit之后的所有变动，每个commit占据一行
$ git log [tag] HEAD --pretty=format:%s

# 显示某个commit之后的所有变动，其"提交说明"必须符合搜索条件
$ git log [tag] HEAD --grep feature

# 显示某个文件的版本历史，包括文件改名
$ git log --follow [file]
$ git whatchanged [file]

# 显示指定文件相关的每一次diff
$ git log -p [file]

# 显示过去5次提交
$ git log -5 --pretty --oneline

# 显示所有提交过的用户，按提交次数排序
$ git shortlog -sn

# 显示指定文件是什么人在什么时间修改过
$ git blame [file]

# 显示暂存区和工作区的差异
$ git diff

# 显示暂存区和上一个commit的差异
$ git diff --cached [file]

# 显示工作区与当前分支最新commit之间的差异
$ git diff HEAD

# 显示两次提交之间的差异
$ git diff [first-branch]...[second-branch]

# 显示今天你写了多少行代码
$ git diff --shortstat "@{0 day ago}"

# 显示某次提交的元数据和内容变化
$ git show [commit]

# 显示某次提交发生变化的文件
$ git show --name-only [commit]

# 显示某次提交时，某个文件的内容
$ git show [commit]:[filename]

# 显示当前分支的最近几次提交
$ git reflog
#+END_SRC
** 远程同步
#+BEGIN_SRC bash
# 下载远程仓库的所有变动
$ git fetch [remote]

# 显示所有远程仓库
$ git remote -v

# 显示某个远程仓库的信息
$ git remote show [remote]

# 增加一个新的远程仓库，并命名
$ git remote add [shortname] [url]

# 取回远程仓库的变化，并与本地分支合并
$ git pull [remote] [branch]

# 上传本地指定分支到远程仓库
$ git push [remote] [branch]

# 强行推送当前分支到远程仓库，即使有冲突
$ git push [remote] --force

# 推送所有分支到远程仓库
$ git push [remote] --all
#+END_SRC
** 撤销
#+BEGIN_SRC bash
# 恢复暂存区的指定文件到工作区
$ git checkout [file]

# 恢复某个commit的指定文件到暂存区和工作区
$ git checkout [commit] [file]

# 恢复暂存区的所有文件到工作区
$ git checkout .

# 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变
$ git reset [file]

# 重置暂存区与工作区，与上一次commit保持一致
$ git reset --hard

# 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变
$ git reset [commit]

# 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致
$ git reset --hard [commit]

# 重置当前HEAD为指定commit，但保持暂存区和工作区不变
$ git reset --keep [commit]

# 新建一个commit，用来撤销指定commit
# 后者的所有变化都将被前者抵消，并且应用到当前分支
$ git revert [commit]

# 暂时将未提交的变化移除，稍后再移入
$ git stash
$ git stash pop
#+END_SRC
** 其他
#+BEGIN_SRC bash
# 生成一个可供发布的压缩包
$ git archive
#+END_SRC
* 问题集锦
** warning: LF will be replaced by CRLF in ** 的原因及解决办法
今天在使用git add 命令的时候，弹出了一个警告 warning: LF will be replaced by CRLF in ******（具体的一个文件）

*** 原因：
LF和CRLF其实都是换行符，但是不同的是，LF是linux和Unix系统的换行符，CRLF是window 系统的换行符。这就给跨平台的协作的项目带来了问题，保存文件到底是使用哪个标准呢？ git为了解决这个问题，提供了一个”换行符自动转换“的功能，并且这个功能是默认处于”自动模式“即开启状态的。

这个换行符自动转换会把自动把你代码里 与你当前操作系统不相同的换行的方式 转换成当前系统的换行方式（即LF和CRLF 之间的转换），这样一来，当你提交代码的时候，即使你没有修改过某个文件，也被git认为你修改过了，从而提示"LF will be replaced by CRLF in *****"

*** 解决
最简单的一种办法就是把自动转换功能关掉即可。

输入命令 ：
#+BEGIN_SRC bash 
git rm -r --cached .  #这个貌似是用于清楚add的缓存

git config core.autocrlf false (仅对当前git仓库有效）

git config --global core.autocrlf false (全局有效）
#+END_SRC
然后重新提交代码即可。
