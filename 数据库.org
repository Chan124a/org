* 数据密集型应用的基本设计原则
** 可靠性
当出现意外情况如硬件\\软件故障\\人为失误等,系统应可以继续正常运转.

故障与失效的意义不同.故障意味着组件偏离其正常规格,而失效意味系统作为一个整体停止,无法向用户提供所需的服务.

由于不太可能将故障概率降低至零,通常设计容错机制来避免从故障引发系统失效.
*** 可以被消除的故障类型
**** 硬件故障
硬盘崩溃,内存故障,电网停电,误拔网线等等.

研究证明硬盘的平均无故障时间(MTTF)约为10~50年.在一个拥有10000个磁盘的存储集群中,预期平均每天有一个磁盘发生故障.

可以通过为硬件添加冗余来减少系统故障率.例如对磁盘添加RAID,服务器配置双电源,热拔插CPU.
**** 软件错误
导致软件故障的bug通常会长时间处于引而不发的状态,知道碰到特定的触发条件.
**** 人为失误
例如运维人员的配置错误.
** 可扩展性
随着规模的增长,例如数据量\\流量或复杂性,系统应以合理的方式来匹配这种增长.

可扩展性是用来描述系统应对负载增加能力的术语.

*** 负载
负载可以用负载参数进行描述.参数的最佳选择取决于系统的体系结构,可以是web服务器的每秒请求处理次数,数据库中写入的比例,缓存命中率等.

*** 性能
可以用吞吐量\\服务响应时间作为性能指标.

延迟和响应时间表达的意义不同.延迟指的是请求花费在处理上的时间.响应=延迟+网络延迟+排队延迟.

中位数指标(也称为50百分位数)非常适合描述多少用户需要等待多长时间:一半的用户请求的服务时间少于中位数响应时间,另一半则多于中位数的时间.

*** 应对负载增加的方法
垂直扩展:升级到更强大的机器.
水平扩展:将负载分布到多个更小的机器.
** 可维护性
随着时间的推移,许多新的人员参与到系统开发和运维,以维护现有功能或适配新场景等,系统都应该高效运转.

提升可维护性的设计原则:
- 可运维性:方便运营团队保持系统平稳运行.自动化工具,监测工具
- 简单性:简化系统复杂度,使新工程师能够轻松理解系统..使用抽象的设计.
- 可演化性:后续工程师能够轻松对系统进行改进,并根据需求变化将其适配到非典型场景.
* 数据模型与查询语言
数据模型的基本设计思想:每层都通过一个简洁的数据模型来隐藏下层的复杂性.
** 关系模型
数据被组织层关系,在sql中称为表,其中每个关系都是元组的无序集合(在sql中称为行)
** 文档模型
像简历这样一对多(一个人可能有多份工作经历和多个教育经历)的数据结构,主要是一个自包含的文档,因此用JSON表示非常合适.

面向文档的数据库(如MongoDB,RethinkDB,CouchDB,Espresso)都支持该数据模型.

一对多得关系形成了树状结构.
** 多对一的关系
使用ID来保存内容的好处是它对人类没有任何意义,所以永远不需要直接改变:即使ID标识的信息发生了变化,它也可以保持不变.
任何对人类有意义的东西都可能在将来某个时刻发生改变.
如果这些信息被复制,那么所有的冗余副本也都需要更新.这会导致更多的写入开销,并且存在数据不一致的风险.
消除这种重复正是数据库规范化的核心思想.

这种数据规范化需要表达多对一的关系.

文档模型不适合表达多对一的关系.
而对于关系数据库,由于支持联结操作,可以方便地通过ID来引用其它表中的行,所以适合表示多对一的关系.

如果数据库本身不支持联结,则必须在应用程序代码中,通过对数据库进行多次查询来模拟联结.
* 术语
** 扇出
在事务处理系统中,扇出用来描述为了服务一个输入请求而需要做的请求总数.
