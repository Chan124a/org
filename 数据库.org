* 数据密集型应用的基本设计原则
** 可靠性
当出现意外情况如硬件\\软件故障\\人为失误等,系统应可以继续正常运转.

故障与失效的意义不同.故障意味着组件偏离其正常规格,而失效意味系统作为一个整体停止,无法向用户提供所需的服务.

由于不太可能将故障概率降低至零,通常设计容错机制来避免从故障引发系统失效.
*** 可以被消除的故障类型
**** 硬件故障
硬盘崩溃,内存故障,电网停电,误拔网线等等.

研究证明硬盘的平均无故障时间(MTTF)约为10~50年.在一个拥有10000个磁盘的存储集群中,预期平均每天有一个磁盘发生故障.

可以通过为硬件添加冗余来减少系统故障率.例如对磁盘添加RAID,服务器配置双电源,热拔插CPU.
**** 软件错误
导致软件故障的bug通常会长时间处于引而不发的状态,知道碰到特定的触发条件.
**** 人为失误
例如运维人员的配置错误.
** 可扩展性
随着规模的增长,例如数据量\\流量或复杂性,系统应以合理的方式来匹配这种增长.

可扩展性是用来描述系统应对负载增加能力的术语.

*** 负载
负载可以用负载参数进行描述.参数的最佳选择取决于系统的体系结构,可以是web服务器的每秒请求处理次数,数据库中写入的比例,缓存命中率等.

*** 性能
可以用吞吐量\\服务响应时间作为性能指标.

延迟和响应时间表达的意义不同.延迟指的是请求花费在处理上的时间.响应=延迟+网络延迟+排队延迟.

中位数指标(也称为50百分位数)非常适合描述多少用户需要等待多长时间:一半的用户请求的服务时间少于中位数响应时间,另一半则多于中位数的时间.

*** 应对负载增加的方法
垂直扩展:升级到更强大的机器.
水平扩展:将负载分布到多个更小的机器.
** 可维护性
随着时间的推移,许多新的人员参与到系统开发和运维,以维护现有功能或适配新场景等,系统都应该高效运转.

提升可维护性的设计原则:
- 可运维性:方便运营团队保持系统平稳运行.自动化工具,监测工具
- 简单性:简化系统复杂度,使新工程师能够轻松理解系统..使用抽象的设计.
- 可演化性:后续工程师能够轻松对系统进行改进,并根据需求变化将其适配到非典型场景.
* 数据模型与查询语言
数据模型的基本设计思想:每层都通过一个简洁的数据模型来隐藏下层的复杂性.
** 关系模型
数据被组织层关系,在sql中称为表,其中每个关系都是元组的无序集合(在sql中称为行)
** 文档模型
像简历这样一对多(一个人可能有多份工作经历和多个教育经历)的数据结构,主要是一个自包含的文档,因此用JSON表示非常合适.

面向文档的数据库(如MongoDB,RethinkDB,CouchDB,Espresso)都支持该数据模型.

一对多得关系形成了树状结构.
** 多对一的关系
使用ID来保存内容的好处是它对人类没有任何意义,所以永远不需要直接改变:即使ID标识的信息发生了变化,它也可以保持不变.
任何对人类有意义的东西都可能在将来某个时刻发生改变.
如果这些信息被复制,那么所有的冗余副本也都需要更新.这会导致更多的写入开销,并且存在数据不一致的风险.
消除这种重复正是数据库规范化的核心思想.

这种数据规范化需要表达多对一的关系.

文档模型不适合表达多对一的关系.
而对于关系数据库,由于支持联结操作,可以方便地通过ID来引用其它表中的行,所以适合表示多对一的关系.

如果数据库本身不支持联结,则必须在应用程序代码中,通过对数据库进行多次查询来模拟联结.
** 数据查询语言
数据查询语言分为声明式和命令式.
- 声明式:SQL
- 命令式:IMS,CODASYL

命令式语言告诉计算机以特定顺序执行某些操作.
声明式语言只需指定所需的数据模式,结果需要满足什么条件,以及如何转换数据,而不需要指明如何实现这一目标.查询优化器会决定执行顺序.

*** MapReduce查询
MapReduce是介于声明式和命令式之间的查询语言:查询的逻辑用代码片段表示,基于函数式编程中的map和reduce函数实现.

*** 聚合管道查询语言

** 图状数据模型
图状数据模型适合处理多对多的关系.

图由两种对象组成:顶点和边.
*** 图模型
每个顶点包括:
- 唯一的标识符
- 出边的集合
- 入边的集合
- 属性的集合

每个边包括:
- 唯一的标识符
- 边开始的顶点
- 边结束的顶点
- 描述两个顶点之间关系类型的标签
- 属性的集合(键-值对)

图模型的特性:
- 任何顶点都可以连接到其他顶点.
- 给定某个顶点,可以快速得到所有入边和出边.
- 通过使用不同类型的标签,可以在图中存储多种不同类型的信息,同时仍然保持整洁的数据模型.
**** Cypher查询语言
*** 三元存储模型
* 存储引擎
** 日志结构的存储引擎
日志是一个仅支持追加式更新的数据文件.

索引是一种可以高效查找数据库中特定键的值的数据结构.

由于每次写数据时都要更新索引,任何类型的索引通常都会降低写的速度.

索引可以加快读取查询,但是每个索引都会引入减慢写的速度,这需要作出权衡的设计.
*** 哈希索引
哈希索引指的是键-值类型的索引.

**** 内存哈希表
用内存中的hash map来反映写入数据的偏移量.
key的个数受到内存大小的限制,而值的数据量则可以超过内存大小.
这种索引方式适合每个键的值频繁更新的场景.

文件格式:最好的文件格式是二进制格式,以字节为单位记录字符串长度,然后记录原始字符串.
删除记录:删除键值时,必须添加一个删除记录,用于合并时可以丢弃这个键的所有值.
崩溃恢复:崩溃后,内存中的hash map将丢失,可以通过将每个段的hash map存到磁盘上,加快恢复速度.
数据一致性:可通过校验值发现损坏部分数据.
并发控制:由于写入按先后顺序追加到文件中,通常只有一个写线程,但是读线程可以有多个.

局限性:
- 哈希表必须全部放入内存.
- 区间查询效率不高
**** SSTables(排序字符串表)和LSM-tree
将key-value对的顺序按键排序.

优点:
- 合并段更加高效
- 在文件中查找特定的键时,只需查找排序前后键的值,所以不需要在内存中保存所有键的索引.
- 读请求通常需要扫描某个范围内的多个key-value对,可以将这些key-value对记录保存到一个块中并在写入磁盘前进行压缩.然后将索引指向压缩块的开头.

工作流程:
1. 写入时,添加到内存中的平衡树数据结构中(例如红黑树)
2. 当内存表大于某个阈值,将其作为SSTable文件写入磁盘.
3. 处理读请求时,先在内存表中查找键,然后查找最新的磁盘段文件.
4. 后台周期对段执行合并与压缩过程.

可以用日志文件处理数据库崩溃的问题.

基于合并和压缩排序文件原理的存储引擎通常都被称为LSM存储引擎(Log-Structured Merge-Tree,LSM-Tree).
LSM-tree的基本思想:保存在后台合并的一系列SSTable.
由于数据按顺序存储,可以高效执行区间查询,由于磁盘是顺序写入,可以支持非常高的写入吞吐量.

性能优化:
1. 当查找某个不存在的键时,必须先检查内存表,然后将段一直回溯到最旧的段文件.为了优化这种访问,可以使用布隆过滤器这种内存高效的数据结构.
2. 不同的策略会影响SSTables压缩和合并的顺序和时机.最常见的方式是大小分级和分层压缩.

**** B-trees
B-tree将数据库分解成固定大小的块或页.页是内部读写的最小单位.

B-tree中一个页所包含的子页引用数量称为分支因子.

B-tree底层的基本写操作是使用新数据覆盖磁盘上的旧页.

可以使用预写日志(write-head log,WAL)解决数据库崩溃的问题.

需要用锁解决B-tree的并发访问.

***** 优化
使用写时复制解决中途崩溃的问题:修改的页被写入不同的位置,树中父页的新版本被创建,并指向新的位置.

保存键的缩略信息,而不是完整的键,可节省页空间.

对树进行布局,使得相邻叶子页可以按顺序保存在磁盘上,加快B-teee的查询速度.

添加额外的指针到树中,用于访问同级的兄弟页.

使用B-tree的变体如分形树.


**** 对比B-tree和LSM-treee

***** LSM-tree的优点
B-tree的索引至少写两次数据:一次写入预写日志,一次写入树的页(可能有分裂).
即使页中只有几个字节的修改,也必须修改整个页.


** 面向页的存储引擎
* 术语
** 扇出
在事务处理系统中,扇出用来描述为了服务一个输入请求而需要做的请求总数.
