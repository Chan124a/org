* 命令
#+BEGIN_SRC bash
docker ps  #可以用来查看当前正在运行的容器
docker ps -a #查看所有容器，包括已停止运行的
docker images #可以查看docker registry上已有的镜像
docker run [OPTIONS] IMAGE [COMMAND] [ARG...]
#用于创建容器,参数使用方法可参考[官方文档](https://docs.docker.com/engine/reference/commandline/run/)
docker run busybox echo "111"  #用镜像busybox创建容器，然后执行命令echo，然后退出容器

docker exec -u root -t -i cpd /bin/bash #用于以root身份进入容器
#需要注意的是，在容器内以root身份安装软件将会导致宿主机也安装软件

docker attach 容器名 #用于进入容器

docker search 镜像名 #查找镜像

docker rm 容器名 #删除容器
docker rmi 镜像名 # 删除镜像

# 从容器拷贝文件到宿主机
docker cp mycontainer:/opt/testnew/file.txt /opt/test/
# 从宿主机拷贝文件到容器
docker cp /opt/test/file.txt mycontainer:/opt/testnew/
#+END_SRC
* 基本概念
** 镜像
我们都知道，操作系统分为 内核 和 用户空间。对于 Linux 而言，内核启动后，会挂载 root 文件系统为其提供用户空间支持。而 Docker 镜像（Image），就相当于是一个 root 文件系统。比如官方镜像 ubuntu:18.04 就包含了完整的一套 Ubuntu 18.04 最小系统的 root 文件系统。
Docker 镜像 是一个特殊的文件系统，除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数（如匿名卷、环境变量、用户等）。镜像 不包含 任何动态数据，其内容在构建之后也不会被改变。
*** 分层存储
因为镜像包含操作系统完整的 root 文件系统，其体积往往是庞大的，因此在 Docker 设计时，就充分利用 Union FS 的技术，将其设计为分层存储的架构。所以严格来说，镜像并非是像一个 ISO 那样的打包文件，镜像只是一个虚拟的概念，其实际体现并非由一个文件组成，而是由一组文件系统组成，或者说，由多层文件系统联合组成。
镜像构建时，会一层层构建，前一层是后一层的基础。每一层构建完就不会再发生改变，后一层上的任何改变只发生在自己这一层。比如，删除前一层文件的操作，实际不是真的删除前一层的文件，而是仅在当前层标记为该文件已删除。在最终容器运行的时候，虽然不会看到这个文件，但是实际上该文件会一直跟随镜像。因此，在构建镜像的时候，需要额外小心，每一层尽量只包含该层需要添加的东西，任何额外的东西应该在该层构建结束前清理掉。

分层存储的特征还使得镜像的复用、定制变的更为容易。甚至可以用之前构建好的镜像作为基础层，然后进一步添加新的层，以定制自己所需的内容，构建新的镜像。
** 容器
镜像（Image）和容器（Container）的关系，就像是面向对象程序设计中的 类 和 实例 一样，镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等。

容器的实质是进程，但与直接在宿主执行的进程不同，容器进程运行于属于自己的独立的 命名空间。因此容器可以拥有自己的 root 文件系统、自己的网络配置、自己的进程空间，甚至自己的用户 ID 空间。容器内的进程是运行在一个隔离的环境里，使用起来，就好像是在一个独立于宿主的系统下操作一样。这种特性使得容器封装的应用比直接在宿主运行更加安全。也因为这种隔离的特性，很多人初学 Docker 时常常会混淆容器和虚拟机。

前面讲过镜像使用的是分层存储，容器也是如此。每一个容器运行时，是以镜像为基础层，在其上创建一个当前容器的存储层，我们可以称这个为容器运行时读写而准备的存储层为 容器存储层。
容器存储层的生存周期和容器一样，容器消亡时，容器存储层也随之消亡。因此，任何保存于容器存储层的信息都会随容器删除而丢失。

按照 Docker 最佳实践的要求，容器不应该向其存储层内写入任何数据，容器存储层要保持无状态化。所有的文件写入操作，都应该使用 数据卷（Volume）、或者 绑定宿主目录，在这些位置的读写会跳过容器存储层，直接对宿主（或网络存储）发生读写，其性能和稳定性更高。

数据卷的生存周期独立于容器，容器消亡，数据卷不会消亡。因此，使用数据卷后，容器删除或者重新运行之后，数据却不会丢失。
** 仓库
镜像构建完成后，可以很容易的在当前宿主机上运行，但是，如果需要在其它服务器上使用这个镜像，我们就需要一个集中的存储、分发镜像的服务，Docker Registry 就是这样的服务。

一个 Docker Registry 中可以包含多个 仓库（Repository）；每个仓库可以包含多个 标签（Tag）；每个标签对应一个镜像。

通常，一个仓库会包含同一个软件不同版本的镜像，而标签就常用于对应该软件的各个版本。我们可以通过 <仓库名>:<标签> 的格式来指定具体是这个软件哪个版本的镜像。如果不给出标签，将以 latest 作为默认标签。

以 Ubuntu 镜像 为例，ubuntu 是仓库的名字，其内包含有不同的版本标签，如，16.04, 18.04。我们可以通过 ubuntu:16.04，或者 ubuntu:18.04 来具体指定所需哪个版本的镜像。如果忽略了标签，比如 ubuntu，那将视为 ubuntu:latest。

仓库名经常以 两段式路径 形式出现，比如 jwilder/nginx-proxy，前者往往意味着 Docker Registry 多用户环境下的用户名，后者则往往是对应的软件名。但这并非绝对，取决于所使用的具体 Docker Registry 的软件或服务。
*** Docker Registry 公开服务
Docker Registry 公开服务是开放给用户使用、允许用户管理镜像的 Registry 服务。一般这类公开服务允许用户免费上传、下载公开的镜像，并可能提供收费服务供用户管理私有镜像。

最常使用的 Registry 公开服务是官方的 Docker Hub，这也是默认的 Registry，并拥有大量的高质量的 官方镜像。除此以外，还有 Red Hat 的 Quay.io；Google 的 Google Container Registry，Kubernetes 的镜像使用的就是这个服务；代码托管平台 GitHub 推出的 ghcr.io。

由于某些原因，在国内访问这些服务可能会比较慢。国内的一些云服务商提供了针对 Docker Hub 的镜像服务（Registry Mirror），这些镜像服务被称为 加速器。常见的有 阿里云加速器、DaoCloud 加速器 等。使用加速器会直接从国内的地址下载 Docker Hub 的镜像，比直接从 Docker Hub 下载速度会提高很多。在 安装 Docker 一节中有详细的配置方法。

国内也有一些云服务商提供类似于 Docker Hub 的公开服务。比如 网易云镜像服务、DaoCloud 镜像市场、阿里云镜像库 等。
*** 私有 Docker Registry
除了使用公开服务外，用户还可以在本地搭建私有 Docker Registry。Docker 官方提供了 Docker Registry 镜像，可以直接使用做为私有 Registry 服务。在 私有仓库 一节中，会有进一步的搭建私有 Registry 服务的讲解。

开源的 Docker Registry 镜像只提供了 Docker Registry API 的服务端实现，足以支持 docker 命令，不影响使用。但不包含图形界面，以及镜像维护、用户管理、访问控制等高级功能。

除了官方的 Docker Registry 外，还有第三方软件实现了 Docker Registry API，甚至提供了用户界面以及一些高级功能。比如，Harbor 和 Sonatype Nexus。

* docker run
#+BEGIN_SRC bash
docker run --rm --shm-size=32G --runtime=nvidia -it -p 8000:8888 --user 1036:1036 -v /etc/group:/etc/group:ro -v /etc/passwd:/etc/passwd:ro -v /home/yangliu/:/home/yangliu --name 容器名 镜像名称 /bin/bash
#+END_SRC
- --rm,当容器退出时,自动删除容器.
- –shm-size:分配/dev/shm/文件夹的大小./dev/shm/是linux下一个非常有用的目录，因为这个目录不在硬盘上，而是在内存里。
- –runtime指容器运行时.容器运行时是管理容器和容器镜像的程序,有各种不同的标准.用nvidia-docker才能启用GPU
- -it: -t让docker分配一个伪终端并绑定到容器的标准输入上, -i则让容器的标准输入保持打开.
- Docker中系统镜像的缺省命令是 bash，如果不加 -ti bash 命令执行了自动会退出。这是因为如果没有衔接输入流，本身就会马上结束。加-ti 后docker命令会为容器分配一个伪终端，并接管其stdin/stdout支持交互操作，这时候bash命令不会自动退出。
- -p:将容器指定端口指定映射到宿主机的一个端口上.以上指令会将宿主机的8000端口映射到容器的8888端口上。
- –user:如果不做相关的设置，容器中的进程默认以 root 用户权限启动.
- -v:将 host 上已存在的目录或文件挂载(mount)到容器.挂载后的目录或文件使得宿主机和容器可以同步修改文件。 路径映射 /a : /b将主机的/a路径映射到容器的/b 。-v也可用–mount来代替.
- –name:可以指定容器的名字
- /bin/bash 启动镜像后执行的命令
- d:后台执行
** 例子
用镜像busybox创建容器，然后执行命令echo，然后退出容器
#+begin_src bash
$ docker run busybox echo "hello from busybox"  
hello from busybox
#+END_SRC
用交互式tty执行容器，如果不加-it参数，该命令创建容器后直接退出容器
#+BEGIN_EXAMPLE
#+begin_src bash
$ docker run -it busybox sh
$ ls
bin   dev   etc   home  proc  root  sys   tmp   usr   var
$ uptime
 05:45:21 up  5:58,  0 users,  load average: 0.00, 0.01, 0.04
#+END_SRC
#+END_EXAMPLE

* docker rm
#+begin_src bash
$ docker rm 305297d7a235 ff0a5c3750b9
305297d7a235
ff0a5c3750b9
# 一次性删除全部stuatus=exited的容器
$ docker rm $(docker ps -a -q -f status=exited)   #-q表示只返回IDs,-f表示过滤条件
#+END_SRC
* docker container prune
删除所有已停止的容器
* Docker 退出容器但不关闭当前容器
方法一：如果要正常退出不关闭容器，请按Ctrl+P+Q进行退出容器

方法二：如果使用exit退出，那么在退出之后会关闭容器，可以使用下面的流程进行恢复

使用docker restart命令重启容器
使用docker attach命令进入容器
重启httpd（service httpd restart）和radosgw(/etc/init.d/ceph-radosgw restart)，并且使用wget验证是否将radosgw重启成功(wget http://127.0.0.1)
* Dockerfile
#+BEGIN_EXAMPLE
# syntax=docker/dockerfile:1
FROM node:12-alpine
RUN apk add --no-cache python g++ make
WORKDIR /app
COPY . .
RUN yarn install --production
CMD ["node", "src/index.js"]
#+END_EXAMPLE

#+begin_src bash
# -t 表示设置镜像名，下面命令镜像名为getting-started
docker build -t getting-started .
#+END_SRC
* docker exec
docker exec <container-id> cat /data.txt

用root进入容器：
docker exec -it --user root <container id> /bin/bash
* SSH远程登录连接docker容器
环境：
- 计算机A为本机计算机；
- 计算机B上创建docker容器；

目的：
在A上ssh远程登录B上的docker容器：

计算机B上创建docker容器步骤：

1. 在ubuntu镜像中创建容器：
docker run -it ubuntu:16.04 /bin/bash

2. 进入容器，设置容器root密码
修改容器的root密码：passwd
密码设置为：123456

3. 修改ssh配置,允许root登录
vi /etc/ssh/sshd_config
将PermitRootLogin的值从withoutPassword改为yes

下面是可选设置
#+BEGIN_EXAMPLE
RSAAuthentication yes #启用 RSA 认证
PubkeyAuthentication yes #启用公钥私钥配对认证方式 
AuthorizedKeysFile .ssh/authorized_keys #公钥文件路径（和上面生成的文件同）
PermitRootLogin yes #root能使用ssh登录
#+END_EXAMPLE

4. 重启ssh服务
service ssh start

5. 将新的镜像启动，并将docker服务器的50001端口映射到容器的22端口上
docker run -it -p 50001:22 ubuntu-ssh /bin/bash

6. 在计算机A上ssh远程登录上述B创建的容器：
#+begin_src bash
ssh root@192.168.1.249 -p 50001
192.168.1.249为B的ip地址

ww@NiandeMacBook-Pro  ~  ssh root@192.168.1.249 -p 50001
The authenticity of host '[192.168.1.249]:50001 ([192.168.1.249]:50001)' can't be established.
ECDSA key fingerprint is SHA256:/i5usXixuOlLTjQO49xbMQEqE/Zj88UsnRmgKlZZ7Rc.
Are you sure you want to continue connecting (yes/no)? yes
Warning: Permanently added '[192.168.1.249]:50001' (ECDSA) to the list of known hosts.
root@192.168.1.249's password:
#+END_SRC
此时输入的密码是当时在容器中所设置修改的root密码，123456

7. 如果需要免密登录，需要把公钥添加到容器里的authorized_keys，而不是宿主机的authorized_keys文件
* VScode + docker进行代码调试
首先docker容器要打开ssh服务，使得可以用ssh连接到docker容器里。

配置VS Code：

打开VS code，在扩展栏（或者按ctr+shift+X）查找安装Remote Development

#+DOWNLOADED: file:E%3A/org/%E5%9B%BE%E7%89%87/Snipaste_2021-10-16_21-17-12.png @ 2021-10-16 21:17:25
[[file:VScode_+_docker%E8%BF%9B%E8%A1%8C%E4%BB%A3%E7%A0%81%E8%B0%83%E8%AF%95/2021-10-16_21-17-25_Snipaste_2021-10-16_21-17-12.png]]
安装完成后需要reload一下，然后按ctr+shift+p，打开查找栏，输入remote-ssh，选择open Configuration file
#+DOWNLOADED: file:E%3A/org/%E5%9B%BE%E7%89%87/Snipaste_2021-10-16_21-17-36.png @ 2021-10-16 21:17:44
[[file:VScode_+_docker%E8%BF%9B%E8%A1%8C%E4%BB%A3%E7%A0%81%E8%B0%83%E8%AF%95/2021-10-16_21-17-44_Snipaste_2021-10-16_21-17-36.png]]
#+DOWNLOADED: file:E%3A/org/%E5%9B%BE%E7%89%87/Snipaste_2021-10-16_21-17-50.png @ 2021-10-16 21:17:54
[[file:VScode_+_docker%E8%BF%9B%E8%A1%8C%E4%BB%A3%E7%A0%81%E8%B0%83%E8%AF%95/2021-10-16_21-17-54_Snipaste_2021-10-16_21-17-50.png]]
Host随便起名字，这里我用AutoML_docker命名。在HostName的地方输入服务器的ip，注意端口Port是我们之前docker映射到服务器上的端口号。
配置成功后左边会多出一个远程浏览的标签，点开就可以看到刚才配置的远程连接了。点击之后要输入密码，即我们创建docker后修改的root密码。

#+DOWNLOADED: file:E%3A/org/%E5%9B%BE%E7%89%87/Snipaste_2021-10-16_21-18-16.png @ 2021-10-16 21:18:21
[[file:VScode_+_docker%E8%BF%9B%E8%A1%8C%E4%BB%A3%E7%A0%81%E8%B0%83%E8%AF%95/2021-10-16_21-18-21_Snipaste_2021-10-16_21-18-16.png]]

配置vscode debugger:
菜单查看-扩展或者Ctrl + Shift + X，在商店中搜索“Python”，找到“适Python extension for Visual Studio Code”安装在服务器docker中，然后重启VSCode。
之后，菜单查看-命令面板或者Ctrl + Shift + P，输入“python: select interpreter”,点击选择解析器，稍等几秒钟，就会列出在系统中找到的Python环境（Python环境要加入环境变量才能被找到），点击需要的python解析器即可。
打开debug选项卡，选择Add configuration

#+DOWNLOADED: file:E%3A/org/%E5%9B%BE%E7%89%87/Snipaste_2021-10-16_21-19-03.png @ 2021-10-16 21:19:08
[[file:VScode_+_docker%E8%BF%9B%E8%A1%8C%E4%BB%A3%E7%A0%81%E8%B0%83%E8%AF%95/2021-10-16_21-19-08_Snipaste_2021-10-16_21-19-03.png]]
编辑launch.json文件如下：
#+DOWNLOADED: file:E%3A/org/%E5%9B%BE%E7%89%87/Snipaste_2021-10-16_21-19-22.png @ 2021-10-16 21:19:27
[[file:VScode_+_docker%E8%BF%9B%E8%A1%8C%E4%BB%A3%E7%A0%81%E8%B0%83%E8%AF%95/2021-10-16_21-19-27_Snipaste_2021-10-16_21-19-22.png]]
launch.json常用的调试配置有：
- “Python: Current File (Integrated Terminal)”：该配置表示在VSCode内置的命令行中直接执行当前激活的Python文件。如果需要制定要执行的文件，可以修改"program": "${file}"中的${file}宏为需要的文件。
- “Python: Current File (External Terminal)”：该配置功能和上面的相同，区别是不使用VSCode内置命令行，而新打开一个命令行。
- “Python: Attach”：该配置是附件到另外一个进程的调试方式。

* docker 拷贝镜像文件
** 概述

我们制作好镜像后，有时需要将镜像复制到另一台服务器使用。

能达到以上目的有两种方式，一种是上传镜像到仓库中（本地或公共仓库），但是另一台服务器很肯能只是与当前服务器局域网想通而没有公网的，所以如果使用仓库的方式，只能自己搭建私有仓库，这会在另一篇文章中介绍。

如果我们仅仅是要复制到另外少数的服务器，搭建私有仓库显然没有这个必要，而将镜像保存为文件上传到其他服务器再从文件中载入镜像也是一个不错的选择。

可以使用Docker save和Docker load命令来存储和载入镜像。

** 保存镜像为文件
*** docker save
如果要讲镜像保存为本地文件，可以使用Docker save命令。

命令格式：
docker save -o 要保存的文件名  要保存的镜像

首先查看当前的镜像列表：

docker images

#+DOWNLOADED: file:E%3A/org/%E5%9B%BE%E7%89%87/Snipaste_2021-10-11_15-50-43.png @ 2021-10-11 23:07:40
[[file:docker_%E6%8B%B7%E8%B4%9D%E9%95%9C%E5%83%8F%E6%96%87%E4%BB%B6/2021-10-11_23-07-40_Snipaste_2021-10-11_15-50-43.png]]

比如这里,我们将java8的镜像保存为文件：

docker save -o java8.tar lwieske/java-8

完成后通过 ls 命令即可看到文件。 
*** docker expory
**** Description
Export a container’s filesystem as a tar archive
**** Usage
#+begin_src bash
 docker export [OPTIONS] CONTAINER
#+END_SRC
**** Extended description
The docker export command does not export the contents of volumes associated with the container. If a volume is mounted on top of an existing directory in the container, docker export will export the contents of the underlying directory, not the contents of the volume.

Refer to Backup, restore, or migrate data volumes in the user guide for examples on exporting data in a volume.

For example uses of this command, refer to the examples section below.
**** Options
| Name, shorthand | Default | Description                        |
|-----------------+---------+------------------------------------|
| --output , -o   |         | Write to a file, instead of STDOUT |
**** Examples
Each of these commands has the same result.
#+begin_src bash
docker export red_panda > latest.tar
docker export --output="latest.tar" red_panda
#+END_SRC

** 从文件载入镜像
*** docker load 
从文件载入镜像可以使用Docker load命令。

命令格式：

docker load --input 文件

或者

docker load < 文件名

此时会导入镜像以及相关的元数据信息等。

首先使用SSH工具将文件上传到另一台服务器。

然后通过命令载入镜像：


docker load < java8.tar

导入后可以使用docker images命令查看:

#+DOWNLOADED: file:E%3A/org/%E5%9B%BE%E7%89%87/Snipaste_2021-10-11_23-08-30.png @ 2021-10-11 23:08:52
[[file:docker_%E6%8B%B7%E8%B4%9D%E9%95%9C%E5%83%8F%E6%96%87%E4%BB%B6/2021-10-11_23-08-52_Snipaste_2021-10-11_23-08-30.png]]
*** docker import
**** Description
Import the contents from a tarball to create a filesystem image
**** Usage
#+begin_src bash
docker import [OPTIONS] file|URL|- [REPOSITORY[:TAG]]
#+END_SRC
**** Extended description
You can specify a URL or - (dash) to take data directly from STDIN. The URL can point to an archive (.tar, .tar.gz, .tgz, .bzip, .tar.xz, or .txz) containing a filesystem or to an individual file on the Docker host. If you specify an archive, Docker untars it in the container relative to the / (root). If you specify an individual file, you must specify the full path within the host. To import from a remote location, specify a URI that begins with the http:// or https:// protocol.

The --change option will apply Dockerfile instructions to the image that is created. Supported Dockerfile instructions: CMD|ENTRYPOINT|ENV|EXPOSE|ONBUILD|USER|VOLUME|WORKDIR

For example uses of this command, refer to the examples section below.
**** Options
| Name, shorthand | Default | Description                                                 |
|-----------------+---------+-------------------------------------------------------------|
| --change , -c   |         | Apply Dockerfile instruction to the created image           |
| --message , -m  |         | Set commit message for imported image                       |
| --platform      |         | API 1.32+  Set platform if server is multi-platform capable |
**** Examples
***** Import from a remote location
This will create a new untagged image.
#+begin_src bash
 docker import https://example.com/exampleimage.tgz
#+END_SRC
***** Import from a local file
Import to docker via pipe and STDIN.
#+begin_src bash
 cat exampleimage.tgz | docker import - exampleimagelocal:new
#+END_SRC
***** Import with a commit message.
#+begin_src bash
 cat exampleimage.tgz | docker import --message "New image imported from tarball" - exampleimagelocal:new
#+END_SRC
***** Import to docker from a local archive.
#+begin_src bash
 docker import /path/to/exampleimage.tgz
#+END_SRC
***** Import from a local directory
#+begin_src bash
 sudo tar -c . | docker import - exampleimagedir
#+END_SRC
***** Import from a local directory with new configurations
#+begin_src bash
 sudo tar -c . | docker import --change "ENV DEBUG=true" - exampleimagedir
#+END_SRC
Note the sudo in this example – you must preserve the ownership of the files (especially root ownership) during the archiving with tar. If you are not root (or the sudo command) when you tar, then the ownerships might not get preserved.
** docker save与docker export的区别
docker save和docker export的区别:
- docker save保存的是镜像（image），docker export保存的是容器（container）；
- docker load用来载入镜像包，docker import用来载入容器包，但两者都会恢复为镜像；
- docker load不能对载入的镜像重命名，而docker import可以为镜像指定新名称。

docker export的应用场景主要用来制作基础镜像，比如你从一个ubuntu镜像启动一个容器，然后安装一些软件和进行一些设置后，使用docker export保存为一个基础镜像。然后，把这个镜像分发给其他人使用，比如作为基础的开发环境。

docker save的应用场景是，如果你的应用是使用docker-compose.yml编排的多个镜像组合，但你要部署的客户服务器并不能连外网。这时，你可以使用docker save将用到的镜像打个包，然后拷贝到客户服务器上使用docker load载入。

导出后再导入(exported-imported)的镜像会丢失所有的历史，而保存后再加载（saveed-loaded）的镜像没有丢失历史和层(layer)。这意味着使用导出后再导入的方式，你将无法回滚到之前的层(layer)，同时，使用保存后再加载的方式持久化整个镜像，就可以做到层回滚（可以执行docker tag <LAYER ID> <IMAGE NAME>来回滚之前的层）。
* docker commit 
docker commit :从容器创建一个新的镜像。

语法

docker commit [OPTIONS] CONTAINER [REPOSITORY[:TAG]]

OPTIONS说明：

-a :提交的镜像作者；

-c :使用Dockerfile指令来创建镜像；

-m :提交时的说明文字；

-p :在commit时，将容器暂停。

** 实例
将容器a404c6c174a2 保存为新的镜像,并添加提交人信息和说明信息。
#+BEGIN_SRC bash
runoob@runoob:~$ docker commit -a "runoob.com" -m "my apache" a404c6c174a2  mymysql:v1 
sha256:37af1236adef1544e8886be23010b66577647a40bc02c0885a6600b33ee28057
runoob@runoob:~$ docker images mymysql:v1
REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE
mymysql             v1                  37af1236adef        15 seconds ago      329 MB
#+END_SRC

* 镜像改名命令格式：
命令格式：

 docker  tag  镜像id  仓库：标签
 
或：
 
 docker  tag  旧镜像名  新镜像名

* linux docker 中实现某些程序段开机自启动
将服务添加到启动文件bashrc中即可

比如可以在root用户下设置自动启动ssh服务：
#+begin_src bash
vim /root/.bashrc
#+END_SRC
在.bashrc文件末尾添加下面的内容
#+begin_src bash
service ssh start >>/root/startup_run.log
#+END_SRC
* docker删除<none>镜像
以下是搜到的几种方案
http://blog.51yip.com/cloud/1859.html
#+begin_src bash
# 停止docker
docker stop $(docker ps -a | grep "Exited" | awk '{print $1 }')
# 删除docker
docker rm $(docker ps -a | grep "Exited" | awk '{print $1 }')
# 删除images
docker rmi $(docker images | grep "none" | awk '{print $3}')
#+END_SRC

或者 http://blog.csdn.net/u014221090/article/details/53186313
#+begin_src bash
docker ps -a | grep "Exited" | awk '{print $1 }'|xargs docker stop
docker ps -a | grep "Exited" | awk '{print $1 }'|xargs docker rm
docker images|grep none|awk '{print $3 }'|xargs docker rmi
#+END_SRC
或者 http://blog.csdn.net/goflyfreely/article/details/53149894
#+BEGIN_EXAMPLE
好的<none>:<none>镜像的产生
例如从镜像仓库里拿一个fedora 镜像。如图虽然docker images 只显示fedora:latest，但是
docker images -a 显示了两个镜像fedora:latest 和<none>:<none>.
原来docker中镜像是有垂直父子关系的，层级关系可以在/var/lib/docker/graph中看到。docker pull fedora执行的时候呢，就会每次下载一个镜像。
可以通过查看/var/lib/docker/graph的json查看父子关系。这些镜像都不会引起存储空间占用的问题。
#+END_EXAMPLE
#+begin_src bash
root@xxxx:/var/lib/docker/graph# more ff0e2b608af6b1901d8ad9e9556e9e8ffe91b4c5386039e32bdf087df6157f65/json
{"container_config":{"Hostname":"","Domainname":"","User":"","AttachStdin":false,"AttachStdout":false,"AttachStderr":false,"Tty":fal
se,"OpenStdin":false,"StdinOnce":false,"Env":null,"Cmd":["/bin/sh -c echo 'export PATH=$ORACLE_HOME/bin:$PATH' \u003e\u003e /etc/bas
h.bashrc"],"Image":"","Volumes":null,"WorkingDir":"","Entrypoint":null,"OnBuild":null,"Labels":null},"created":"2016-04-20T10:29:03.
276290831Z","layer_id":"sha256:a5d9cef8ef2a0ffd19fea965e22924c2717bdcec82f628344111ae5aeec3ec13","parent_id":"sha256:c74e9fd53a7e49d
4d4cd562a69aa8ccc094ee17aedb7cc26a161af2903af8f68"}
#+END_SRC
#+BEGIN_EXAMPLE
坏的<none>:<none>镜像的产生
而docker build 或是 pull 命令就会产生临时镜像。如果我们用dockerfile创建一个helloworld镜像后，因为版本更新需要重新创建，那么以前那个版本的镜像就会
成为临时镜像。这个是需要删除的。
#+END_EXAMPLE
删除命令见下。
#+begin_src bash
sudo docker rmi $(docker images -f "dangling=true" -q)
#+END_SRC


** 参考文章
[[https://www.jianshu.com/p/d06830de219f][docker删除<none>镜像]]
* 端口映射
** 启动容器后
容器除了在启动时添加端口映射关系，还可以通过宿主机的iptables进行nat转发，将宿主机的端口映射到容器的内部端口上，这种方式适用于容器启动时没有指定端口映射的情况！
#+begin_src bash
[root@docker-test ~]# docker run -ti -d --name my-nginx9 docker.io/nginx
990752e39d75b977cbff5a944247366662211ce43d16843a452a5697ddded12f
[root@docker-test ~]# docker ps
CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS            NAMES
990752e39d75        docker.io/nginx     "nginx -g 'daemon ..."   2 seconds ago       Up 1 second         80/tcp           my-nginx9
#+END_SRC 
这个时候，由于容器my-nginx9在启动时没有指定其内部的80端口映射到宿主机的端口上，所以默认是没法访问的！
现在通过宿主机的iptables进行net转发
 
首先获得容器的ip地址
#+begin_src bash
[root@docker-test ~]# docker inspect my-nginx9|grep IPAddress
            "SecondaryIPAddresses": null,
            "IPAddress": "172.17.0.9",
                    "IPAddress": "172.17.0.9",
 
[root@docker-test ~]# ping 172.17.0.9
PING 172.17.0.9 (172.17.0.9) 56(84) bytes of data.
64 bytes from 172.17.0.9: icmp_seq=1 ttl=64 time=0.105 ms
64 bytes from 172.17.0.9: icmp_seq=2 ttl=64 time=0.061 ms
.....
 
[root@docker-test ~]# telnet 172.17.0.9 80
Trying 172.17.0.9...
Connected to 172.17.0.9.
Escape character is '^]'
#+END_SRC  
 
centos7下部署iptables环境纪录（关闭默认的firewalle）
参考：http://www.cnblogs.com/kevingrace/p/5799210.html
 
将容器的80端口映射到dockers宿主机的9998端口
#+begin_src bash
[root@docker-test ~]# iptables -t nat -A PREROUTING -p tcp -m tcp --dport 9998 -j DNAT --to-destination 172.17.0.9:80
[root@docker-test ~]# iptables -t nat -A POSTROUTING -d 172.17.0.9/32 -p tcp -m tcp --sport 80 -j SNAT --to-source 192.16.10.214
[root@docker-test ~]# iptables -t filter -A INPUT -p tcp -m state --state NEW -m tcp --dport 9998 -j ACCEPT
#+END_SRC 
保存以上iptables规则
#+begin_src bash 
[root@docker-test ~]# iptables-save > /etc/sysconfig/iptables
#+END_SRC  
查看/etc/sysconfig/iptables文件，注意下面两行有关icmp-host-prohibited的设置一定要注释掉！否则nat转发会失败！
#+begin_src bash
[root@docker-test ~]# cat /etc/sysconfig/iptables
# Generated by iptables-save v1.4.21 on Fri Aug 10 11:13:57 2018
*nat
:PREROUTING ACCEPT [32:1280]
:INPUT ACCEPT [0:0]
:OUTPUT ACCEPT [0:0]
:POSTROUTING ACCEPT [0:0]
-A PREROUTING -p tcp -m tcp --dport 9998 -j DNAT --to-destination 172.17.0.9:80
-A POSTROUTING -d 172.17.0.9/32 -p tcp -m tcp --sport 80 -j SNAT --to-source 192.16.10.214
COMMIT
# Completed on Fri Aug 10 11:13:57 2018
# Generated by iptables-save v1.4.21 on Fri Aug 10 11:13:57 2018
*filter
:INPUT ACCEPT [0:0]
:FORWARD ACCEPT [0:0]
:OUTPUT ACCEPT [50:5056]
-A INPUT -m state --state RELATED,ESTABLISHED -j ACCEPT
-A INPUT -p icmp -j ACCEPT
-A INPUT -i lo -j ACCEPT
-A INPUT -p tcp -m state --state NEW -m tcp --dport 22 -j ACCEPT
-A INPUT -p tcp -m state --state NEW -m tcp --dport 9998 -j ACCEPT
#-A INPUT -j REJECT --reject-with icmp-host-prohibited
#-A FORWARD -j REJECT --reject-with icmp-host-prohibited
COMMIT
# Completed on Fri Aug 10 11:13:57 2018
#+END_SRC  
最后重启iptbales服务
#+begin_src bash
[root@docker-test ~]# systemctl restart iptables
#+END_SRC  
查看iptables规则
#+begin_src bash
[root@docker-test ~]# iptables -L
Chain INPUT (policy ACCEPT)
target     prot opt source               destination        
ACCEPT     all  --  anywhere             anywhere             state RELATED,ESTABLISHED
ACCEPT     icmp --  anywhere             anywhere           
ACCEPT     all  --  anywhere             anywhere           
ACCEPT     tcp  --  anywhere             anywhere             state NEW tcp dpt:ssh
ACCEPT     tcp  --  anywhere             anywhere             state NEW tcp dpt:distinct32
 
Chain FORWARD (policy ACCEPT)
target     prot opt source               destination        
 
Chain OUTPUT (policy ACCEPT)
target     prot opt source               destination       
 
[root@docker-test ~]# iptables -L -t nat
Chain PREROUTING (policy ACCEPT)
target     prot opt source               destination        
DNAT       tcp  --  anywhere             anywhere             tcp dpt:distinct32 to:172.17.0.9:80
 
Chain INPUT (policy ACCEPT)
target     prot opt source               destination        
 
Chain OUTPUT (policy ACCEPT)
target     prot opt source               destination        
 
Chain POSTROUTING (policy ACCEPT)
target     prot opt source               destination        
SNAT       tcp  --  anywhere             172.17.0.9           tcp spt:http to:192.16.10.214
#+END_SRC
然后访问http://192.168.10.214:9998/，就能转发访问到my-nginx9容器的80端口了！！！ 
** 参考文章
[[https://www.cnblogs.com/kevingrace/p/9453987.html][Docker容器内部端口映射到外部宿主机端口 - 运维笔记]]
* 参考文档:
1. [官方文档](https://docs.docker.com/engine/reference/commandline)
2. [Docker 参数 -i -t 的作用](https://blog.csdn.net/upHailin/article/details/80892505)
3. [容器运行时笔记](https://gobomb.github.io/post/container-runtime-note/)
4. [解密容器运行时](https://gobomb.github.io/post/container-runtime-note/)
5. [Docker容器的创建、启动、和停止](https://www.cnblogs.com/linjiqin/p/8608975.html)
6. [启动容器](https://yeasy.gitbooks.io/docker_practice/container/run.html)
7. [认识/dev/shm](http://www.361way.com/dev-shm/4029.html)
8. [Docker-端口映射](https://www.jianshu.com/p/b92d4b845ed6)
9. [理解 docker 容器中的 uid 和 gid](https://www.cnblogs.com/sparkdev/p/9614164.html)
10. [Make “–user `whoami`” the default for “docker run”](https://forums.docker.com/t/make-user-whoami-the-default-for-docker-run/40874)
11. [Data Volume 之 bind mount - 每天5分钟玩转 Docker 容器技术（39）](https://www.ibm.com/developerworks/community/blogs/132cfa78-44b0-4376-85d0-d3096cd30d3f/entry/Data_Volume_%E4%B9%8B_bind_mount_%E6%AF%8F%E5%A4%A95%E5%88%86%E9%92%9F%E7%8E%A9%E8%BD%AC_Docker_%E5%AE%B9%E5%99%A8%E6%8A%80%E6%9C%AF_39?lang=en)
12. [官方文档:Use bind mounts](https://docs.docker.com/storage/bind-mounts/)
13. [Docker数据管理-Volume， bind mount和tmpfs mount](https://michaelyou.github.io/2017/09/17/Docker%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86-Volume%EF%BC%8C-bind-mount%E5%92%8Ctmpfs-mount/)
14. [Docker数据持久之volume和bind mount](https://blog.csdn.net/docerce/article/details/79265858)
15. [Joe's Blog: Share volume between docker host and container](https://blog.johannes-beck.name/?p=571)
16. [running-docker-container-with-my-own-privileges](https://github.com/docker/for-mac/issues/2458)
17. [breaks mounting /etc/passwd or /etc/group #2458](https://github.com/docker/for-mac/issues/2458)









