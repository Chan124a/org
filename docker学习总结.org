* 命令
#+BEGIN_SRC bash
docker ps  #可以用来查看当前正在运行的容器
docker ps -a #查看所有容器，包括已停止运行的
docker images #可以查看docker registry上已有的镜像
docker run [OPTIONS] IMAGE [COMMAND] [ARG...]
#用于创建容器,参数使用方法可参考[官方文档](https://docs.docker.com/engine/reference/commandline/run/)
docker run busybox echo "111"  #用镜像busybox创建容器，然后执行命令echo，然后退出容器

docker exec -u root -t -i cpd /bin/bash #用于以root身份进入容器
#需要注意的是，在容器内以root身份安装软件将会导致宿主机也安装软件

docker attach 容器名 #用于进入容器
#+END_SRC
* docker run
#+BEGIN_SRC bash
docker run --rm --shm-size=32G --runtime=nvidia -it -p 8000:8888 --user 1036:1036 -v /etc/group:/etc/group:ro -v /etc/passwd:/etc/passwd:ro -v /home/yangliu/:/home/yangliu --name 容器名 镜像名称 /bin/bash
#+END_SRC
- --rm,当容器退出时,自动删除容器.
- –shm-size:分配/dev/shm/文件夹的大小./dev/shm/是linux下一个非常有用的目录，因为这个目录不在硬盘上，而是在内存里。
- –runtime指容器运行时.容器运行时是管理容器和容器镜像的程序,有各种不同的标准.用nvidia-docker才能启用GPU
- -it: -t让docker分配一个伪终端并绑定到容器的标准输入上, -i则让容器的标准输入保持打开.
- Docker中系统镜像的缺省命令是 bash，如果不加 -ti bash 命令执行了自动会退出。这是因为如果没有衔接输入流，本身就会马上结束。加-ti 后docker命令会为容器分配一个伪终端，并接管其stdin/stdout支持交互操作，这时候bash命令不会自动退出。
- -p:将容器指定端口指定映射到宿主机的一个端口上.以上指令会将宿主机的8000端口映射到容器的8888端口上。
- –user:如果不做相关的设置，容器中的进程默认以 root 用户权限启动.
- -v:将 host 上已存在的目录或文件挂载(mount)到容器.挂载后的目录或文件使得宿主机和容器可以同步修改文件。 路径映射 /a : /b将主机的/a路径映射到容器的/b 。-v也可用–mount来代替.
- –name:可以指定容器的名字
- /bin/bash 启动镜像后执行的命令
- d:后台执行
** 例子
用镜像busybox创建容器，然后执行命令echo，然后退出容器
#+begin_src bash
$ docker run busybox echo "hello from busybox"  
hello from busybox
#+END_SRC
用交互式tty执行容器，如果不加-it参数，该命令创建容器后直接退出容器
#+BEGIN_EXAMPLE
#+begin_src bash
$ docker run -it busybox sh
$ ls
bin   dev   etc   home  proc  root  sys   tmp   usr   var
$ uptime
 05:45:21 up  5:58,  0 users,  load average: 0.00, 0.01, 0.04
#+END_SRC
#+END_EXAMPLE

* docker rm
#+begin_src bash
$ docker rm 305297d7a235 ff0a5c3750b9
305297d7a235
ff0a5c3750b9
# 一次性删除全部stuatus=exited的容器
$ docker rm $(docker ps -a -q -f status=exited)   #-q表示只返回IDs,-f表示过滤条件
#+END_SRC
* docker container prune
删除所有已停止的容器
* docker rmi
删除镜像
* Docker 退出容器但不关闭当前容器
方法一：如果要正常退出不关闭容器，请按Ctrl+P+Q进行退出容器

方法二：如果使用exit退出，那么在退出之后会关闭容器，可以使用下面的流程进行恢复

使用docker restart命令重启容器
使用docker attach命令进入容器
重启httpd（service httpd restart）和radosgw(/etc/init.d/ceph-radosgw restart)，并且使用wget验证是否将radosgw重启成功(wget http://127.0.0.1)
* Dockerfile
#+BEGIN_EXAMPLE
# syntax=docker/dockerfile:1
FROM node:12-alpine
RUN apk add --no-cache python g++ make
WORKDIR /app
COPY . .
RUN yarn install --production
CMD ["node", "src/index.js"]
#+END_EXAMPLE

#+begin_src bash
# -t 表示设置镜像名，下面命令镜像名为getting-started
docker build -t getting-started .
#+END_SRC
* docker exec
docker exec <container-id> cat /data.txt
* SSH远程登录连接docker容器
环境：
- 计算机A为本机计算机；
- 计算机B上创建docker容器；

目的：
在A上ssh远程登录B上的docker容器：

计算机B上创建docker容器步骤：

1. 在ubuntu镜像中创建容器：
docker run -it ubuntu:16.04 /bin/bash

2. 进入容器，设置容器root密码
修改容器的root密码：passwd
密码设置为：123456

3. 修改ssh配置,允许root登录
vi /etc/ssh/sshd_config
将PermitRootLogin的值从withoutPassword改为yes

下面是可选设置
#+BEGIN_EXAMPLE
RSAAuthentication yes #启用 RSA 认证
PubkeyAuthentication yes #启用公钥私钥配对认证方式 
AuthorizedKeysFile .ssh/authorized_keys #公钥文件路径（和上面生成的文件同）
PermitRootLogin yes #root能使用ssh登录
#+END_EXAMPLE

4. 重启ssh服务
service ssh start

5. 将新的镜像启动，并将docker服务器的50001端口映射到容器的22端口上
docker run -it -p 50001:22 ubuntu-ssh /bin/bash

6. 在计算机A上ssh远程登录上述B创建的容器：
#+begin_src bash
ssh root@192.168.1.249 -p 50001
192.168.1.249为B的ip地址

ww@NiandeMacBook-Pro  ~  ssh root@192.168.1.249 -p 50001
The authenticity of host '[192.168.1.249]:50001 ([192.168.1.249]:50001)' can't be established.
ECDSA key fingerprint is SHA256:/i5usXixuOlLTjQO49xbMQEqE/Zj88UsnRmgKlZZ7Rc.
Are you sure you want to continue connecting (yes/no)? yes
Warning: Permanently added '[192.168.1.249]:50001' (ECDSA) to the list of known hosts.
root@192.168.1.249's password:
#+END_SRC
此时输入的密码是当时在容器中所设置修改的root密码，123456

* VScode + docker进行代码调试
首先docker容器要打开ssh服务，使得可以用ssh连接到docker容器里。

配置VS Code：

打开VS code，在扩展栏（或者按ctr+shift+X）查找安装Remote Development

#+DOWNLOADED: file:E%3A/org/%E5%9B%BE%E7%89%87/Snipaste_2021-10-16_21-17-12.png @ 2021-10-16 21:17:25
[[file:VScode_+_docker%E8%BF%9B%E8%A1%8C%E4%BB%A3%E7%A0%81%E8%B0%83%E8%AF%95/2021-10-16_21-17-25_Snipaste_2021-10-16_21-17-12.png]]
安装完成后需要reload一下，然后按ctr+shift+p，打开查找栏，输入remote-ssh，选择open Configuration file
#+DOWNLOADED: file:E%3A/org/%E5%9B%BE%E7%89%87/Snipaste_2021-10-16_21-17-36.png @ 2021-10-16 21:17:44
[[file:VScode_+_docker%E8%BF%9B%E8%A1%8C%E4%BB%A3%E7%A0%81%E8%B0%83%E8%AF%95/2021-10-16_21-17-44_Snipaste_2021-10-16_21-17-36.png]]
#+DOWNLOADED: file:E%3A/org/%E5%9B%BE%E7%89%87/Snipaste_2021-10-16_21-17-50.png @ 2021-10-16 21:17:54
[[file:VScode_+_docker%E8%BF%9B%E8%A1%8C%E4%BB%A3%E7%A0%81%E8%B0%83%E8%AF%95/2021-10-16_21-17-54_Snipaste_2021-10-16_21-17-50.png]]
Host随便起名字，这里我用AutoML_docker命名。在HostName的地方输入服务器的ip，注意端口Port是我们之前docker映射到服务器上的端口号。
配置成功后左边会多出一个远程浏览的标签，点开就可以看到刚才配置的远程连接了。点击之后要输入密码，即我们创建docker后修改的root密码。

#+DOWNLOADED: file:E%3A/org/%E5%9B%BE%E7%89%87/Snipaste_2021-10-16_21-18-16.png @ 2021-10-16 21:18:21
[[file:VScode_+_docker%E8%BF%9B%E8%A1%8C%E4%BB%A3%E7%A0%81%E8%B0%83%E8%AF%95/2021-10-16_21-18-21_Snipaste_2021-10-16_21-18-16.png]]

配置vscode debugger:
菜单查看-扩展或者Ctrl + Shift + X，在商店中搜索“Python”，找到“适Python extension for Visual Studio Code”安装在服务器docker中，然后重启VSCode。
之后，菜单查看-命令面板或者Ctrl + Shift + P，输入“python: select interpreter”,点击选择解析器，稍等几秒钟，就会列出在系统中找到的Python环境（Python环境要加入环境变量才能被找到），点击需要的python解析器即可。
打开debug选项卡，选择Add configuration

#+DOWNLOADED: file:E%3A/org/%E5%9B%BE%E7%89%87/Snipaste_2021-10-16_21-19-03.png @ 2021-10-16 21:19:08
[[file:VScode_+_docker%E8%BF%9B%E8%A1%8C%E4%BB%A3%E7%A0%81%E8%B0%83%E8%AF%95/2021-10-16_21-19-08_Snipaste_2021-10-16_21-19-03.png]]
编辑launch.json文件如下：
#+DOWNLOADED: file:E%3A/org/%E5%9B%BE%E7%89%87/Snipaste_2021-10-16_21-19-22.png @ 2021-10-16 21:19:27
[[file:VScode_+_docker%E8%BF%9B%E8%A1%8C%E4%BB%A3%E7%A0%81%E8%B0%83%E8%AF%95/2021-10-16_21-19-27_Snipaste_2021-10-16_21-19-22.png]]
launch.json常用的调试配置有：
- “Python: Current File (Integrated Terminal)”：该配置表示在VSCode内置的命令行中直接执行当前激活的Python文件。如果需要制定要执行的文件，可以修改"program": "${file}"中的${file}宏为需要的文件。
- “Python: Current File (External Terminal)”：该配置功能和上面的相同，区别是不使用VSCode内置命令行，而新打开一个命令行。
- “Python: Attach”：该配置是附件到另外一个进程的调试方式。

* docker 拷贝镜像文件
** 概述

我们制作好镜像后，有时需要将镜像复制到另一台服务器使用。

能达到以上目的有两种方式，一种是上传镜像到仓库中（本地或公共仓库），但是另一台服务器很肯能只是与当前服务器局域网想通而没有公网的，所以如果使用仓库的方式，只能自己搭建私有仓库，这会在另一篇文章中介绍。

如果我们仅仅是要复制到另外少数的服务器，搭建私有仓库显然没有这个必要，而将镜像保存为文件上传到其他服务器再从文件中载入镜像也是一个不错的选择。

可以使用Docker save和Docker load命令来存储和载入镜像。

** 保存镜像为文件

如果要讲镜像保存为本地文件，可以使用Docker save命令。

命令格式：
docker save -o 要保存的文件名  要保存的镜像

首先查看当前的镜像列表：

docker images

#+DOWNLOADED: file:E%3A/org/%E5%9B%BE%E7%89%87/Snipaste_2021-10-11_15-50-43.png @ 2021-10-11 23:07:40
[[file:docker_%E6%8B%B7%E8%B4%9D%E9%95%9C%E5%83%8F%E6%96%87%E4%BB%B6/2021-10-11_23-07-40_Snipaste_2021-10-11_15-50-43.png]]

比如这里,我们将java8的镜像保存为文件：

docker save -o java8.tar lwieske/java-8

完成后通过 ls 命令即可看到文件。 

** 从文件载入镜像

从文件载入镜像可以使用Docker load命令。

命令格式：

docker load --input 文件

或者

docker load < 文件名

此时会导入镜像以及相关的元数据信息等。

首先使用SSH工具将文件上传到另一台服务器。

然后通过命令载入镜像：


docker load < java8.tar

导入后可以使用docker images命令查看:

#+DOWNLOADED: file:E%3A/org/%E5%9B%BE%E7%89%87/Snipaste_2021-10-11_23-08-30.png @ 2021-10-11 23:08:52
[[file:docker_%E6%8B%B7%E8%B4%9D%E9%95%9C%E5%83%8F%E6%96%87%E4%BB%B6/2021-10-11_23-08-52_Snipaste_2021-10-11_23-08-30.png]]

* docker commit 
docker commit :从容器创建一个新的镜像。

语法

docker commit [OPTIONS] CONTAINER [REPOSITORY[:TAG]]

OPTIONS说明：

-a :提交的镜像作者；

-c :使用Dockerfile指令来创建镜像；

-m :提交时的说明文字；

-p :在commit时，将容器暂停。

** 实例
将容器a404c6c174a2 保存为新的镜像,并添加提交人信息和说明信息。
#+BEGIN_SRC bash
runoob@runoob:~$ docker commit -a "runoob.com" -m "my apache" a404c6c174a2  mymysql:v1 
sha256:37af1236adef1544e8886be23010b66577647a40bc02c0885a6600b33ee28057
runoob@runoob:~$ docker images mymysql:v1
REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE
mymysql             v1                  37af1236adef        15 seconds ago      329 MB
#+END_SRC

* 镜像改名命令格式：
命令格式：

 docker  tag  镜像id  仓库：标签
 
或：
 
 docker  tag  旧镜像名  新镜像名
* 参考文档:
1. [官方文档](https://docs.docker.com/engine/reference/commandline)
2. [Docker 参数 -i -t 的作用](https://blog.csdn.net/upHailin/article/details/80892505)
3. [容器运行时笔记](https://gobomb.github.io/post/container-runtime-note/)
4. [解密容器运行时](https://gobomb.github.io/post/container-runtime-note/)
5. [Docker容器的创建、启动、和停止](https://www.cnblogs.com/linjiqin/p/8608975.html)
6. [启动容器](https://yeasy.gitbooks.io/docker_practice/container/run.html)
7. [认识/dev/shm](http://www.361way.com/dev-shm/4029.html)
8. [Docker-端口映射](https://www.jianshu.com/p/b92d4b845ed6)
9. [理解 docker 容器中的 uid 和 gid](https://www.cnblogs.com/sparkdev/p/9614164.html)
10. [Make “–user `whoami`” the default for “docker run”](https://forums.docker.com/t/make-user-whoami-the-default-for-docker-run/40874)
11. [Data Volume 之 bind mount - 每天5分钟玩转 Docker 容器技术（39）](https://www.ibm.com/developerworks/community/blogs/132cfa78-44b0-4376-85d0-d3096cd30d3f/entry/Data_Volume_%E4%B9%8B_bind_mount_%E6%AF%8F%E5%A4%A95%E5%88%86%E9%92%9F%E7%8E%A9%E8%BD%AC_Docker_%E5%AE%B9%E5%99%A8%E6%8A%80%E6%9C%AF_39?lang=en)
12. [官方文档:Use bind mounts](https://docs.docker.com/storage/bind-mounts/)
13. [Docker数据管理-Volume， bind mount和tmpfs mount](https://michaelyou.github.io/2017/09/17/Docker%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86-Volume%EF%BC%8C-bind-mount%E5%92%8Ctmpfs-mount/)
14. [Docker数据持久之volume和bind mount](https://blog.csdn.net/docerce/article/details/79265858)
15. [Joe's Blog: Share volume between docker host and container](https://blog.johannes-beck.name/?p=571)
16. [running-docker-container-with-my-own-privileges](https://github.com/docker/for-mac/issues/2458)
17. [breaks mounting /etc/passwd or /etc/group #2458](https://github.com/docker/for-mac/issues/2458)









