* auto
** 静态类型，动态类型和类型推导
在编程语言分类中，C/C++C常常被认为是静态类型的语言。而有的编程语言则号称是“动态类型”的，比如python。通常情况下，“静”和“动”的区别是非常直观的。我们看看下面这段简单的python代码：   
#+BEGIN_SRC python 
name=‘world\n’
print 'hello, ' %name
#+END_SRC
这段代码中python中的一个hellowworld的实现。这就是编程语言中的“动态类型”,在运行时来进行类型检查，而C++中类型检查是在编译阶段。动态类型语言能做到在运行时决定类型，主要归功于一技术，这技术是类型推导。

事实上，类型推导也可以用于静态类型语言中。比如上面的python代码中，如果按照C/C++程序员的思考方式，world\n表达式应该可以返回一个临时的字符串，所以即使name没有进行声明，我们也能轻松低推导出name的类型应该是一个字符串类型。在C++11中，这个想法得到了实现。C++11中类型推导的实现之一就是重定义auto关键字，另一个实现是decltype。

我们可以使用C++11方式来书写刚才的python的代码
#+BEGIN_SRC c++
#include <iostream>
using namespace std;
int main()
{
  auto name=‘world\n’
  cout<<"hello   "<<name<<endl;
 
}
#+END_SRC

这里使用auto关键字来要求编译器对变量name的类型进行了自动推导。这里编译器根据它的初始化表达式的类型，推导出name的类型为char*。事实上，atuo关键字在早期的C/C++标准中有着完全不同的含义。声明时使用auto修饰的变量，按照早期C/C++标准的解释，是具有自动存储期的局部变量。不过那时情况是该关键字几乎无人使用，因为一般函数内没有声明为static的变量总是具有自动存储期的局部变量。auto声明变量的类型必须又编译器在编译时期推导而得。

通过以下例子来了解以下auto类型推导的基本用法
#+BEGIN_SRC c++
#include <iostream>
using namespace std;
int main()
{
     double foo();
	 auto x=1;
	 auto y=foo();
	 struct m
	 {
	     int i;
	 }str;
	 auto str1=str;
	 auto z;
	 z=x;
}
#+END_SRC
以上变量x被初始化为1，因为字面变量1的类型是const int，所以编译器推导出x的类型应该为int（这里const类型限制符被去掉了，后面会解释）。同理在变量y的定义中，auto类型的y被推导为double类型；而在auto str1的定义中，其类型被推导为struct m。这里的z，使用auto关键字来声明，但是不立即对其进行定义，此时编译器则会报错。这跟通过其他关键字（除去引用类型的关键字）先声明后定义的变量的使用规则是不同的。auto声明的变量必须被初始化，以使编译器能够从其初始化表达式中推导出其类型。这个意义上，auto并非一种类型声明，而是一个类型声明时的“占位符”，编译器在便已是亲会将suto替代为变量实际的类型。
** auto的优势
*** 简化代码
1.直观地，auto推导的一个最大的优势在于拥有初始化表达式的复杂类型变量声明时简化代码。由于C++的发展，变量类型变得越来越复杂。但是很多时候，名字空间、模板成为类型的一部分，导致了程序员在使用库的时候如履薄冰。
#+BEGIN_SRC c++
#include <string>
#include <vector>
void loopover(std::vector<std::string>&vs)
{
    std::vector<std::string>::iterator i=vs.begin();
	for(;i<vs.end();i++)
	{
	
	}
 
}
#+END_SRC
#+BEGIN_SRC c++
<pre name="code" class="cpp">#include <string>
#include <vector>
void loopover(std::vector<std::string>&vs)
{
	for(  auto i=vs.begin();;i<vs.end();i++)
	{
	
	}
 
}
#+END_SRC
使用std::vector<std::string>::iterator来定义i是C++常用的良好的习惯，但是这样长的声明带来了代码可读性的困难，因此引入auto，使代码可读性增加。并且使用STL将会变得更加容易
*** 避免声明类型错误
可以避免类型声明时的麻烦而且避免类型声明时的错误。事实上，在C/C++中，存在着很多隐式或者是用户自定义类型的转换规则（比如整型与字符型进行加法运算后，表达式返回整型，这是一条隐式规则）。这些规则并非容易记忆，尤其是在用户自定义很多操作符以后，这个时候auto就有用户之地了。看一下例子
#+BEGIN_SRC c++
class PI
{
   public :
          double operator*(float v)
		  {
		     return (double)val*v;
		  }
          const float val=3.1415927f;
}

int main()
{
          float radius=1.7e10;
	  PI pi;
	  auto circumference =2*(pi*radius);
}
#+END_SRC
上面定义了一个float类型的变量radius（半径）以及一个自定义类型PI的变量pi,在计算周长的时候，使用auto类型来定义变量circumference。这里PI在于float类型数据相乘时，其返回值为double。而PI得定义可能是在其他的地方（头文件里），main函数的程序可能就不知道PI的作者为了避免数据上溢或者是精度上的降低而返回了double类型的浮点数。因此main函数程序员如果使用float类型声明circumference，就可能会享受不了PI作者细心设计带来的好处。反之，将circumference声明为auto，则毫无问题，因为编译器已经做了最好的选择。

但是auto不能解决所有的精度问题。下面例子
#+BEGIN_SRC c++
#include <iostream>
using namespace std;
int main()
{
   unsigned int a=4294967295;//最大的unsigned int值
   unsigned int b=1；
   auto c=a+b;
   cout<<"a="<<a<<endl;
   cout<<"b="<<b<<endl;
   cout<<"c="<<c<<endl;
}
#+END_SRC
上面代码中，程序员希望通过声明变量c为auto就能解决a+b溢出的问题。而实际上由于a+b返回的依然是unsigned int的值，姑且c的类型依然被推导为unsigned int，auto并不能帮上忙。这个跟动态类型语言中数据自动进行拓展的特性还是不一样的。
*** 支持泛型编程
在C++中其“自适应”性能够在一定程度上支持泛型的编程。

 回到上面class PI的例子，这里假设PI的作者改动了PI的定义，比如讲operator*返回值变为long  double，此时，main函数并不需要修改，因为auto会“自适应”新的类型。同理，对于不同平台上的二代马维护，auto也会带来一些“泛型”的好处。这里我们一strlen函数为例，在32位编译环境下，strlen返回的为一个4字节的整型，在64位的编译环境下，strlen会返回一个8字节的整型。即使系统库中<cstring>为其提供了size_t类型来支持多平台间的代码共享支持，但是使用auto关键字我们同样可以达到代码跨平台的效果。

~auto var=strlen("hello world")~

由于size_t的适用性范围往往局限于<cstring>中定义的函数，auto的适用范围明显更为广泛。

当auto应用于模板的定义中，其"自适应"性会得到更加充分的体现。我们可以看看以下例子
#+BEGIN_SRC c++
template<typename T1,typename T2>
double Sum(T1&t1,T2&t2)
{
        auto a=t1+t2;
	return a;
}
int main()
{
        int a=3;
	long b=5;
	float c=1.0f;
	float d=2.3f;
	auto e=Sum<int,long>(a,b); //e的类型被推导为long
	auto f=Sum<float,float>(c,d);//s的类型被推导为float
}
#+END_SRC
上面中Sum模板函数接受两个参数。由于T1，T2要在模板实例化时才能确定，所以Sum中将变量s的类型声明为auto的。在函数main中我们将模板实例化时。Sum<int,long>中的s变量会被推导为long类型，而Sum<float,float>中的s变量则会被推导为float。可以看到，auto与模板一起使用时，其“自适应”特性能够加强C++中泛型的能力。
** auto的使用注意细节
1. 我们可以使用valatile，pointer（*），reference（&），rvalue reference（&&） 来修饰auto
#+BEGIN_SRC c++
auto k = 5;
auto* pK = new auto(k);
auto** ppK = new auto(&k);
const auto n = 6;
#+END_SRC
2. 用auto声明的变量必须初始化

~auto m; // m should be intialized~

3. auto不能与其他类型组合连用

~auto int p; // 这是旧auto的做法~

4. 函数和模板参数不能被声明为auto
#+BEGIN_SRC c++
void MyFunction(auto parameter){} // no auto as method argument
template<auto T> // utter nonsense - not allowed
void Fun(T t){}
#+END_SRC
5. 定义在堆上的变量，使用了auto的表达式必须被初始化
#+BEGIN_SRC c++
int* p = new auto(0); //fine
int* pp = new auto(); // should be initialized
auto x = new auto(); // Hmmm ... no intializer
auto* y = new auto(9); // Fine. Here y is a int*
auto z = new auto(9); //Fine. Here z is a int* (It is not just an int)
#+END_SRC
6. 以为auto是一个占位符，并不是一个他自己的类型，因此不能用于类型转换或其他一些操作，如sizeof和typeid
#+BEGIN_SRC c++
int value = 123;
auto x2 = (auto)value; // no casting using auto
auto x3 = static_cast<auto>(value); // same as above 
#+END_SRC
7. 定义在一个auto序列的变量必须始终推导成同一类型
#+BEGIN_SRC c++
auto x1 = 5, x2 = 5.0, x3='r';  // This is too much....we cannot combine like this
#+END_SRC
8. auto不能自动推导成CV-qualifiers（constant & volatile qualifiers），除非被声明为引用类型
#+BEGIN_SRC c++ 
const int i = 99;
auto j = i;       // j is int, rather than const int
j = 100           // Fine. As j is not constant
// Now let us try to have reference
auto& k = i;      // Now k is const int&
k = 100;          // Error. k is constant
// Similarly with volatile qualifer
#+END_SRC
9. auto会退化成指向数组的指针，除非被声明为引用
#+BEGIN_SRC c++
int a[9];
auto j = a;
cout<<typeid(j).name()<<endl; // This will print int*
auto& k = a;
cout<<typeid(k).name()<<endl; // This will print int [9]
#+END_SRC
* C++四种类型转换运算符
隐式类型转换是安全的，显式类型转换是有风险的，C语言之所以增加强制类型转换的语法，就是为了强调风险，让程序员意识到自己在做什么。

但是，这种强调风险的方式还是比较粗放，粒度比较大，它并没有表明存在什么风险，风险程度如何。再者，C风格的强制类型转换统一使用( )，而( )在代码中随处可见，所以也不利于使用文本检索工具（例如 Windows 下的 Ctrl+F、Linux 下的 grep 命令、Mac 下的 Command+F）定位关键代码。

为了使潜在风险更加细化，使问题追溯更加方便，使书写格式更加规范，C++ 对类型转换进行了分类，并新增了四个关键字来予以支持，它们分别是：
| 关键字           | 说明                                                                                                                          |
|------------------+-------------------------------------------------------------------------------------------------------------------------------|
| static_cast      | 用于良性转换，一般不会导致意外发生，风险很低。                                                                                |
| const_cast       | 用于 const 与非 const、volatile 与非 volatile 之间的转换。                                                                    |
| reinterpret_cast | 高度危险的转换，这种转换仅仅是对二进制位的重新解释，不会借助已有的转换规则对数据进行调整，但是可以实现最灵活的 C++ 类型转换。 |
| dynamic_cast     | 借助 RTTI，用于类型安全的向下转型（Downcasting）。                                                                            |
这四个关键字的语法格式都是一样的，具体为：
#+BEGIN_SRC c++
xxx_cast<newType>(data)
#+END_SRC
newType 是要转换成的新类型，data 是被转换的数据。例如，老式的C风格的 double 转 int 的写法为：
#+BEGIN_SRC c
double scores = 95.5;
int n = (int)scores;
#+END_SRC
C++ 新风格的写法为：
#+BEGIN_SRC c++
double scores = 95.5;
int n = static_cast<int>(scores);
#+END_SRC

** static_cast
static_cast 只能用于良性转换，这样的转换风险较低，一般不会发生什么意外，例如：
原有的自动类型转换，例如 short 转 int、int 转 double、const 转非 const、向上转型等；
void 指针和具体类型指针之间的转换，例如 ~void *~ 转 ~int *~ 、 ~char *~ 转 ~void *~ 等；
有转换构造函数或者类型转换函数的类与其它类型之间的转换，例如 double 转 Complex（调用转换构造函数）、Complex 转 double（调用类型转换函数）。

需要注意的是，static_cast 不能用于无关类型之间的转换，因为这些转换都是有风险的，例如：
两个具体类型指针之间的转换，例如int *转double *、Student *转int *等。不同类型的数据存储格式不一样，长度也不一样，用 A 类型的指针指向 B 类型的数据后，会按照 A 类型的方式来处理数据：如果是读取操作，可能会得到一堆没有意义的值；如果是写入操作，可能会使 B 类型的数据遭到破坏，当再次以 B 类型的方式读取数据时会得到一堆没有意义的值。
int 和指针之间的转换。将一个具体的地址赋值给指针变量是非常危险的，因为该地址上的内存可能没有分配，也可能没有读写权限，恰好是可用内存反而是小概率事件。

static_cast 也不能用来去掉表达式的 const 修饰和 volatile 修饰。换句话说，不能将 const/volatile 类型转换为非 const/volatile 类型。

static_cast 是“静态转换”的意思，也就是在编译期间转换，转换失败的话会抛出一个编译错误。

下面的代码演示了 static_cast 的正确用法和错误用法：
#+BEGIN_SRC c++
#include <iostream>
#include <cstdlib>
using namespace std;

class Complex{
public:
    Complex(double real = 0.0, double imag = 0.0): m_real(real), m_imag(imag){ }
public:
    operator double() const { return m_real; }  //类型转换函数
private:
    double m_real;
    double m_imag;
};

int main(){
    //下面是正确的用法
    int m = 100;
    Complex c(12.5, 23.8);
    long n = static_cast<long>(m);  //宽转换，没有信息丢失
    char ch = static_cast<char>(m);  //窄转换，可能会丢失信息
    int *p1 = static_cast<int*>( malloc(10 * sizeof(int)) );  //将void指针转换为具体类型指针
    void *p2 = static_cast<void*>(p1);  //将具体类型指针，转换为void指针
    double real= static_cast<double>(c);  //调用类型转换函数
   
    //下面的用法是错误的
    float *p3 = static_cast<float*>(p1);  //不能在两个具体类型的指针之间进行转换
    p3 = static_cast<float*>(0X2DF9);  //不能将整数转换为指针类型

    return 0;
}
#+END_SRC

** const_cast 
const_cast 比较好理解，它用来去掉表达式的 const 修饰或 volatile 修饰。换句话说，const_cast 就是用来将 const/volatile 类型转换为非 const/volatile 类型。

下面我们以 const 为例来说明 const_cast 的用法：
#+BEGIN_SRC c++
#include <iostream>
using namespace std;

int main(){
    const int n = 100;
    int *p = const_cast<int*>(&n);
    *p = 234;
    cout<<"n = "<<n<<endl;
    cout<<"*p = "<<*p<<endl;

    return 0;
}
#+END_SRC
运行结果：
n = 100
*p = 234

~&n~ 用来获取 n 的地址，它的类型为 ~const int *~ ，必须使用 const_cast 转换为 ~int *~ 类型后才能赋值给 p。由于 p 指向了 n，并且 n 占用的是栈内存，有写入权限，所以可以通过 p 修改 n 的值。

有读者可能会问，为什么通过 n 和 *p 输出的值不一样呢？这是因为 C++ 对常量的处理更像是编译时期的 ~#define~ ，是一个值替换的过程，代码中所有使用 n 的地方在编译期间就被替换成了 100。换句话说，第 8 行代码被修改成了下面的形式：
#+BEGIN_SRC c++
cout<<"n = "<<100<<endl;
#+END_SRC
这样一来，即使程序在运行期间修改 n 的值，也不会影响 cout 语句了。

使用 const_cast 进行强制类型转换可以突破 C/C++ 的常数限制，修改常数的值，因此有一定的危险性；但是程序员如果这样做的话，基本上会意识到这个问题，因此也还有一定的安全性。

** reinterpret_cast
reinterpret 是“重新解释”的意思，顾名思义，reinterpret_cast 这种转换仅仅是对二进制位的重新解释，不会借助已有的转换规则对数据进行调整，非常简单粗暴，所以风险很高。

reinterpret_cast 可以认为是 static_cast 的一种补充，一些 static_cast 不能完成的转换，就可以用 reinterpret_cast 来完成，例如两个具体类型指针之间的转换、int 和指针之间的转换（有些编译器只允许 int 转指针，不允许反过来）。

下面的代码代码演示了 reinterpret_cast 的使用：
#+BEGIN_SRC c++
#include <iostream>
using namespace std;

class A{
public:
    A(int a = 0, int b = 0): m_a(a), m_b(b){}
private:
    int m_a;
    int m_b;
};

int main(){
    //将 char* 转换为 float*
    char str[]="http://c.biancheng.net";
    float *p1 = reinterpret_cast<float*>(str);
    cout<<*p1<<endl;
    //将 int 转换为 int*
    int *p = reinterpret_cast<int*>(100);
    //将 A* 转换为 int*
    p = reinterpret_cast<int*>(new A(25, 96));
    cout<<*p<<endl;
   
    return 0;
}
#+END_SRC
运行结果：
3.0262e+29
25

可以想象，用一个 float 指针来操作一个 char 数组是一件多么荒诞和危险的事情，这样的转换方式不到万不得已的时候不要使用。将 ~A*~ 转换为 ~int*~ ，使用指针直接访问 private 成员刺穿了一个类的封装性，更好的办法是让类提供 get/set 函数，间接地访问成员变量。

** dynamic_cast
这部分内容我省略没写。
* cmake
** 简介
什么是cmake

你或许听过好几种 Make 工具，例如 GNU Make ，QT 的 qmake ，微软的 MSnmake，BSD Make（pmake），Makepp，等等。这些 Make 工具遵循着不同的规范和标准，所执行的 Makefile 格式也千差万别。这样就带来了一个严峻的问题：如果软件想跨平台，必须要保证能够在不同平台编译。而如果使用上面的 Make 工具，就得为每一种标准写一次 Makefile ，这将是一件让人抓狂的工作。

CMake就是针对上面问题所设计的工具：它首先允许开发者编写一种平台无关的 CMakeList.txt 文件来定制整个编译流程，然后再根据目标用户的平台进一步生成所需的本地化 Makefile 和工程文件，如 Unix 的 Makefile 或 Windows 的 Visual Studio 工程。从而做到“Write once, run everywhere”。显然，CMake 是一个比上述几种 make 更高级的编译配置工具。一些使用 CMake 作为项目架构系统的知名开源项目有 VTK、ITK、KDE、OpenCV、OSG 等。

在 linux 平台下使用 CMake 生成 Makefile 并编译的流程如下：
- 编写 CMake 配置文件 CMakeLists.txt 。
- 执行命令 cmake PATH 或者 ccmake PATH 生成 Makefile。其中， PATH 是 CMakeLists.txt 所在的目录。（ccmake 和 cmake 的区别在于前者提供了一个交互式的界面）
- 使用 make 命令进行编译。
** 入门案例
*** 单个源文件
本节对应的源代码所在目录：Demo1。

对于简单的项目，只需要写几行代码就可以了。例如，假设现在我们的项目中只有一个源文件 main.cc ，该程序的用途是计算一个数的指数幂。
#+BEGIN_SRC c++
#include <stdio.h>
#include <stdlib.h>
/**
 * power - Calculate the power of number.
 * @param base: Base value.
 * @param exponent: Exponent value.
 *
 * @return base raised to the power exponent.
 */
double power(double base, int exponent)
{
  int result = base;
  int i;
  
  if (exponent == 0) {
    return 1;
  }
  
  for(i = 1; i < exponent; ++i){
    result = result * base;
  }
  return result;
}
int main(int argc, char *argv[])
{
  if (argc < 3){
    printf("Usage: %s base exponent \n", argv[0]);
    return 1;
  }
  double base = atof(argv[1]);
  int exponent = atoi(argv[2]);
  double result = power(base, exponent);
  printf("%g ^ %d is %g\n", base, exponent, result);
  return 0;
}

#+END_SRC

首先编写 CMakeLists.txt 文件，并保存在与 main.cc 源文件同个目录下：
#+BEGIN_SRC c++
# CMake 最低版本号要求
cmake_minimum_required(VERSION 2.8)
# 项目信息
project(Demo1)
# 指定生成目标
add_executable(Demo main.cc)
#+END_SRC
CMakeLists.txt 的语法比较简单，由命令、注释和空格组成，其中命令是不区分大小写的。符号 # 后面的内容被认为是注释。命令由命令名称、小括号和参数组成，参数之间使用空格进行间隔。

对于上面的 CMakeLists.txt 文件，依次出现了几个命令：
- cmake_minimum_required：指定运行此配置文件所需的 CMake 的最低版本；
- project：参数值是 Demo1，该命令表示项目的名称是 Demo1 。
- add_executable： 将名为 main.cc 的源文件编译成一个名称为 Demo 的可执行文件。

编译项目:之后，在当前目录执行 cmake . ，得到 Makefile 后再使用 make 命令编译得到 Demo1 可执行文件。
#+BEGIN_SRC c++
[ehome@xman Demo1]$ cmake .
-- The C compiler identification is GNU 4.8.2
-- The CXX compiler identification is GNU 4.8.2
-- Check for working C compiler: /usr/sbin/cc
-- Check for working C compiler: /usr/sbin/cc -- works
-- Detecting C compiler ABI info
-- Detecting C compiler ABI info - done
-- Check for working CXX compiler: /usr/sbin/c++
-- Check for working CXX compiler: /usr/sbin/c++ -- works
-- Detecting CXX compiler ABI info
-- Detecting CXX compiler ABI info - done
-- Configuring done
-- Generating done
-- Build files have been written to: /home/ehome/Documents/programming/C/power/Demo1
[ehome@xman Demo1]$ make
Scanning dependencies of target Demo
[100%] Building C object CMakeFiles/Demo.dir/main.cc.o
Linking C executable Demo
[100%] Built target Demo
[ehome@xman Demo1]$ ./Demo 5 4
5 ^ 4 is 625
[ehome@xman Demo1]$ ./Demo 7 3
7 ^ 3 is 343
[ehome@xman Demo1]$ ./Demo 2 10
2 ^ 10 is 1024

#+END_SRC
*** 多个源文件
同一目录，多个源文件

本小节对应的源代码所在目录：Demo2。

上面的例子只有单个源文件。现在假如把 power 函数单独写进一个名为MathFunctions.c 的源文件里，使得这个工程变成如下的形式：
#+BEGIN_EXAMPLE
./Demo2
    |
    +--- main.cc
    |
    +--- MathFunctions.cc
    |
    +--- MathFunctions.h
#+END_EXAMPLE
这个时候，CMakeLists.txt 可以改成如下的形式：
#+BEGIN_SRC c++
# CMake 最低版本号要求
cmake_minimum_required(VERSION 2.8)
# 项目信息
project(Demo2)
# 指定生成目标
add_executable(Demo main.cc MathFunctions.cc)
#+END_SRC
唯一的改动只是在 add_executable 命令中增加了一个 MathFunctions.cc 源文件。这样写当然没什么问题，但是如果源文件很多，把所有源文件的名字都加进去将是一件烦人的工作。更省事的方法是使用 aux_source_directory 命令，该命令会查找指定目录下的所有源文件，然后将结果存进指定变量名。其语法如下：
#+BEGIN_SRC c++
aux_source_directory(<dir> <variable>)
#+END_SRC
因此，可以修改 CMakeLists.txt 如下：
#+BEGIN_SRC c++
# CMake 最低版本号要求
cmake_minimum_required(VERSION 2.8)
# 项目信息
project (Demo2)
# 查找当前目录下的所有源文件
# 并将名称保存到 DIR_SRCS 变量
aux_source_directory(. DIR_SRCS)
# 指定生成目标
add_executable(Demo ${DIR_SRCS})
#+END_SRC
这样，CMake 会将当前目录所有源文件的文件名赋值给变量 DIR_SRCS ，再指示变量 DIR_SRCS 中的源文件需要编译成一个名称为 Demo 的可执行文件。
*** 多个目录，多个源文件
本小节对应的源代码所在目录：Demo3。

现在进一步将 MathFunctions.h 和 MathFunctions.cc 文件移动到 math 目录下。
#+BEGIN_EXAMPLE
./Demo3
    |
    +--- main.cc
    |
    +--- math/
          |
          +--- MathFunctions.cc
          |
          +--- MathFunctions.h
#+END_EXAMPLE
对于这种情况，需要分别在项目根目录 Demo3 和 math 目录里各编写一个 CMakeLists.txt 文件。为了方便，我们可以先将 math 目录里的文件编译成静态库再由 main 函数调用。

根目录中的 CMakeLists.txt ：
#+BEGIN_SRC c++
# CMake 最低版本号要求
cmake_minimum_required(VERSION 2.8)
# 项目信息
project(Demo3)
# 查找当前目录下的所有源文件
# 并将名称保存到 DIR_SRCS 变量
aux_source_directory(. DIR_SRCS)
# 添加 math 子目录
add_subdirectory(math)
# 指定生成目标
add_executable(Demo main.cc)
# 添加链接库
target_link_libraries(Demo MathFunctions)
#+END_SRC
该文件添加了下面的内容: 第3行，使用命令 add_subdirectory 指明本项目包含一个子目录 math，这样 math 目录下的 CMakeLists.txt 文件和源代码也会被处理 。第6行，使用命令 target_link_libraries 指明可执行文件 main 需要连接一个名为 MathFunctions 的链接库 。

子目录中的 CMakeLists.txt：
#+BEGIN_SRC c++
# 查找当前目录下的所有源文件
# 并将名称保存到 DIR_LIB_SRCS 变量
aux_source_directory(. DIR_LIB_SRCS)
# 生成链接库
add_library (MathFunctions ${DIR_LIB_SRCS})
#+END_SRC
在该文件中使用命令 add_library 将 src 目录中的源文件编译为静态链接库。
*** 自定义编译选项
本节对应的源代码所在目录：Demo4。

CMake 允许为项目增加编译选项，从而可以根据用户的环境和需求选择最合适的编译方案。

例如，可以将 MathFunctions 库设为一个可选的库，如果该选项为 ON ，就使用该库定义的数学函数来进行运算。否则就调用标准库中的数学函数库。

修改 CMakeLists 文件：我们要做的第一步是在顶层的 CMakeLists.txt 文件中添加该选项： 
#+BEGIN_SRC c++
# CMake 最低版本号要求
cmake_minimum_required(VERSION 2.8)
# 项目信息
project(Demo4)
# 加入一个配置头文件，用于处理 CMake 对源码的设置
configure_file(
"${PROJECT_SOURCE_DIR}/config.h.in"
"${PROJECT_BINARY_DIR}/config.h"
)
# 是否使用自己的 MathFunctions 库
option(USE_MYMATH
"Use provided math implementation" ON)
# 是否加入 MathFunctions 库
if (USE_MYMATH)
 include_directories("${PROJECT_SOURCE_DIR}/math")
add_subdirectory(math)
set (EXTRA_LIBS ${EXTRA_LIBS} MathFunctions)
endif (USE_MYMATH)
# 查找当前目录下的所有源文件
# 并将名称保存到 DIR_SRCS 变量
aux_source_directory(. DIR_SRCS)
# 指定生成目标
add_executable(Demo ${DIR_SRCS})
target_link_libraries (Demo ${EXTRA_LIBS})
#+END_SRC
其中：

第7行的 configure_file 命令用于加入一个配置头文件 config.h ，这个文件由 CMake 从 config.h.in 生成，通过这样的机制，将可以通过预定义一些参数和变量来控制代码的生成。

第13行的 option 命令添加了一个 USE_MYMATH 选项，并且默认值为 ON 。

第17行根据 USE_MYMATH 变量的值来决定是否使用我们自己编写的 MathFunctions 库。
** set
set 有三种，分别为: 设置一般变量(Set Normal Variable)， 设置缓存变量(Set Cache Entry)，设置环境变量(Set Environment Variable)
#+BEGIN_SRC c++
// 1. 设置一般变量(Set Normal Variable)
set(<variable> <value>... [PARENT_SCOPE])

// 2. 设置缓存变量(Set Cache Entry)
set(<variable> <value>... CACHE <type> <docstring> [FORCE])

// 3. 设置环境变量(Set Environment Variable)
set(ENV{<variable>} [<value>])
#+END_SRC
*** 设置一般变量set(<variable> <value>... [PARENT_SCOPE])
#+BEGIN_SRC bash
set(<variable> <value>... [PARENT_SCOPE])
#+END_SRC
将一个或者多个值 <value>... 赋值给变量 <variable>， 多个值之间以分号（；）分隔。
**** 参数
- PARENT_SCOPE，配置该选项后，表示该变量在父级作用域上有效, 在当前作用域上是无效的;
**** 例子
目录结构如下:
#+BEGIN_EXAMPLE
rs:cmake-set$ tree
.
├── CMakeLists.txt
├── main.cpp
└── subdir
    └── CMakeLists.txt
#+END_EXAMPLE
顶层的　CMakeLists.txt
#+BEGIN_SRC c++
cmake_minimum_required(VERSION 3.5)

project(DEMO VERSION 10.2.1.3 LANGUAGES CXX C ASM )

# 设置一般变量
set(PNAME rsenjoyer)
set(PGRADE 80 85 90 95)

message("top name = ${PNAME}")  # top name = rsenjoyer
message("top grade = ${PGRADE}") #top grade = 80;85;90;95

add_subdirectory(subdir)

message("top after name = ${PNAME}")  # top name = rsenjoyer

add_executable(DEMO main.cpp)
#+END_SRC
子目录的 CMakeLists.txt
#+BEGIN_SRC c++
set(PNAME jack)
message("sub name = ${PNAME}") # sub name = jack

# 仅仅会改变父级的　PNAME，　对当前的变量不会更改
set(PNAME rose PARENT_SCOPE)
message("sub name = ${PNAME}") #sub name = jack
#+END_SRC
*** 设置缓存变量(Set Cache Entry)
什么是缓存变量，缓存变量可以理解为当第一次运行cmake时，这些变量缓存到一份文件中(即编译目录下的CMakeCache.txt)。当再次运行cmake时，这些变量会直接使用缓存值，可以利用ccmake或者cmake-gui等工具来重新赋值。缓存变量在整个cmake运行过程中都可以起作用。

当使用CACHE时，且缓存(cache)中没有该变量时，变量被创建并存入缓存(cache)中，如果原缓存(cache)中有该变量，也不会改变原缓存中该变量的值，除非后面使用FORCE。
#+BEGIN_SRC c++
set(<variable> <value>... CACHE <type> <docstring> [FORCE])
#+END_SRC
作用:
- 设置变量并缓存到 CMakeCache.txt
- 默认不会覆盖已缓存(已存在于 CMakeCache.txt )的变量；
**** 参数
- 类型 type,必须为以下的一种
    - BOOL,布尔值(ON/OFF)
    - FILEPATH,文件路径
    - PATH,目录路径
    - STRING,字符串
    - INTERNAL,单行文字.INTERNAL将变量为内部变量，即cmake-gui不会向用户显示这类变量，而其它类型的缓存变量用户都可以通cmake-gui按照特定的类型改变。
- 描述字符串 <docstring>: 单行文字,用于 CMAKE-GUI 的时提示用户
- FORCE 用于是否强制更新缓存里面的值，配置后，每次都会强制更新　CMakeCache.txt 里面的值
**** 例子
#+BEGIN_SRC c++
set(FOO, "x" CACHE <type>)  
//原缓存中没有FOO则将FOO赋值为x且存入cache中。
//原缓存中有FOO则不做任何改变，即便原cache中FOO存的不是x。
set(FOO, "x" CACHE <type><docstring> FORCE) 　　　
//即便原cache中存在FOO也会创建另一个FOO，官方文档原话(If FORCE is specified, the value of the cache variable 
//is set, even if the variable is already in the cache.This should normally be avoided, as it will 
//remove any changes to the cache variable’s value by the user.)，小弟笨拙没有搞懂。
#+END_SRC
**** 注意
1. CACHE与PARENT_SCOPE不能一起使用。
2. 同一名称(例FOO)的一般变量和缓存变量可以同时存在，但在调用该变量时(${FOO})会在先取一般变量的值，一般变量中没有再取缓存变量的值。
一些栗子：
#+BEGIN_EXAMPLE
set(FOO “x”)　　　　　　　　//设置一般变量FOO，不会触及cache，但是会隐藏cache中的FOO。

set(FOO “x” CACHE ...)　　//忽视相同名称的一般变量，在cache中检查FOO是否存在，
#+END_EXAMPLE
3. 当改变cache中的变量时，同名的一般变量会被删除。一般不建议使用相同名称的一般变量和缓存变量。

然而在有些工程中可以很好的借助这一交互例如：

一个工程利用ADD_SUBDIRECTOTY()添加子工程，子工程有它自己的CMakeList.txt。如果在父工程和子工程中都对同一缓存变量赋值，cmake时父工程率先将变量存入cache中，子工程直接在cache中调用该值，保证了父子工程的一致性。当父工程需要改变该变量，而子程序需要利用原值时，可以直接在父工程中设置同名称的一般变量即可。

*** 设置环境变量(Set Environment Variable)
#+BEGIN_SRC c++
set(ENV{<variable>} [<value>])
#+END_SRC
作用
- 设置环境变量 <variable>,值为 <value>
- 如果 <value> 不存在或者为空字符串 表示清除该环境变量
** 变量
*** 变量的作用域
- Function Scope: 在函数内部定义,仅仅在当前函数以及所调用的子函数内有效;
- Directory Scope: 在当前目录的定义的变量,当调用子目录时候,子目录会复制一份父级目录内的变量到子目录中
- Persistent Cache: 持久化的缓存,一般由CACHE 存储起来.
*** 变量的搜索路径
- 在当前 Function Scope 调用内查找,找到后使用,未找到进行下一步;
- 在当前目录下面查找,找到使用,未找到下一步;
- 在 CACHE 中寻找,找到使用,未找到,则为空.
*** Variables for Languages
**** CMAKE_COMPILER_IS_GNUCXX
True if the C++ (CXX) compiler is GNU. Use CMAKE_CXX_COMPILER_ID instead
*** Variables that Change Behavior.
**** CMAKE_MODULE_PATH
这个变量用来定义自己的 cmake 模块所在的路径。如果你的工程比较复杂,有可能会自己编写一些 cmake 模块,这些 cmake 模块是随你的工程发布的,为了让 cmake 在处理CMakeLists.txt 时找到这些模块,你需要通过 SET 指令,将自己的 cmake 模块路径设置一下。
比如 
#+BEGIN_SRC c++
SET(CMAKE_MODULE_PATH ${PROJECT_SOURCE_DIR}/cmake)
#+END_SRC
这时候你就可以通过 INCLUDE 指令来调用自己的模块了。
*** Variables that Provide Information
**** CMAKE_SOURCE_DIR
#+BEGIN_EXAMPLE
The path to the top level of the source tree.

This is the full path to the top level of the current CMake source tree. For an in-source build, this would be the same as CMAKE_BINARY_DIR.

When run in -P script mode, CMake sets the variables CMAKE_BINARY_DIR, CMAKE_SOURCE_DIR, CMAKE_CURRENT_BINARY_DIR and CMAKE_CURRENT_SOURCE_DIR to the current working directory.
#+END_EXAMPLE
PROJECT_SOURCE_DIR,<projectname>_SOURCE_DIR

这三个变量指代的内容是一致的,不论采用何种编译方式,都是工程顶层目录。
也就是在 in source 编译时,他跟 CMAKE_BINARY_DIR 等变量一致。
PROJECT_SOURCE_DIR 跟其他指令稍有区别,现在,你可以理解为他们是一致的。

** STREQUAL
STREQUAL 用于比较字符串，相同返回 true 。
** file命令
#+BEGIN_SRC c++
file(GLOB <variable>
     [LIST_DIRECTORIES true|false] [RELATIVE <path>] [CONFIGURE_DEPENDS]
     [<globbing-expressions>...])
file(GLOB_RECURSE <variable> [FOLLOW_SYMLINKS]
     [LIST_DIRECTORIES true|false] [RELATIVE <path>] [CONFIGURE_DEPENDS]
     [<globbing-expressions>...])
#+END_SRC
Generate a list of files that match the <globbing-expressions> and store it into the <variable>. Globbing expressions are similar to regular expressions, but much simpler. If RELATIVE flag is specified, the results will be returned as relative paths to the given path. The results will be ordered lexicographically.

On Windows and macOS, globbing is case-insensitive even if the underlying filesystem is case-sensitive (both filenames and globbing expressions are converted to lowercase before matching). On other platforms, globbing is case-sensitive.

If the CONFIGURE_DEPENDS flag is specified, CMake will add logic to the main build system check target to rerun the flagged GLOB commands at build time. If any of the outputs change, CMake will regenerate the build system.

产生一个匹配 <globbing-expressions> 的文件列表并将它存储到变量 <variable> 中。文件名替代表达式和正则表达式相似，但更简单。如果 RELATIVE 标志位被设定，将返回指定路径的相对路径。结果将按字典顺序排序。

如果 CONFIGURE_DEPENDS 标志位被指定，CMake 将在编译时给主构建系统添加逻辑来检查目标，以重新运行 GLOB 标志的命令。如果任何输出被改变，CMake都将重新生成这个构建系统。
** include指令
[[https://blog.csdn.net/qq_38410730/article/details/102677143][参考文章]]
*** include指令
include指令一般用于语句的复用，也就是说，如果有一些语句需要在很多CMakeLists.txt文件中使用，为避免重复编写，可以将其写在.cmake文件中，然后在需要的CMakeLists.txt文件中进行include操作就行了。

include指令的结构为：
#+BEGIN_EXAMPLE
include(<file|module> [OPTIONAL] [RESULT_VARIABLE <var>]
                      [NO_POLICY_SCOPE])
#+END_EXAMPLE
虽然，有不少的可选参数，但是一般情况下，都是直接写：
#+BEGIN_EXAMPLE
include(file|module)
#+END_EXAMPLE

注意，为了使CMakeLists.txt能够找到该文件，需要指定文件完整路径(绝对路径或相对路径)，当然如果指定了CMAKE_MODULE_PATH，就可以直接include该目录下的.cmake文件了。

.cmake文件里面通常是什么信息呢？

.cmake文件里包含了一些cmake命令和一些宏/函数，当CMakeLists.txt包含该.cmake文件时，当编译运行时，该.cmake里的一些命令就会在该包含处得到执行，并且在包含以后的地方能够调用该.cmake里的一些宏和函数。

什么是宏？什么是函数？
*** 宏和函数的定义
先看一下关键字：cmake的宏是MACRO，函数是function。它们的用法是：
#+BEGIN_SRC c++
macro(<name> [arg1 [arg2 [arg3 ...]]])
  COMMAND1(ARGS ...)            # 命令语句
  COMMAND2(ARGS ...)
  ...
endmacro()

function(<name> [arg1 [arg2 [arg3 ...]]])
  COMMAND1(ARGS ...)            # 命令语句
  COMMAND2(ARGS ...)
  ...
function()
#+END_SRC
定义一个名称为name的宏（函数），arg1...是传入的参数。我们除了可以用${arg1}来引用变量以外，系统为我们提供了一些特殊的变量：

| 变量  | 说明                                                 |
|-------+------------------------------------------------------|
| argv# | #是一个下标，0指向第一个参数，累加                   |
| argv  | 所有的定义时要求传入的参数                           |
| argn  | 定义时要求传入的参数以外的参数                       |
| argc  | 传入的实际参数的个数，也就是调用函数是传入的参数个数 |

*** 宏和函数的区别
那么宏和函数之间的区别是什么呢？

其实和C/C++里面宏和函数之间的区别差不多，宏就是字符串替换，函数就是使用变量，在命令中途可以对改变量进行修改。

以StackOverflow的例子来了解一下区别：

首先创建一个CMakeLists.txt：
#+BEGIN_EXAMPLE
cmake_minimum_required(VERSION 3.0)
include(test.cmake)
#+END_EXAMPLE
在同目录下创建文件test.cmake：
#+BEGIN_EXAMPLE
set(var "ABC")

macro(Moo arg)
  message("arg = ${arg}")
  set(arg "abc")
  message("# After change the value of arg.")
  message("arg = ${arg}")
endmacro()
message("=== Call macro ===")
Moo(${var})

function(Foo arg)
  message("arg = ${arg}")
  set(arg "abc")
  message("# After change the value of arg.")
  message("arg = ${arg}")
endfunction()
message("=== Call function ===")
Foo(${var})
#+END_EXAMPLE
运行cmake：
#+BEGIN_SRC bash
mkdir build && cd build
cmake ..
#+END_SRC
运行后的输出结果是：
#+BEGIN_EXAMPLE
-- The C compiler identification is GNU 5.4.0
-- The CXX compiler identification is GNU 5.4.0
-- Check for working C compiler: /usr/bin/cc
-- Check for working C compiler: /usr/bin/cc -- works
-- Detecting C compiler ABI info
-- Detecting C compiler ABI info - done
-- Detecting C compile features
-- Detecting C compile features - done
-- Check for working CXX compiler: /usr/bin/c++
-- Check for working CXX compiler: /usr/bin/c++ -- works
-- Detecting CXX compiler ABI info
-- Detecting CXX compiler ABI info - done
-- Detecting CXX compile features
-- Detecting CXX compile features - done
=== Call macro ===
arg = ABC
# After change the value of arg.
arg = ABC
=== Call function ===
arg = ABC
# After change the value of arg.
arg = abc
-- Configuring done
-- Generating done
-- Build files have been written to: /home/yngzmiao/test/build
#+END_EXAMPLE
从这里可以看出，宏实现的仅仅是字符串替换，宏定义的过程中是无法进行修改的，而函数却是可以的。

*** 宏和函数参数的差异
一般情况下，从上面的例子就能看出宏和函数的用法了，但很多情况下，我们自以为的“懂了”都是假懂。比如一不小心，就会出错。

更换test.cmake为下面的内容，并运行：
#+BEGIN_EXAMPLE
set(var "ABC")

macro(Moo arg)
  message("arg = ${arg}")
  set(arg "abc")
  message("# After change the value of arg.")
  message("arg = ${arg}")
endmacro()
message("=== Call macro ===")
Moo(var)

function(Foo arg)
  message("arg = ${arg}")
  set(arg "abc")
  message("# After change the value of arg.")
  message("arg = ${arg}")
endfunction()
message("=== Call function ===")
Foo(var)
#+END_EXAMPLE
运行后的输出结果是：
#+BEGIN_EXAMPLE
-- The C compiler identification is GNU 5.4.0
-- The CXX compiler identification is GNU 5.4.0
-- Check for working C compiler: /usr/bin/cc
-- Check for working C compiler: /usr/bin/cc -- works
-- Detecting C compiler ABI info
-- Detecting C compiler ABI info - done
-- Detecting C compile features
-- Detecting C compile features - done
-- Check for working CXX compiler: /usr/bin/c++
-- Check for working CXX compiler: /usr/bin/c++ -- works
-- Detecting CXX compiler ABI info
-- Detecting CXX compiler ABI info - done
-- Detecting CXX compile features
-- Detecting CXX compile features - done
=== Call macro ===
arg = var
# After change the value of arg.
arg = var
=== Call function ===
arg = var
# After change the value of arg.
arg = abc
-- Configuring done
-- Generating done
-- Build files have been written to: /home/yngzmiao/test/build
#+END_EXAMPLE
对比两段程序可以看出其中的区别：无论是宏还是函数，当调用的时候如果使用的是set出来的变量，都必须通过${}将变量的内容传递进去，而不能只写上变量名。

这是将实参传递给形参时的注意点，但在宏和函数的实现过程中，还有需要注意的内容。

例子：
#+BEGIN_EXAMPLE
set(var "ABC")

macro(Moo arg)
  if (arg STREQUAL "ABC")
    message("arg1 = ${arg}")
  endif()
  if (${arg} STREQUAL "ABC")
    message("arg2 = ${arg}")
  endif()
endmacro()
message("=== Call macro ===")
Moo(${var})

function(Foo arg)
  if (arg STREQUAL "ABC")
    message("arg1 = ${arg}")
  endif()
  if (${arg} STREQUAL "ABC")
    message("arg2 = ${arg}")
  endif()
endfunction()
message("=== Call function ===")
Foo(${var})
#+END_EXAMPLE
运行后的输出结果是：
#+BEGIN_EXAMPLE
-- The C compiler identification is GNU 5.4.0
-- The CXX compiler identification is GNU 5.4.0
-- Check for working C compiler: /usr/bin/cc
-- Check for working C compiler: /usr/bin/cc -- works
-- Detecting C compiler ABI info
-- Detecting C compiler ABI info - done
-- Detecting C compile features
-- Detecting C compile features - done
-- Check for working CXX compiler: /usr/bin/c++
-- Check for working CXX compiler: /usr/bin/c++ -- works
-- Detecting CXX compiler ABI info
-- Detecting CXX compiler ABI info - done
-- Detecting CXX compile features
-- Detecting CXX compile features - done
=== Call macro ===
arg2 = ABC
=== Call function ===
arg1 = ABC
arg2 = ABC
-- Configuring done
-- Generating done
-- Build files have been written to: /home/yngzmiao/test/build
#+END_EXAMPLE
可以看出，在宏和函数的实现过程中，宏的参数由于不是传统意义上的变量，而是字符串替换，因此需要通过${}取出内容。而函数却不一定需要这样。

也就是说，对于macro宏而言：
#+BEGIN_EXAMPLE
if(argv0)                         # 错误用法
if(${argv0})                      # 正确用法
if(defined argv0)                 # 错误用法
if(defined ${argv0})              # 正确用法
#+END_EXAMPLE
也就是说，对于宏和函数的参数而言：
- 当宏和函数调用的时候，如果传递的是经set设置的变量，必须通过${}取出内容；
- 在宏的定义过程中，对变量进行的操作必须通过${}取出内容，而函数就没有这个必要。
** cmake命令选项

#+DOWNLOADED: file:E%3A/org/%E5%9B%BE%E7%89%87/Snipaste_2021-05-01_15-36-45.png @ 2021-05-01 15:36:52
[[file:cmake/2021-05-01_15-36-52_Snipaste_2021-05-01_15-36-45.png]]

** message
纪录一条消息。
*** General messages
#+BEGIN_SRC c++
message([<mode>] "message text" ...)
#+END_SRC
Record the specified message text in the log. If more than one message string is given, they are concatenated into a single message with no separator between the strings.

The optional <mode> keyword determines the type of message, which influences the way the message is handled:

The CMake command-line tool displays STATUS to TRACE messages on stdout with the message preceded by two hyphens and a space. All other message types are sent to stderr and are not prefixed with hyphens. The CMake GUI displays all messages in its log area. The curses interface shows STATUS to TRACE messages one at a time on a status line and other messages in an interactive pop-up box. The --log-level command-line option to each of these tools can be used to control which messages will be shown.

New in version 3.17: To make a log level persist between CMake runs, the CMAKE_MESSAGE_LOG_LEVEL variable can be set instead. Note that the command line option takes precedence over the cache variable.

New in version 3.16: Messages of log levels NOTICE and below will have each line preceded by the content of the CMAKE_MESSAGE_INDENT variable (converted to a single string by concatenating its list items). For STATUS to TRACE messages, this indenting content will be inserted after the hyphens.

New in version 3.17: Messages of log levels NOTICE and below can also have each line preceded with context of the form [some.context.example]. The content between the square brackets is obtained by converting the CMAKE_MESSAGE_CONTEXT list variable to a dot-separated string. The message context will always appear before any indenting content but after any automatically added leading hyphens. By default, message context is not shown, it has to be explicitly enabled by giving the cmake --log-context command-line option or by setting the CMAKE_MESSAGE_CONTEXT_SHOW variable to true. See the CMAKE_MESSAGE_CONTEXT documentation for usage examples.

CMake Warning and Error message text displays using a simple markup language. Non-indented text is formatted in line-wrapped paragraphs delimited by newlines. Indented text is considered pre-formatted.
**** mode
- FATAL_ERROR: CMake Error, stop processing and generation.
- SEND_ERROR: CMake Error, continue processing, but skip generation.
- WARNING: CMake Warning, continue processing.
- AUTHOR_WARNING: CMake Warning (dev), continue processing.
- DEPRECATION: CMake Deprecation Error or Warning if variable CMAKE_ERROR_DEPRECATED or CMAKE_WARN_DEPRECATED is enabled, respectively, else no message.
- (none) or NOTICE: Important message printed to stderr to attract user's attention.
- STATUS： The main interesting messages that project users might be interested in. Ideally these should be concise, no more than a single line, but still informative.
- VERBOSE： Detailed informational messages intended for project users. These messages should provide additional details that won't be of interest in most cases, but which may be useful to those building the project when they want deeper insight into what's happening.
- DEBUG： Detailed informational messages intended for developers working on the project itself as opposed to users who just want to build it. These messages will not typically be of interest to other users building the project and will often be closely related to internal implementation details.
- TRACE： Fine-grained messages with very low-level implementation details. Messages using this log level would normally only be temporary and would expect to be removed before releasing the project, packaging up the files, etc.

*** Reporting checks
A common pattern in CMake output is a message indicating the start of some sort of check, followed by another message reporting the result of that check. For example:
#+BEGIN_SRC c++
message(STATUS "Looking for someheader.h")
#... do the checks, set checkSuccess with the result
if(checkSuccess)
  message(STATUS "Looking for someheader.h - found")
else()
  message(STATUS "Looking for someheader.h - not found")
endif()
#+END_SRC
This can be more robustly and conveniently expressed using the CHECK_... keyword form of the message() command:
#+BEGIN_SRC c++
message(<checkState> "message" ...)where <checkState> must be one of the following:
#+END_SRC
- CHECK_START:Record a concise message about the check about to be performed.
- CHECK_PASS:Record a successful result for a check.
- CHECK_FAIL:Record an unsuccessful result for a check.

When recording a check result, the command repeats the message from the most recently started check for which no result has yet been reported, then some separator characters and then the message text provided after the CHECK_PASS or CHECK_FAIL keyword. Check messages are always reported at STATUS log level.

Checks may be nested and every CHECK_START should have exactly one matching CHECK_PASS or CHECK_FAIL. The CMAKE_MESSAGE_INDENT variable can also be used to add indenting to nested checks if desired. For example:
#+BEGIN_SRC c++
message(CHECK_START "Finding my things")
list(APPEND CMAKE_MESSAGE_INDENT "  ")
unset(missingComponents)

message(CHECK_START "Finding partA")
# ... do check, assume we find A
message(CHECK_PASS "found")

message(CHECK_START "Finding partB")
# ... do check, assume we don't find B
list(APPEND missingComponents B)
message(CHECK_FAIL "not found")

list(POP_BACK CMAKE_MESSAGE_INDENT)
if(missingComponents)
  message(CHECK_FAIL "missing components: ${missingComponents}")
else()
  message(CHECK_PASS "all components found")
endif()
#+END_SRC
Output from the above would appear something like the following:
#+BEGIN_EXAMPLE
-- Finding my things
--   Finding partA
--   Finding partA - found
--   Finding partB
--   Finding partB - not found
-- Finding my things - missing components: B
#+END_EXAMPLE
** include
include 用于加载makefile文件

-include 表示当文件不存在时，make不会报错
*** 参考文章
[[https://www.gnu.org/software/make/manual/html_node/Include.html][3.3 Including Other Makefiles]]
[[https://blog.csdn.net/xiaozhi_su/article/details/4202779][Makefile中指示符“include”、“-include”和“sinclude”的区别]]
[[https://stackoverflow.com/questions/16981464/difference-between-include-and-include-in-a-makefile][Difference between "include" and "-include" in a makefile]]
** Makefile选项CFLAGS,LDFLAGS,LIBS
CFLAGS 表示用于 C 编译器的选项，
CXXFLAGS 表示用于 C++ 编译器的选项。
这两个变量实际上涵盖了编译和汇编两个步骤。

CFLAGS： 指定头文件（.h文件）的路径，如：CFLAGS=-I/usr/include -I/path/include。同样地，安装一个包时会在安装路径下建立一个include目录，当安装过程中出现问题时，试着把以前安装的包的include目录加入到该变量中来。

LDFLAGS：gcc 等编译器会用到的一些优化参数，也可以在里面指定库文件的位置。用法：LDFLAGS=-L/usr/lib -L/path/to/your/lib。每安装一个包都几乎一定的会在安装目录里建立一个lib目录。如果明明安装了某个包，而安装另一个包时，它愣是说找不到，可以抒那个包的lib路径加入的LDFALGS中试一下。

LIBS：告诉链接器要链接哪些库文件，如LIBS = -lpthread -liconv

简单地说，LDFLAGS是告诉链接器从哪里寻找库文件，而LIBS是告诉链接器要链接哪些库文件。不过使用时链接阶段这两个参数都会加上，所以你即使将这两个的值互换，也没有问题。

有时候LDFLAGS指定-L虽然能让链接器找到库进行链接，但是运行时链接器却找不到这个库，如果要让软件运行时库文件的路径也得到扩展，那么我们需要增加这两个库给"-Wl,R"：

LDFLAGS = -L/var/xxx/lib -L/opt/mysql/lib -Wl,R/var/xxx/lib -Wl,R/opt/mysql/lib

如果在执行./configure以前设置环境变量export LDFLAGS="-L/var/xxx/lib -L/opt/mysql/lib -Wl,R/var/xxx/lib -Wl,R/opt/mysql/lib" ，注意设置环境变量等号两边不可以有空格，而且要加上引号（shell的用法）。那么执行configure以后，Makefile将会设置这个选项，链接时会有这个参数，编译出来的可执行程序的库文件搜索路径就得到扩展了。
*** 参考文章
[[https://www.cnblogs.com/taskiller/archive/2012/12/14/2817650.html][Makefile选项CFLAGS,LDFLAGS,LIBS - Taskiller - 博客园]]
** =和:=的区别
如果使用=，make会将整个makefile展开后，再决定变量的值。也就是说，变量的值将会是整个makefile中最后被指定的值。看例子：
#+begin_src bash
x = foo
y = $(x) bar
x = xyz
#+END_SRC

在上例中，y的值将会是 xyz bar ，而不是 foo bar 。
#+begin_src bash
x := foo
y := $(x) bar
x := xyz
#+END_SRC
而:=表示变量在赋值时就先设置为该值，而不是整个makefile展开后的最终值，后面如果再有赋值，则会将前面的赋值覆盖，使用新的值。

在上例中，y的值将会是 foo bar ，而不是 xyz bar 了。

#+BEGIN_EXAMPLE
Simple assignment :=
A simple assignment expression is evaluated only once, at the very first occurrence. For example, if CC :=${GCC} ${FLAGS} during the first encounter is evaluated to gcc -W then each time ${CC} occurs it will be replaced with gcc -W.

Recursive assignment =
A Recursive assignment expression is evaluated everytime the variable is encountered in the code. For example, a statement like CC = ${GCC} {FLAGS} will be evaluated only when an action like ${CC} file.c is executed. However, if the variable GCC is reassigned i.e GCC=c++ then the ${CC} will be converted to c++ -W after the reassignment.

Conditional assignment ?=
Conditional assignment assigns a value to a variable only if it does not have a value

Appending +=
Assume that CC = gcc then the appending operator is used like CC += -w
then CC now has the value gcc -W
#+END_EXAMPLE
For more check out these [[https://github.com/amjadmajid/Makefile][tutorials]]
*** 参考文章
[[https://www.cnblogs.com/wanqieddy/archive/2011/09/21/2184257.html][Makefile 中:= ?= += =的区别- wanqi - 博客园]]
[[https://www.sunxidong.com/237.html][Makefile中“=”、“:=”、“?=”、“+=”的区别 - 孙希栋的博客]]
[[https://stackoverflow.com/questions/4879592/whats-the-difference-between-and-in-makefile][What's the difference between := and = in Makefile?]]
* C++ STL vector添加元素（push_back()和emplace_back()）详解
emplace_back() 和 push_back() 的区别，就在于底层实现的机制不同。push_back() 向容器尾部添加元素时，首先会创建这个元素，然后再将这个元素拷贝或者移动到容器中（如果是拷贝的话，事后会自行销毁先前创建的这个元素）；而 emplace_back() 在实现时，则是直接在容器尾部创建这个元素，省去了拷贝或移动元素的过程。
* lambda表达式
The predicates we pass to an algorithm must have exactly one or two parameters,depending on whether the algorithm takes a unary or binary predicate, respectively.However, sometimes we want to do processing that requires more arguments than the algorithm’s predicate allows.

A lambda expression represents a callable unit of code. It can be thought of as an unnamed, inline function. Like any function, a lambda has a return type, a parameter list, and a function body. Unlike a function, lambdas may be defined inside a function.A lamba expression has the form 
~[capture list] (parameter list) -> return type { function body }~

where capture list is an (often empty) list of local variables defined in the enclosing function; return type, parameter list, and function body are the same as in any ordinary function. However, unlike ordinary functions, a lambda must use a trailing return to specify its return type.

We can omit either or both of the parameter list and return type but must always include the capture list and function body:
#+BEGIN_SRC c++
auto f = [] { return 42; };
cout << f() << endl; // prints 42
#+END_SRC
Here, we’ve defined f as a callable object that takes no arguments and returns 42.
* new创建类对象与不new区别
#+BEGIN_SRC c++
A a;

A * a = new a();
#+END_SRC
以上两种方式皆可实现类的实例化,区别在于：
1. 前者在堆栈中分配内存，后者为动态内存分配，在一般应用中是没有什么区别的，但动态内存分配会使对象的可控性增强。
2. 前者在栈中分配内存，后者在堆中分配内存
3. 大程序用new，小程序直接申请
4. new必须delete删除;不用new的方式，系统会自动回收内存

* set自定义去重和排序函数
** 方法一：使用std::set内置的less比较函数（直接定义内置类型的set对象）

这种方法适用于：1）比较int、char等内置类型。2）只能针对某一个内置类型去重和排序：如果想通过id（int）去重，并通过hot(int)排序，该种方法就束手无策了。代码如下：
#+BEGIN_SRC c++
#include <iostream>
#include <set>
using namespace std;
void main()
{
    std::set<int> mySet;    // 直接定义内置类型set集合
    mySet.insert(10);       // 默认比较函数为less
    mySet.insert(20);       // 从小到大排序
    for(auto it:mySet)
    {
        std::cout<<it<<std::endl;
    }
    std::cout<<"end"<<std::endl;

}
#+END_SRC
#+BEGIN_EXAMPLE
结果如下：
output：
            10
            20
            end
#+END_EXAMPLE

** 方法二：自定义类（结构体）比较函数

前文提到：直接定义内置类型的set对象，即使用std::set内置的默认的less比较函数，可能不能满足我们的实际需求。例如：现在有一批结构体对象，需要将其插入set集合，并按照id去重，按照热度hot进行排序。这个时候，就需要重新自定义比较函数了。有两种方法可以自定义比较函数：
*** 重载<操作符
甚么要重载<运算符呢？能不能重载"<="或者">="运算符？答案是不可以。几乎所有的方法或容器都需要排序来满足数学意义上的标准严格弱序化，否则这些方法或容器的行为将不可预知。假设f(x,y)是一个比较函数。 如果该函数满足如下条件则它是严格弱序化的。
1. f(x,x) = false; 
2. if f(x,y) then !f(y,x)
3. if f(x,y) and f(y,z) then f(x,z)
4. if !f(x,y)&&!f(y,x) then x==y; if x==y and y==z then x==z;

看上去有点晕乎，不过不用担心，只要你的比较方法能够满足对相等元素永远返回false（记住一个准则：永远让比较函数对相同元素返回false），那你的方法就满足要求了。

其实，set容器在判定已有元素a和新插入元素b是否相等时，是这么做的：
1. 将a作为左操作数，b作为有操作数，调用比较函数，并返回比较值  
2. 将b作为左操作数，a作为有操作数，再调用一次比较函数，并返回比较值。如果1、2两步的返回值都是false，则认为a、b是相等的，则b不会被插入set容器中；

如果1、2两步的返回值都是true，则可能发生未知行为，因此，记住一个准则：永远让比较函数对相同元素返回false。
#+BEGIN_SRC c++
#include <iostream>
#include <set>
using namespace std;
struct song
{
    int m_id;
    int m_hot;
    song(int id,int hot)
    {

        this->m_id = id;
        this->m_hot = hot;
    }
    bool operator<(const struct song & right)const   //重载<运算符
    {
        if(this->m_id == right.m_id)     //根据id去重
            return false;
        else
        {
            if(this->m_hot != right.m_hot)
            {
                return this->m_hot > right.m_hot;      //降序
            }
            else
            {
                return this->m_id > right.m_id;     
            }
        }
    }
};
void main()
{
    std::set<song> mySet;
    song s1(10,100);
    song s2(20,200);
    song s3(20,300);
    song s4(30,200);
    mySet.insert(s1);    //插入s1
    mySet.insert(s2);    //插入s2
    mySet.insert(s3);    //s3和s2的id相同，不插入
    mySet.insert(s4);    //插入s4
    for(auto it:mySet)
    {
        std::cout<<"id:"<<it.m_id<<",hot:"<<it.m_hot<<std::endl;
    }
    std::cout<<"end"<<std::endl;
;}
#+END_SRC
#+BEGIN_EXAMPLE
结果如下：
id：30，hot ： 200
id：20，hot ： 200
id：10，hot ： 100
end
#+END_EXAMPLE
*** 重载（）运算符
具体代码如下：
#+BEGIN_SRC c++
#include <iostream>
#include <set>
using namespace std;
struct song
{
    int m_id;
    int m_hot;
    song(int id,int hot)
    {

        this->m_id = id;
        this->m_hot = hot;
    }
    /*
    bool operator<(const struct song & right)const   //重载<运算符
    {
        if(this->m_id == right.m_id)     //根据id去重
            return false;
        else
        {
            if(this->m_hot != right.m_hot)
            {
                return this->m_hot > right.m_hot;      //降序
            }
            else
            {
                return this->m_id > right.m_id;
            }
        }
    }
    */
};
struct comp
{
    bool operator()(struct song left,struct song  right)  //重载（）运算符
    {

        if(left.m_id == right.m_id)     //根据id去重
            return false;
        else
        {
            if(left.m_hot != right.m_hot)
            {
                return left.m_hot > right.m_hot;      //降序
            }
            else
            {
                return left.m_id > right.m_id;
            }

        }
    }

};
void main()
{
    std::set<song,comp> mySet;      //写法和2.1中的的区别
    song s1(10,100);
    song s2(20,200);
    song s3(20,300);
    song s4(30,200);
    mySet.insert(s1);    //插入s1
    mySet.insert(s2);    //插入s2
    mySet.insert(s3);    //s3和s2的id相同，不插入
    mySet.insert(s4);    //插入s4
    for(auto it:mySet)
    {
        std::cout<<"id:"<<it.m_id<<",hot:"<<it.m_hot<<std::endl;
    }
    std::cout<<"end"<<std::endl;
};
#+END_SRC
#+BEGIN_EXAMPLE
结果如下：
id：30，hot ： 200
id：20，hot ： 200
id：10，hot ： 100
end
#+END_EXAMPLE
* SFML
SFML 是多媒体库，它为PC的各个组件提供简单的界面，用来简化游戏和多媒体应用程序的开发。 主要由五个模块组成，分别是：系统，窗口，图形，音频和网络。

SFML 是跨平台的，通过 SFML，你的应用程序可以在最常见的操作系统上进行编译和运行：Windows，Linux，macOS以及Android和iOS。

SFML 支持多种语言，具体可以在官网查看支持的语言。
* std
** 介绍
std::是个名称空间标识符，C++标准库中的函数或者对象都是在命名空间std中定义的，所以我们要使用标准库中的函数或者对象都要用std来限定。

至于为什么将cout放到名字空间std中，是因为象cout这样的对象在实际操作中或许会有好多个，比如说你自己也可能会不小心定义一个对象叫cout，那么这两个cout对象就会产生冲突。


一般来说，std都是要调用C++标准库时使用。比如：使用标准库文件iostream时，要写上std;使用非标准库文件iostream.h，不用写。如图引入非标准库iostream.h时，省去了std::
#+BEGIN_SRC c++
#include <iostream.h>
#+END_SRC

当然使用标准库时，也是可以省略的，不过需要进行处理

1. 分别将cout和endl释放出来
#+BEGIN_SRC c++
#include <iostream>
using std::cout;
using std::endl;
#+END_SRC

2. 将命名空间释放出来

注：using namespace std 告诉编辑器我们将要使用名字空间std中的函数或者对象，所以cout和endl前面不用注明他们是std这个名字空间中的cout和endl
#+BEGIN_SRC c++
#include <iostream>
using namespace std;
#+END_SRC

** transform
transform函数的作用是：将某操作应用于指定范围的每个元素。transform函数有两个重载版本：

transform(first,last,result,op);//first是容器的首迭代器，last为容器的末迭代器，result为存放结果的容器，op为要进行操作的一元函数对象或sturct、class。

transform(first1,last1,first2,result,binary_op);//first1是第一个容器的首迭代 器，last1为第一个容器的末迭代器，first2为第二个容器的首迭代器，result为存放结果的容器，binary_op为要进行操作的二元函数 对象或sturct、class。

注意：第二个重载版本必须要保证两个容器的元素个数相等才行，否则会抛出异常
*** 例子
看一个例子：利用transform函数将一个给定的字符串中的小写字母改写成大写字母，并将结果保存在一个叫second的数组里，原字符串内容不变。
我们只需要使用transform的第一个重载函数，当然我们也可以使用for_each函数来完成再copy几次就行了，现在来看一下代码：
#+BEGIN_SRC c++
#include <iostream>
#include <algorithm>
using namespace std;
char op(char ch)
{

   if(ch>='A'&&ch<='Z')
        return ch+32;
    else
        return ch;
}
int main()
{
    string first,second;
    cin>>first;
    second.resize(first.size());
    transform(first.begin(),first.end(),second.begin(),op);
    cout<<second<<endl;
    return 0;
}
#+END_SRC

再看一个例子：给你两个vector向量（元素个数相等），请你利用transform函数将两个vector的每个元素相乘，并输出相乘的结果。
代码：
foreach的用法
#+BEGIN_SRC c++
#include <iostream>
#include <algorithm>
#include <vector>
using namespace std;
void print(int &elem){cout<<elem<<" ";}
int op(int a,int b){return a*b;}
int main()
{
    vector <int> A,B,SUM;
    int n;
    cin>>n;
    for(int i=0;i<n;i++)
    {
        int t;
        cin>>t;
        A.push_back(t);
    }
    for(int i=0;i<n;i++)
    {
        int t;
        cin>>t;
        B.push_back(t);
    }
    SUM.resize(n);
    transform(A.begin(),A.end(),B.begin(),SUM.begin(),op);
    for_each(SUM.begin(),SUM.end(),print);
    return 0;
}
#+END_SRC
** to_string
** all_of
all_of() 算法会返回 true，前提是序列中的所有元素都可以使谓词返回 true。

*** 实例
下面是一段代码，用来展示用 all_of() 检查 ages 容器中的元素： 
#+BEGIN_SRC c++
int good_age{100};
std::cout << (std::all_of(std::begin(ages), std::end(ages),[good_age] (int age) { return age < good_age; }) ? "None": "Some") << " of the people are centenarians." << std::endl;
#+END_SRC
这个 lambda 表达式会将 ages 中的元素和 good_age 的值作比较，good_age 的值为 100。所有的元素都小于 100，所以 all_of() 会返回 true，而且输出消息会正确报告没有记录的百岁老人。
** accumulate
accumulate定义在#include<numeric>中，作用有两个，一个是累加求和，另一个是自定义类型数据的处理

1. 累加求和
~int sum = accumulate(vec.begin() , vec.end() , 42);~

accumulate带有三个形参：头两个形参指定要累加的元素范围，第三个形参则是累加的初值。

accumulate函数将它的一个内部变量设置为指定的初始值，然后在此初值上累加输入范围内所有元素的值。accumulate算法返回累加的结果，其返回类型就是其第三个实参的类型。

可以使用accumulate把string型的vector容器中的元素连接起来：

~string sum = accumulate(v.begin() , v.end() , string(" "));~

这个函数调用的效果是：从空字符串开始，把vec里的每个元素连接成一个字符串。

2. 自定义数据类型的处理

C++ STL中有一个通用的数值类型计算函数— accumulate(),可以用来直接计算数组或者容器中C++内置数据类型，例如：
#+BEGIN_SRC c++
#include <numeric>  
int arr[]={10,20,30,40,50};  
vector<int> va(&arr[0],&arr[5]);  
int sum=accumulate(va.begin(),va.end(),0);  //sum = 150  
#+END_SRC
但是对于自定义数据类型，我们就需要自己动手写一个回调函数来实现自定义数据的处理，然后让它作为accumulate()的第四个参数，accumulate()的原型为
#+BEGIN_SRC c++
template<class _InIt, class _Ty,  class _Fn2> 
inline _Ty _Accumulate(_InIt _First, _InIt _Last, _Ty _Val, _Fn2 _Func)  
{   // return sum of _Val and all in [_First, _Last), using _Func  
    for (; _First != _Last; ++_First)  
        _Val = _Func(_Val, *_First);  
    return (_Val);  
}
#+END_SRC
下面是例子：
#+BEGIN_SRC c++

#include <vector>  
#include <string>  
using namespace std;  
  
struct Grade  
{  
    string name;  
    int grade;  
};  
  
int main()  
{  
    Grade subject[3] = {  
        { "English", 80 },  
        { "Biology", 70 },  
        { "History", 90 }  
    };  
  
    int sum = accumulate(subject, subject + 3, 0, [](int a, Grade b){return a + b.grade; });  
    cout << sum << endl;  
  
    system("pause");  
    return 0;  
} 
#+END_SRC
* std::hex
Sets the basefield format flag for the str stream to hex.

When basefield is set to hex, integer values inserted into the stream are expressed in hexadecimal base (i.e., radix 16). For input streams, extracted values are also expected to be expressed in hexadecimal base when this flag is set.

The basefield format flag can take any of the following values (each with its own manipulator):

| flag value | effect when set                                          |
|------------+----------------------------------------------------------|
| dec        | read/write integer values using decimal base format.     |
| hex        | read/write integer values using hexadecimal base format. |
| oct        | read/write integer values using octal base format.       |

example:
#+BEGIN_SRC c++
// modify basefield
#include <iostream>     // std::cout, std::dec, std::hex, std::oct

int main () {
  int n = 70;
  std::cout << std::dec << n << '\n';
  std::cout << std::hex << n << '\n';
  std::cout << std::oct << n << '\n';
  return 0;
}
#+END_SRC
#+BEGIN_EXAMPLE
Output:
70
46
106

#+END_EXAMPLE
* std::boolalpha
Sets the boolalpha format flag for the str stream.

When the boolalpha format flag is set, bool values are inserted/extracted by their textual representation: either true or false, instead of integral values.

example:
#+BEGIN_SRC c++
// modify boolalpha flag
#include <iostream>     // std::cout, std::boolalpha, std::noboolalpha

int main () {
  bool b = true;
  std::cout << std::boolalpha << b << '\n';
  std::cout << std::noboolalpha << b << '\n';
  return 0;
}
#+END_SRC
#+BEGIN_EXAMPLE
Output:
true
1
#+END_EXAMPLE
* std::optional

** 例子 
场景：如果有这样一个函数，通过返回值来判断计算结果是否有效，如果结果有效，才能使用结果 。

例如：计算a、b相除。b有可能为0，所以需要考虑相除结果是否有效。
#+BEGIN_SRC c++
bool div_int(int a, int b, int &result) {
    if (b == 0) {
        return false;
    }
    result = a / b;
    return true;
}

TEST_F(before_optional) {
    int result = 0; // 接收结果
    auto ret = div_int(2, 1, result);
    ASSERT(ret);
    ASSERT_EQ(2, result); // 如果返回值为true, 结果才有效

    auto b = div_int(2, 0, result);
    ASSERT(!b);
}
#+END_SRC
这样的使用方式很不方便，需要两个变量来描述结果。这种场景下应该使用c++17中的std::optional。我们用std::optional改写上面这个例子：
#+BEGIN_SRC c++
//div_int可以通过optional优化：optional中，结果是否有效和结果都保存在其中
std::optional<int> div_int(int a, int b) {
    if (b != 0) {
        return std::make_optional<int>(a / b);
    }
    return {};
}

TEST_F(optional) {
    auto ret = div_int(2, 1);
    ASSERT(ret);
    ASSERT_EQ(2, ret.value()); // 如果ret为true, 直接从ret中获取结果

    auto ret2 = div_int(2, 0);
    ASSERT(!ret2); // 结果无效

    // 如果ret2为false，获取访问value将会 抛出异常
    try {
        ret2.value();
    } catch (std::exception e) {
        std::cout << e.what() << std::endl;
    }
}
#+END_SRC
如果开发项目中没有支持到c++17可以用boost库中的optional。
* std::string_view使用介绍
C++中与字符串有两种风格，分别是C风格的字符串、std::string字符串。C风格的字符串性能更高，但是也不方便操作使用。如下示例：
#+BEGIN_SRC c++
#include <iostream>
#include <string>
 
int main()
{
    //C风格字符串总是以null结尾
    char cstr1[] = { 'y', 'a', 'n', 'g', NULL};
    char cstr2[5];
    strcpy(cstr1, cstr2);
    std::cout << cstr2 << std::endl;
 
    //C++风格的字符串操作更方便，但是性能不如C风格字符串
    std::string str = "yang";
    std::string str2 = str;
}
#+END_SRC

C++17中我们可以使用std::string_view来获取一个字符串的视图，字符串视图并不真正的创建或者拷贝字符串，而只是拥有一个字符串的查看功能。std::string_view比std::string的性能要高很多，因为每个std::string都独自拥有一份字符串的拷贝，而std::string_view只是记录了自己对应的字符串的指针和偏移位置。当我们在只是查看字符串的函数中可以直接使用std::string_view来代替std::string。
#+BEGIN_SRC c++
#include <iostream>
#include <string>
#include <string_view>
 
int main()
{
 
    const char* cstr = "yangxunwu";
    std::string_view stringView1(cstr);
    std::string_view stringView2(cstr, 4);
    std::cout << "stringView1: " << stringView1 << ", stringView2: " << stringView2 << std::endl;
 
    std::string str = "yangxunwu";
    std::string_view stringView3(str.c_str());
    std::string_view stringView4(str.c_str(), 4);
    std::cout << "stringView3: " << stringView1 << ", stringView4: " << stringView2 << std::endl;
}
#+END_SRC
输出
* STL容器底层数据结构总结
** vector
vector是我们用到最多的数据结构，其底层数据结构是数组，由于数组的特点，vector也具有以下特性：
1、O(1)时间的快速访问；
2、顺序存储，所以插入到非尾结点位置所需时间复杂度为O(n)，删除也一样；
3、扩容规则：
当我们新建一个vector的时候，会首先分配给他一片连续的内存空间，如std::vector<int> vec，当通过push_back向其中增加元素时，如果初始分配空间已满，就会引起vector扩容，其扩容规则在gcc下以2倍方式完成：
首先重新申请一个2倍大的内存空间；
然后将原空间的内容拷贝过来；
最后将原空间内容进行释放，将内存交还给操作系统；

测试代码如下：
#+BEGIN_SRC c++
#include<iostream>
#include<vector>
using namespace std;

void mycapacity(const vector<int>& vec)
{
    cout << "分配总空间大小为：" << vec.capacity() << endl;
}

void mysize(const vector<int>& vec)
{
    cout << "已用空间大小为：" << vec.size() << endl;
}

void myprint(const vector<int>& vec)
{
    for (int i = 0; i < vec.size(); ++i)
        cout << vec[i] << ",";
    cout << endl;
}


int main()
{
    vector<int> vec;
    cout << "起始状态：" << endl;
    mycapacity(vec);
    mysize(vec);
    cout << "========================" << endl;

    for (int i = 0; i < 10; ++i) {
        vec.push_back(i);
        cout << "压入第" << i+1 << "个元素之后：" << endl;
        myprint(vec);
        mycapacity(vec);
        mysize(vec);
        cout << "========================" << endl;
    }

    return 0;
}
#+END_SRC

#+DOWNLOADED: file:E%3A/org/%E5%9B%BE%E7%89%87/Snipaste_2021-04-11_10-52-03.png @ 2021-04-11 10:54:14
[[file:STL%E5%AE%B9%E5%99%A8%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/2021-04-11_10-54-14_Snipaste_2021-04-11_10-52-03.png]]

从输出结果中的三个红色箭头可以看出vector的扩容规则。

4、注意事项：
根据vector的插入和删除特性，以及扩容规则，我们在使用vector的时候要注意，在插入位置和删除位置之后的所有迭代器和指针引用都会失效，同理，扩容之后的所有迭代器指针和引用也都会失效。
** map & multimap & unordered_map & unordered_multimap
*** map与multimap底层数据结构
map与multimap是STL中的关联容器、提供一对一key-value的数据处理能力； map与multimap的区别在于，multimap允许关键字重复，而map不允许重复。

这两个关联容器的底层数据结构均为红黑树,根据红黑树的原理，map与multimap可以实现O(lgn)的查找，插入和删除。
*** unordered_map 与unordered_multimap底层数据结构
unordered_map与unordered_multimap 对比map与multimap两种map在于map与multimap中的两个容器实现了以key为序排列，也就是说map与multimap为有序的。

而unordered_map与unordered_multimap中key为无序排列，其底层实现为hash table，因此其查找时间复杂度理论上达到了O(n)，之所以说理论上是因为在理想无碰撞的情况下，而真实情况未必如此。
** set & multiset & unordered_set & unordered_multiset
以上四种容器也都是关联容器，set系与map系的区别在于map中存储的是<key-value>，而set可以理解为关键字即值，即只保存关键字的容器。
*** set & multiset底层数据结构
set与multiset有序存储元素，这两种容器的底层实现与map一样都是红黑树，所以能实现O(lgn)的查找，插入，删除操作。

set与multiset的区别在于是否允许重复；
*** unordered_set & unordered_multiset
与unordered_map & unordered_multimap相同，其底层实现为hash table；
** priority_queue
priority_queue
优先级队列相当于一个有权值的单向队列queue，在这个队列中，所有元素是按照优先级排列的。

priority_queue根据堆的处理规则来调整元素之间的位置，根据堆的特性，优先级队列实现了取出最大最小元素时间复杂度为O(1),对于插入和删除，其最坏情况为O(lgn)。
** list
list的底层数据结构为双向链表，特点是支持快速的增删。
* STL容器迭代器失效情况分析、总结
[[https://ivanzz1001.github.io/records/post/cplusplus/2018/03/14/cpluscplus_stl_iterator#31-%25E4%25BD%25BF%25E7%2594%25A8%25E8%25BF%25AD%25E4%25BB%25A3%25E5%2599%25A8%25E9%2581%258D%25E5%258E%2586%25E4%25B8%258D%25E5%2590%258C%25E7%259A%2584%25E5%25AE%25B9%25E5%2599%25A8][参考文献]]
** 迭代器失效
当使用一个容器的insert或者erase函数通过迭代器插入或删除元素可能会导致迭代器失效，因此我们为了避免危险，应该获取insert或者erase返回的迭代器，以便用重新获取的新的有效的迭代器进行正确的操作：
#+BEGIN_SRC c++
iter = vec.insert(iter);

iter = vec.erase(iter);
#+END_SRC
迭代器失效类型：
- 由于插入元素，使得容器元素整体迁移导致存放原容器元素的空间不再有效，从而使得指向原空间的迭代器失效；
- 由于删除元素，使得某些元素次序发生变化导致原本指向某元素的迭代器不再指向期望指向的元素。

*** vector迭代器失效
- 当插入(push_back)一个元素后，end操作返回的迭代器肯定失效；
- 当插入(push_back)一个元素后，如果vector的capacity发生了改变，则需要重新加载整个容器，此时first和end操作返回的迭代器都会失效；
- 当进行删除操作(erase,pop_back)后，指向删除点的迭代器全部失效，指向删除点后面的元素的迭代器也将全部失效；

参看如下示例：
#+BEGIN_SRC c++
#include <iostream>
#include <vector>
using namespace std;


int main(int argc, char *argv[])
{
	vector<int> vec;
	
	vec.push_back(100);
	vec.push_back(300);
	vec.push_back(400);
	vec.push_back(500);
	
	vector<int>::iterator iter;
	
	for(iter = vec.begin(); iter != vec.end(); iter++)
	{
		if(*iter == 300){
			iter = vec.erase(iter);			//此时iter指向400
			cout<<"next iter: " << *iter << endl;
		}
	}
	
	for(iter = vec.begin(); iter != vec.end(); iter++)
		cout<<*iter << "  ";
	
	cout<<endl;	
	return 0x0;
}
#+END_SRC
编译运行：
#+BEGIN_EXAMPLE
# gcc -o vector_iterator vector_iterator.cpp -lstdc++
# ./vector_iterator 
next iter: 400
100  400  500 
#+END_EXAMPLE

*** list迭代器失效
- 插入操作(insert)和接合操作(splice)不会造成原有的list迭代器失效，这在vector中是不成立的，因为vector的插入操作可能造成记忆体重新配置，导致所有的迭代器全部失效；
- list的删除操作(erase)也只有指向被删元素的那个迭代器失效，其他迭代器不受影响。（list目前只发现这一种失效情况）
*** deque迭代器失效
- 在deque容器首部或者尾部插入元素，不会使得任何迭代器失效；
注： 通过vs2012测试，不管前端插入还是后端插入，都会使迭代器失效
- 在deque容器的首部或者尾部删除元素，只会使指向被删元素的迭代器失效；
- 在deque容器的任何其他位置进行插入或删除操作都将使指向该容器元素的所有迭代器失效；
*** set和map迭代器失效
与list相同，当对其进行insert或者erase操作时，操作之前的所有迭代器，在操作完成之后都依然有效，但被删除元素的迭代器失效。
** C++标准模板库(STL)迭代器的原理及实现
迭代器(iterator)是一种抽象的设计理念，通过迭代器可以在不了解容器内部原理的情况下遍历容器。除此之外，STL中迭代器一个最重要的作用就是作为容器(vector、list等)与STL算法的粘结剂，只要容器提供迭代器的接口，同一套算法代码可以利用在完全不同的容器中，这是抽象思想的经典应用。
*** 使用迭代器遍历不同的容器
如下所示的代码演示了迭代器是如何将容器和算法结合在一起的，其中使用了3种不同的容器，.begin()和.end()方法返回一个指向容器第一个元素和一个指向容器最后一个元素后面一个位置的迭代器，也就是说begin()和end()返回的迭代器是一个前闭后开的，一般用[begin, end) 表示。对于不同的容器，我们都使用同一个accumulate()函数，原因就在于acccumulate()函数的实现无需考虑容器的种类，只需要容器传入的begin()和end()迭代器能够完成标准迭代器的要求即可。
#+BEGIN_SRC c++
std::vector<int> vec{1,2,3};
std::list<int> lst{4,5,6};
std::deque<int> deq{7,8,9};

std::cout<<std::accumulate(vec.begin(), vec.end(), 0) << std::endl;
std::cout<<std::accumulate(lst.begin(), lst.end(), 0) << std::endl;
std::cout<<std::accumulate(deq.begin(), deq.end(), 0) << std::endl;
#+END_SRC
*** 迭代器的实现
迭代器的作用就是提供一个遍历容器内部所有元素的接口，因此迭代器的内部必须保存一个与容器相关联的指针，然后重载各种运算操作来方便遍历，其中最重要的就是* 运算符和-> 运算符，以及++、--等可能需要的运算符重载。实际上这和C++标准库的智能指针(smart pointer)很像，智能指针也是将一个指针封装，然后通过引用计数或是其他方法完成自动释放内存的功能，为了达到和原有指针一样的功能，也需要对*、->等运算符进行重载。下面参照智能指针实现一个简单vector迭代器，其中几个typedef暂时不用管，我们后面会提到。vecIter主要作用就是包裹一个指针，不同容器内部数据结构不相同，因此迭代器操作符重载的实现也会不同。比如++操作符。对于线性分配内存的数组来说，直接对指针执行++操作即可； 但是如果容器是List就需要采用元素内部的方法，比如ptr->next()之类的方法访问下一个元素。因此，STL容器都实现了自己的专属迭代器。

下面我们给出一个普通数组的迭代器的实现(array_iterator.cpp)：
#+BEGIN_SRC c++
#include <iostream>
#include <numeric>

template<class Item>
class vecIter{
	Item *ptr;
	
public:
	typedef std::forward_iterator_tag iterator_category;
	typedef Item value_type;
	typedef Item *pointer;
	typedef Item &reference;
	typedef std::ptrdiff_t difference_type;
	
public:
	vecIter(Item *p = 0):ptr(p){}
	
	Item & operator*() const{
		return *ptr;
	}
	
	Item * operator->() const{
		return ptr;
	}
	
	//pre
	vecIter &operator++(){
		++ptr;
		
		return *this;
	}
	
	vecIter operator++(int){
		vecIter tmp = *this;
		++*this;
		
		return tmp;
	}
	
	bool operator==(const vecIter &iter){
		return ptr == iter.ptr;
	}
	
	bool operator!=(const vecIter &iter){
		return !(*this == iter);
	}
};

int main(int argc, char *argv[])
{
	int a[] = {1,2,3,4};
	
	std::cout<<std::accumulate(vecIter<int>(a), vecIter<int>(a+4), 0)<<std::endl;
	
	return 0x0;
}
#+END_SRC
#+BEGIN_EXAMPLE
编译运行：

# gcc -o array_iterator array_iterator.cpp -lstdc++
# ./array_iterator 
10
#+END_EXAMPLE
*** 迭代器的相应型别
我们都知道type_traits可以萃取出类型的型别，根据不同的型别可以执行不同的处理流程。那么对于迭代器来说，是否有针对不同特性迭代器的优化方法呢？ 答案是肯定的。拿一个STL算法库中的distance()函数来说，distance函数接受两个迭代器参数，然后计算两者之间的距离。显然，对于不同的迭代器计算效率差别很大。比如对于vector容器来说，由于内存是连续分配的，因此指针直接相减即可获得两者的距离；而list容器是链表结构，内存一般都不是连续分配，因此只能通过一级一级调用next()或者其他函数，每调用一次再判断迭代器是否相等来计算距离。vector迭代器计算distance的效率为O(1)，而list则为O(n)，n为距离的大小。

因此，根据迭代器不同的特性，将迭代器分为5类：
- Input Iterator: 这种迭代器所指的对象为只读的
- Output Iterator: 所指的对象只能进行写入操作
- Forward Iterator: 该类迭代器可以在一个正确的区间中进行读写操作，它拥有Input Iterator的所有特性，和Output Iterator的部分特性，以及单步向前迭代元素的能力
- Bidirectional Iterator: 该类迭代器是在Forward Iterator的基础上提供了单步向后迭代元素的能力，从而使得可以双向移动
- Random Access Iterator： 前4种迭代器只提供部分指针算术能力（前3种支持++运算符，后一种还支持--运算符)，而本迭代器则支持所有指针的算术运算，包括p+n、p-n、p[n]、p1-p2、p1<p2

上述5种迭代器的继承关系如下图所示：
#+DOWNLOADED: file:E%3A/org/%E5%9B%BE%E7%89%87/Snipaste_2021-04-11_14-30-22.png @ 2021-04-11 14:30:26
[[file:STL%E5%AE%B9%E5%99%A8%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%A4%B1%E6%95%88%E6%83%85%E5%86%B5%E5%88%86%E6%9E%90%E3%80%81%E6%80%BB%E7%BB%93/2021-04-11_14-30-26_Snipaste_2021-04-11_14-30-22.png]]
了解了迭代器的类型，我们就能解释vector的迭代器和list迭代器的区别了。显然，vector迭代器具有所有指针算术运算能力，而list由于是双向链表，因此只有双向读写不能随机访问元素。故vector的迭代器种类为Random Access Iterator，而list的迭代器种类为Bidirectional Iterator。我们只需要根据不同的迭代器种类，利用traits编程技巧萃取出迭代器型别，然后由C++重载机制就能够对不同型别的迭代器采用不同的处理流程了。为此，对于每个迭代器都必须定义型别iterator_category，也就是上文代码中的typedef std:forward_iterator_tag iterator_category，实际上可以直接继承STL中定义的iterator模板，模板后三个参数都有默认值，因此继承时只需要指定前两个模板参数即可。如下所示，STL定义了5个空类型作为迭代器的标签：
#+BEGIN_SRC c++
template<class Category,class T,class Distance = ptrdiff_t,class Pointer=T*,class Reference=T&>
class iterator{
    typedef Category iterator_category;
    typedef T        value_type;
    typedef Distance difference_type;
    typedef Pointer  pointer;
    typedef Reference reference;
};

struct input_iterator_tag{};
struct output_iterator_tag{};
struct forward_iterator_tag:public input_iterator_tag{};
struct bidirectional_iterator_tag:public forward_iterator_tag{};
struct random_access_iterator_tag:public bidirectional_iterator_tag{};
#+END_SRC
*** 利用迭代器种类更有效的实现distance函数
回到distance函数，有了前面的基础，我们可以根据不同迭代器种类实现distance函数（distance.cpp)：
#+BEGIN_SRC c++
#include <iostream>
#include <vector>
#include <list>

# if 0
template <class _InputIterator, class _Distance>
inline void __distance(_InputIterator __first, _InputIterator __last,
                       _Distance& __n, std::input_iterator_tag)
{
  while (__first != __last) { ++__first; ++__n; }
}

template <class _RandomAccessIterator, class _Distance>
inline void __distance(_RandomAccessIterator __first, 
                       _RandomAccessIterator __last, 
                       _Distance& __n, std::random_access_iterator_tag)
{
  __n += __last - __first;
}

template <class _InputIterator, class _Distance>
inline void distance(_InputIterator __first, 
                     _InputIterator __last, _Distance& __n)
{
 typedef typename std::iterator_traits<_InputIterator>::iterator_category _Category;
  __distance(__first, __last, __n, _Category());
}
#else
//注： 这里需要放在一个新的namespace中，否则可能会与STL中的相冲突	
namespace DT{
template<class InputIterator>
inline typename std::iterator_traits<InputIterator>::difference_type distance(InputIterator first, InputIterator last){
	typedef typename std::iterator_traits<InputIterator>::iterator_category _Category;
	return __distance(first, last, _Category());
}
template<class InputIterator>
inline typename std::iterator_traits<InputIterator>::difference_type __distance(InputIterator first, InputIterator last, std::input_iterator_tag){
	typename std::iterator_traits<InputIterator>::difference_type n = 0;
	while (first != last){
		++first; ++n;
	}
	return n;
}

template<class InputIterator>
inline typename std::iterator_traits<InputIterator>::difference_type \
__distance(InputIterator first, InputIterator last, std::random_access_iterator_tag){
	return last - first;
}
}	
#endif


int main(int argc, char *argv[])
{

	int a[] = {1,2,3,4};
	std::vector<int> vec;
	vec.push_back(1);
	vec.push_back(2);
	vec.push_back(3);
	vec.push_back(4);
	
	std::list<int> lst;
	lst.push_back(1);
	lst.push_back(2);
	lst.push_back(3);
	lst.push_back(4);
	

	# if 0
		int vec_distance = 0, lst_distance = 0, carr_distance = 0;
		distance(vec.begin(), vec.end(), vec_distance);
		distance(lst.begin(), lst.end(), lst_distance);
		distance(a, a + sizeof(a)/sizeof(*a), carr_distance);
		
		std::cout<<"vec distance:"<<vec_distance<<std::endl;
		std::cout<<"lst distance:"<<lst_distance<<std::endl;
		std::cout<<"c-array distance:"<<carr_distance<<std::endl;
	#else
		std::cout<<"vec distance:"<<DT::distance(vec.begin(), vec.end())<<std::endl;
		std::cout<<"lst distance:"<<DT::distance(lst.begin(), lst.end())<<std::endl;
		std::cout<<"c-array distance:"<<DT::distance(a, a + sizeof(a)/sizeof(*a))<<std::endl;
	#endif
	
}
#+END_SRC
编译运行：
#+BEGIN_EXAMPLE
# gcc -o distance distance.cpp -lstdc++
# ./distance 
vec distance:4
lst distance:4
c-array distance:4
#+END_EXAMPLE
上面通过STL定义的iterator_traits模板可以萃取不同种类的迭代器特性，iterator_traits还对指针和常量指针有特化版本，因此也可以萃取原生指针的特性。具体实现如下：
#+BEGIN_SRC c++
template <class _Tp, class _Distance> struct input_iterator {
  typedef input_iterator_tag iterator_category;
  typedef _Tp                value_type;
  typedef _Distance          difference_type;
  typedef _Tp*               pointer;
  typedef _Tp&               reference;
};

struct output_iterator {
  typedef output_iterator_tag iterator_category;
  typedef void                value_type;
  typedef void                difference_type;
  typedef void                pointer;
  typedef void                reference;
};

template <class _Tp, class _Distance> struct forward_iterator {
  typedef forward_iterator_tag iterator_category;
  typedef _Tp                  value_type;
  typedef _Distance            difference_type;
  typedef _Tp*                 pointer;
  typedef _Tp&                 reference;
};


template <class _Tp, class _Distance> struct bidirectional_iterator {
  typedef bidirectional_iterator_tag iterator_category;
  typedef _Tp                        value_type;
  typedef _Distance                  difference_type;
  typedef _Tp*                       pointer;
  typedef _Tp&                       reference;
};

template <class _Tp, class _Distance> struct random_access_iterator {
  typedef random_access_iterator_tag iterator_category;
  typedef _Tp                        value_type;
  typedef _Distance                  difference_type;
  typedef _Tp*                       pointer;
  typedef _Tp&                       reference;
};

template <class _Iterator>
struct iterator_traits {
  typedef typename _Iterator::iterator_category iterator_category;
  typedef typename _Iterator::value_type        value_type;
  typedef typename _Iterator::difference_type   difference_type;
  typedef typename _Iterator::pointer           pointer;
  typedef typename _Iterator::reference         reference;
};

template <class _Tp>
struct iterator_traits<_Tp*> {
  typedef random_access_iterator_tag iterator_category;
  typedef _Tp                         value_type;
  typedef ptrdiff_t                   difference_type;
  typedef _Tp*                        pointer;
  typedef _Tp&                        reference;
};

template <class _Tp>
struct iterator_traits<const _Tp*> {
  typedef random_access_iterator_tag iterator_category;
  typedef _Tp                         value_type;
  typedef ptrdiff_t                   difference_type;
  typedef const _Tp*                  pointer;
  typedef const _Tp&                  reference;
};
#+END_SRC

*** 3.5 小结
STL使用迭代器算法和容器结合，利用迭代器型别可以针对不同迭代器编写更加高效的算法，这一点很重要的思想就是： 利用C++重载机制和参数推导机制将运行期决议问题提前到编译期决议，也就是说，我们不需要在运行时判断迭代器的类型，而是在编译期就已经决定。这很符合C++模板编程的理念。在后续STL学习中，我们会实现自己的各种容器，也必须实现各种各样的迭代器，因此迭代器的学习还远没有停止。
** C++中模板使用时候typename和class的区别
在C++ Template中很多地方都用到了typename与class这两个关键字，而且好像可以替换，是不是这两个关键字完全一样呢？ 相信学习C++的人对class这个关键字都非常明白，class用于定义类，在C++中引入模板后，最初定义模板的方法为：
#+BEGIN_EXAMPLE
template<class T>....
#+END_EXAMPLE
在这里class关键字表明T是一个类型，后来为了避免class在这两个地方的使用可能给人带来混淆，所以引入typename这个关键字，它的作用同class一样表明后面的符号为一个类型，这样在定义模板的时候就可以使用下面的方式了：
#+BEGIN_EXAMPLE
template<typename T>...
#+END_EXAMPLE
在模板定义语法中关键字class与typename的作用完全一样。

typename难道仅仅在模板定义中起作用吗？ 其实不是这样，typename另外一个作用为： 使用嵌套依赖类型(nested depended name), 如下所示
#+BEGIN_SRC c++
class MyArray{
public:
	typedef int LengthType;
	....
};

template<class T>
void MyMethod(T myarr){
	typedef typename T::LengthType LengthType;
	LengthType length = myarr.GetLength();
}
#+END_SRC
这个时候typename的作用就是告诉C++编译器，typename后面的字符串为一个类型名称，而不是成员函数或者成员变量。这个时候如果前面没有typename，编译器没有任何办法知道T::LengthType是一个类型还是一个成员名称(静态数据成员或者静态函数），所以编译不能够通过。
* 定义抽象数据类型
#+BEGIN_SRC c++
struct ListNode {
    int val;
    ListNode *next;
    ListNode() : val(0), next(nullptr) {}
    ListNode(int x) : val(x), next(nullptr) {}
    ListNode(int x, ListNode *next) : val(x), next(next) {}
};
#+END_SRC

如果调用 ~ListNode(5)~ 那么 ~val=5~ ， ~next~ 指针为空指针
* 内存泄露
new 和 delete 是 C++ 用于管理堆内存的两个运算符，对应于C语言中的 malloc 和 free，但是 malloc 和 free 是函数，而new 和 delete 是运算符。除此之外，new 在申请内存的同时，还会调用对象的构造函数，而 malloc 只会申请内存；同样，delete 在释放内存之前，会调用对象的析构函数，而 free 只会释放内存。

new运算符申请内存：将调用相应的 operator new(size_t) 函数动态分配内存，在分配到的动态内存块上 初始化 相应类型的对象（构造函数）并返回其首地址。如果调用构造函数初始化对象时抛出异常，则自动调用 operator delete(void*, void*) 函数释放已经分配到的内存。

delete运算符释放内存：调用相应类型的析构函数，处理类内部可能涉及的资源释放，调用相应的 operator delete(void *) 函数。
** 内存是如何泄露的
在 C++ 程序中，主要涉及到的内存就是“栈”和“堆”

#+DOWNLOADED: file:F%3A/org/%E5%9B%BE%E7%89%87/v2-f3189547daa4548bc4ab6fdd13eeea6d_720w.png @ 2020-06-13 19:16:48
[[file:%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2/2020-06-13_19-16-48_v2-f3189547daa4548bc4ab6fdd13eeea6d_720w.png]]

通常来说，一个线程的栈内存是有限的，通常来说是 8M 左右（取决于运行的环境）。栈上的内存通常是由编译器来自动管理的。当在栈上分配一个新的变量时，或进入一个函数时，栈的指针会下移，相当于在栈上分配了一块内存。我们把一个变量分配在栈上，也就是利用了栈上的内存空间。当这个变量的生命周期结束时，栈的指针会上移，相同于回收了内存。

由于栈上的内存的分配和回收都是由编译器控制的，所以在栈上是不会发生内存泄露的，只会发生栈溢出（Stack Overflow），也就是分配的空间超过了规定的栈大小。

而堆上的内存是由程序直接控制的，程序可以通过 malloc/free 或 new/delete 来分配和回收内存，如果程序中通过 malloc/new 分配了一块内存，但忘记使用 free/delete 来回收内存，就发生了内存泄露。

*** 经验 #1：尽量避免在堆上分配内存
既然只有堆上会发生内存泄露，那第一原则肯定是避免在堆上面进行内存分配，尽可能的使用栈上的内存，由编译器进行分配和回收，这样当然就不会有内存泄露了。

然而，只在栈上分配内存，在有 IO 的情况下是存在一定局限性的。

举个例子，为了完成一个请求，我们通常会为这个请求构造一个 Context 对象，用于描述和这个请求有关的一些上下文。例如下面一段代码：
#+BEGIN_SRC c++
void Foo(Reuqest* req) {
    RequestContext ctx(req);
    HandleRequest(&ctx);
}
#+END_SRC
如果 HandleRequest 是一个同步函数，当这个函数返回时，请求就可以被处理完成，那么显然 ctx 是可以被分配在栈上的。

但如果 HandleRequest 是一个异步函数，例如：
#+BEGIN_SRC c++
void HandleRequest(RequestContext* ctx, Callback cb);
#+END_SRC
那么显然，ctx 是不能被分配在栈上的，因为如果 ctx 被分配在栈上，那么当 Foo 函数推出后，ctx 对象的生命周期也就结束了。而 FooCB 中显然会使用到 ctx 对象。
#+BEGIN_SRC c++
void HandleRequest(RequestContext* ctx, Callback cb);

void Foo(Reuqest* req) {
    auto ctx = new RequestContext(req);
    HandleRequest(ctx, FooCB);
}

void FooCB(RequestContext* ctx) {
    FinishRequest(ctx);
    delete ctx;
}
#+END_SRC
在这种情况下，如果忘记在 FooCB 中调用 delete ctx，则就会触发内存泄露。尽管我们可以借助一些静态检查工具对代码进行检查，但往往异步程序的逻辑是极其复杂的，一个请求的生命周期中，也需要进行大量的内存分配操作，静态检查工具往往无法发现所有的内存泄露情况。

那么怎么才能避免这种情况的产生呢？引入智能指针显然是一种可行的方法，但引入 shared_ptr 往往引入了额外的性能开销，并不十分理想。

在 SmartX，我们通常采用两种方法来应对这种情况。

*** 经验 #2：使用 Arena
Arena 是一种统一化管理内存生命周期的方法。所有需要在堆上分配的内存，不通过 malloc/new，而是通过 Arena 的 CreateObject 接口。同时，不需要手动的执行 free/delete，而是在 Arena 被销毁的时候，统一释放所有通过 Arena 对象申请的内存。所以，只需要确保 Arena 对象一定被销毁就可以了，而不用再关心其他对象是否有漏掉的 free/delete。这样显然降低了内存管理的复杂度。

此外，我们还可以将 Arena 的生命周期与 Request 的生命周期绑定，一个 Request 生命周期内的所有内存分配都通过 Arena 完成。这样的好处是，我们可以在构造 Arena 的时候，大概预估出处理完成这个 Request 会消耗多少内存，并提前将会使用到的内存一次性的申请完成，从而减少了在处理一个请求的过程中，分配和回收内存的次数，从而优化了性能。

我们最早看到 Arena 的思想，是在 LevelDB 的代码中。这段代码相当简单，建议大家直接阅读。

*** 经验 #3：使用 Coroutine
Coroutine 相信大家并不陌生，那 Coroutine 的本质是什么？我认为 Coroutine 的本质，是使得一个线程中可以存在多个上下文，并可以由用户控制在多个上下文之间进行切换。而在上下文中，一个重要的组成部分，就是栈指针。使用 Coroutine，意味着我们在一个线程中，可以创造（或模拟）多个栈。

有了多个栈，意味着当我们要做一个异步处理时，不需要释放当前栈上的内存，而只需要切换到另一个栈上，就可以继续做其他的事情了，当异步处理完成时，可以再切换回到这个栈上，将这个请求处理完成。

还是以刚才的代码为示例:
#+BEGIN_SRC c++
void Foo(Reuqest* req) {
    RequestContext ctx(req);
    HandleRequest(&ctx);
}

void HandleRequest(RequestCtx* ctx) {
    SubmitAsync(ctx);
    Coroutine::Self()->Yield();
    CompleteRequest(ctx);
}
#+END_SRC
这里的精髓在于，尽管 Coroutine::Self()->Yield() 被调用时，程序可以跳出 HandleRequest 函数去执行其他代码逻辑，但当前的栈却被保存了下来，所以 ctx 对象是安全的，并没有被释放。

这样一来，我们就可以完全抛弃在堆上申请内存，只是用栈上的内存，就可以完成请求的处理，完全不用考虑内存泄露的问题。然而这种假设过于理想，由于在栈上申请内存存在一定的限制，例如栈大小的限制，以及需要在编译是知道分配内存的大小，所以在实际场景中，我们通常会结合使用 Arena 和 Coroutine 两种技术一起使用。

有人可能会提到，想要多个栈用多个线程不就可以了？然而用多线程实现多个栈的问题在于，线程的创建和销毁的开销极大，且线程间切块，也就是在栈之间进行切换的代销需要经过操作系统，这个开销也是极大的。所以想用线程模拟多个栈的想法在实际场景中是走不通的。

关于 Coroutine 有很多开源的实现方式，大家可以在 github 上找到很多，C++20 标准也会包含 Coroutine 的支持。在 SmartX 内部，我们很早就实现了 Coroutine，并对所有异步 IO 操作进行了封装，示例可参考我们之前的一篇文章 smartx：基于 Coroutine 的异步 RPC 框架示例（C++）

这里需要强调一下，Coroutine 确实会带来一定的性能开销，通常 Coroutine 切换的开销在 20ns 以内，然而我们依然在对性能要求很苛刻的场景使用 Coroutine，一方面是因为 20ns 的性能开销是相对很小的，另一方面是因为 Coroutine 极大的降低了异步编程的复杂度，降低了内存泄露的可能性，使得编写异步程序像编写同步程序一样简单，降低了程序员心智的开销。

*** 经验 #4：善用 RAII
尽管在有些场景使用了 Coroutine，但还是可能会有在堆上申请内存的需要，而此时有可能 Arena 也并不适用。在这种情况下，善用 RAII（Resource Acquisition Is Initialization）思想会帮助我们解决很多问题。

简单来说，RAII 可以帮助我们将管理堆上的内存，简化为管理栈上的内存，从而达到利用编译器自动解决内存回收问题的效果。此外，RAII 可以简化的还不仅仅是内存管理，还可以简化对资源的管理，例如 fd，锁，引用计数等等。

当我们需要在堆上分配内存时，我们可以同时在栈上面分配一个对象，让栈上面的对象对堆上面的对象进行封装，用时通过在栈对象的析构函数中释放堆内存的方式，将栈对象的生命周期和堆内存进行绑定。

unique_ptr 就是一种很典型的例子。然而 unique_ptr 管理的对象类型只能是指针，对于其他的资源，例如 fd，我们可以通过将 fd 封装成另外一个 FileHandle 对象的方式管理，也可以采用一些更通用的方式。例如，在我们内部的 C++ 基础库中实现了 Defer 类，想法类似于 Go 中 defer。
#+BEGIN_SRC c++
void Foo() {
    int fd = open();
    Defer d = [=]() { close(fd); }
    // do something with fd
}
#+END_SRC

*** 经验 #5：便于 Debug
在特定的情况下，我们难免还是要手动管理堆上的内存。然而当我们面临一个正在发生内存泄露线上程序时，我们应该怎么处理呢？

当然不是简单的『重启大法好』，毕竟重启后还是可能会产生泄露，而且最宝贵的现场也被破坏了。最佳的方式，还是利用现场进行 Debug，这就要求程序具有便于 Debug 的能力。

这里不得不提到一个经典而强大的工具 gperftools。gperftools 是 google 开源的一个工具集，包含了 tcmalloc，heap profiler，heap checker，cpu profiler 等等。gperftools 的作者之一，就是大名鼎鼎的 Sanjay Ghemawat，没错，就是与 Jeff Dean 齐名，并和他一起写 MapReduce 的那个 Sanjay。

gperftools 的一些经典用法，我们就不在这里进行介绍了，大家可以自行查看文档。而使用 gperftools 可以在不重启程序的情况下，进行内存泄露检查，这个恐怕是很少有人了解。

实际上我们 Release 版本的 C++ 程序可执行文件在编译时全部都链接了 gperftools。在 gperftools 的 heap profiler 中，提供了 HeapProfilerStart 和 HeapProfilerStop 的接口，使得我们可以在运行时启动和停止 heap profiler。同时，我们每个程序都暴露了 RPC 接口，用于接收控制命令和调试命令。在调试命令中，我们就增加了调用 HeapProfilerStart 和 HeapProfilerStop 的命令。由于链接了 tcmalloc，所以 tcmalloc 可以获取所有内存分配和回收的信息。当 heap profiler 启动后，就会定期的将程序内存分配和回收的行为 dump 到一个临时文件中。

当程序运行一段时间后，你将得到一组 heap profile 文件
#+BEGIN_SRC bash
  profile.0001.heap
  profile.0002.heap
  ...
  profile.0100.heap
#+END_SRC
每个 profile 文件中都包含了一段时间内，程序中内存分配和回收的记录。如果想要找到内存泄露的线索，可以通过使用
#+BEGIN_SRC bash
pprof --base=profile.0001.heap /usr/bin/xxx profile.0100.heap --text
#+END_SRC
来进行查看，也可以生成 pdf 文件，会更直观一些。
#+DOWNLOADED: file:F%3A/org/%E5%9B%BE%E7%89%87/v2-a8eedcc8f07691a31707f5f8921acfa8_720w.png @ 2020-06-13 19:27:10
[[file:%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2/2020-06-13_19-27-10_v2-a8eedcc8f07691a31707f5f8921acfa8_720w.png]]
* 二重指针
char**是二重指针，bai也就是指向指针变量的指针。 而char*是一维指针，即指向zhi字符变量的指针。

其区别在于，指向地址dao所存储的值不同。

对于char **p1, *p1的类型为char*型，而**p1的类型才是char型。

对于char*类指针p2，*p2就是char 型。
* 字符串
** 字符串数组
#+BEGIN_SRC c++
char a[] = "hello";   //字符串数组，存放的是字符,a表示字符h的地址
#+END_SRC
*** 初始化
#+BEGIN_SRC c++
char a[10] ="hello";//字符串以'\0'结尾，这种方式系统会自动在数组未填值的地方添加'\0'
char b[] = {'h', 'e' , 'l', 'l', '\0'};//类似于初始化整型数组，必须要手动在后面添加'\0'
#+END_SRC
** 字符串指针数组
#+BEGIN_SRC c++
char *b[] = {"hello", "world"};//字符串指针数组，数组b总共有两个4字节的元素,第一个元素存储字符串"hello"的地址,即指向字符h的指针,第二个元素存储字符串"world"的地址,即指向字符w的指针.
#+END_SRC
* 谓词
A predicate is an expression that can be called and that returns a value that can be used as a condition. The predicates used by library algorithms are either unary predicates (meaning they have a single parameter) or binary predicates (meaning they have two parameters).

The version of sort that takes a binary predicate uses the given predicate in place of < to compare elements.

#+BEGIN_SRC c++
// comparison function to be used to sort by word length
bool isShorter(const string &s1, const string &s2)
C++ Primer, Fifth Edition
{
return s1.size() < s2.size();
}
// sort on word length, shortest to longest
sort(words.begin(), words.end(), isShorter);
#+END_SRC
