* auto
** 静态类型，动态类型和类型推导
在编程语言分类中，C/C++C 常常被认为是静态类型的语言。而有的编程语言则号称是“动态类型”的，比如 python。通常情况下，“静”和“动”的区别是非常直观的。我们看看下面这段简单的 python 代码：   
#+BEGIN_SRC python 
name=‘world\n’
print 'hello, ' %name
#+END_SRC
这段代码中 python 中的一个 hellowworld 的实现。这就是编程语言中的“动态类型”,在运行时来进行类型检查，而 C++中类型检查是在编译阶段。动态类型语言能做到在运行时决定类型，主要归功于一技术，这技术是类型推导。

事实上，类型推导也可以用于静态类型语言中。比如上面的 python 代码中，如果按照 C/C++程序员的思考方式，world\n 表达式应该可以返回一个临时的字符串，所以即使 name 没有进行声明，我们也能轻松低推导出 name 的类型应该是一个字符串类型。在 C++11 中，这个想法得到了实现。C++11 中类型推导的实现之一就是重定义 auto 关键字，另一个实现是 decltype。

我们可以使用 C++11 方式来书写刚才的 python 的代码
#+BEGIN_SRC c++
#include <iostream>
using namespace std;
int main()
{
  auto name=‘world\n’
  cout<<"hello   "<<name<<endl;
 
}
#+END_SRC

这里使用 auto 关键字来要求编译器对变量 name 的类型进行了自动推导。这里编译器根据它的初始化表达式的类型，推导出 name 的类型为 char*。事实上，atuo 关键字在早期的 C/C++标准中有着完全不同的含义。声明时使用 auto 修饰的变量，按照早期 C/C++标准的解释，是具有自动存储期的局部变量。不过那时情况是该关键字几乎无人使用，因为一般函数内没有声明为 static 的变量总是具有自动存储期的局部变量。auto 声明变量的类型必须又编译器在编译时期推导而得。

通过以下例子来了解以下 auto 类型推导的基本用法
#+BEGIN_SRC c++
#include <iostream>
using namespace std;
int main()
{
     double foo();
	 auto x=1;
	 auto y=foo();
	 struct m
	 {
	     int i;
	 }str;
	 auto str1=str;
	 auto z;
	 z=x;
}
#+END_SRC
以上变量 x 被初始化为 1，因为字面变量 1 的类型是 const int，所以编译器推导出 x 的类型应该为 int（这里 const 类型限制符被去掉了，后面会解释）。同理在变量 y 的定义中，auto 类型的 y 被推导为 double 类型；而在 auto str1 的定义中，其类型被推导为 struct m。这里的 z，使用 auto 关键字来声明，但是不立即对其进行定义，此时编译器则会报错。这跟通过其他关键字（除去引用类型的关键字）先声明后定义的变量的使用规则是不同的。auto 声明的变量必须被初始化，以使编译器能够从其初始化表达式中推导出其类型。这个意义上，auto 并非一种类型声明，而是一个类型声明时的“占位符”，编译器在便已是亲会将 suto 替代为变量实际的类型。
** auto 的优势
*** 简化代码
1.直观地，auto 推导的一个最大的优势在于拥有初始化表达式的复杂类型变量声明时简化代码。由于 C++的发展，变量类型变得越来越复杂。但是很多时候，名字空间、模板成为类型的一部分，导致了程序员在使用库的时候如履薄冰。
#+BEGIN_SRC c++
#include <string>
#include <vector>
void loopover(std::vector<std::string>&vs)
{
    std::vector<std::string>::iterator i=vs.begin();
	for(;i<vs.end();i++)
	{
	
	}
 
}
#+END_SRC
#+BEGIN_SRC c++
<pre name="code" class="cpp">#include <string>
#include <vector>
void loopover(std::vector<std::string>&vs)
{
	for(  auto i=vs.begin();;i<vs.end();i++)
	{
	
	}
 
}
#+END_SRC
使用 std::vector<std::string>::iterator 来定义 i 是 C++常用的良好的习惯，但是这样长的声明带来了代码可读性的困难，因此引入 auto，使代码可读性增加。并且使用 STL 将会变得更加容易
*** 避免声明类型错误
可以避免类型声明时的麻烦而且避免类型声明时的错误。事实上，在 C/C++中，存在着很多隐式或者是用户自定义类型的转换规则（比如整型与字符型进行加法运算后，表达式返回整型，这是一条隐式规则）。这些规则并非容易记忆，尤其是在用户自定义很多操作符以后，这个时候 auto 就有用户之地了。看一下例子
#+BEGIN_SRC c++
class PI
{
   public :
          double operator*(float v)
		  {
		     return (double)val*v;
		  }
          const float val=3.1415927f;
}

int main()
{
          float radius=1.7e10;
	  PI pi;
	  auto circumference =2*(pi*radius);
}
#+END_SRC
上面定义了一个 float 类型的变量 radius（半径）以及一个自定义类型 PI 的变量 pi,在计算周长的时候，使用 auto 类型来定义变量 circumference。这里 PI 在于 float 类型数据相乘时，其返回值为 double。而 PI 得定义可能是在其他的地方（头文件里），main 函数的程序可能就不知道 PI 的作者为了避免数据上溢或者是精度上的降低而返回了 double 类型的浮点数。因此 main 函数程序员如果使用 float 类型声明 circumference，就可能会享受不了 PI 作者细心设计带来的好处。反之，将 circumference 声明为 auto，则毫无问题，因为编译器已经做了最好的选择。

但是 auto 不能解决所有的精度问题。下面例子
#+BEGIN_SRC c++
#include <iostream>
using namespace std;
int main()
{
   unsigned int a=4294967295;//最大的unsigned int值
   unsigned int b=1；
   auto c=a+b;
   cout<<"a="<<a<<endl;
   cout<<"b="<<b<<endl;
   cout<<"c="<<c<<endl;
}
#+END_SRC
上面代码中，程序员希望通过声明变量 c 为 auto 就能解决 a+b 溢出的问题。而实际上由于 a+b 返回的依然是 unsigned int 的值，姑且 c 的类型依然被推导为 unsigned int，auto 并不能帮上忙。这个跟动态类型语言中数据自动进行拓展的特性还是不一样的。
*** 支持泛型编程
在 C++中其“自适应”性能够在一定程度上支持泛型的编程。

 回到上面 class PI 的例子，这里假设 PI 的作者改动了 PI 的定义，比如讲 operator*返回值变为 long  double，此时，main 函数并不需要修改，因为 auto 会“自适应”新的类型。同理，对于不同平台上的二代马维护，auto 也会带来一些“泛型”的好处。这里我们一 strlen 函数为例，在 32 位编译环境下，strlen 返回的为一个 4 字节的整型，在 64 位的编译环境下，strlen 会返回一个 8 字节的整型。即使系统库中<cstring>为其提供了 size_t 类型来支持多平台间的代码共享支持，但是使用 auto 关键字我们同样可以达到代码跨平台的效果。

~auto var=strlen("hello world")~

由于 size_t 的适用性范围往往局限于<cstring>中定义的函数，auto 的适用范围明显更为广泛。

当 auto 应用于模板的定义中，其"自适应"性会得到更加充分的体现。我们可以看看以下例子
#+BEGIN_SRC c++
template<typename T1,typename T2>
double Sum(T1&t1,T2&t2)
{
        auto a=t1+t2;
	return a;
}
int main()
{
        int a=3;
	long b=5;
	float c=1.0f;
	float d=2.3f;
	auto e=Sum<int,long>(a,b); //e的类型被推导为long
	auto f=Sum<float,float>(c,d);//s的类型被推导为float
}
#+END_SRC
上面中 Sum 模板函数接受两个参数。由于 T1，T2 要在模板实例化时才能确定，所以 Sum 中将变量 s 的类型声明为 auto 的。在函数 main 中我们将模板实例化时。Sum<int,long>中的 s 变量会被推导为 long 类型，而 Sum<float,float>中的 s 变量则会被推导为 float。可以看到，auto 与模板一起使用时，其“自适应”特性能够加强 C++中泛型的能力。
** auto 的使用注意细节
1. 我们可以使用 valatile，pointer（*），reference（&），rvalue reference（&&） 来修饰 auto
#+BEGIN_SRC c++
auto k = 5;
auto* pK = new auto(k);
auto** ppK = new auto(&k);
const auto n = 6;
#+END_SRC
2. 用 auto 声明的变量必须初始化

~auto m; // m should be intialized~

3. auto 不能与其他类型组合连用

~auto int p; // 这是旧auto的做法~

4. 函数和模板参数不能被声明为 auto
#+BEGIN_SRC c++
void MyFunction(auto parameter){} // no auto as method argument
template<auto T> // utter nonsense - not allowed
void Fun(T t){}
#+END_SRC
5. 定义在堆上的变量，使用了 auto 的表达式必须被初始化
#+BEGIN_SRC c++
int* p = new auto(0); //fine
int* pp = new auto(); // should be initialized
auto x = new auto(); // Hmmm ... no intializer
auto* y = new auto(9); // Fine. Here y is a int*
auto z = new auto(9); //Fine. Here z is a int* (It is not just an int)
#+END_SRC
6. 以为 auto 是一个占位符，并不是一个他自己的类型，因此不能用于类型转换或其他一些操作，如 sizeof 和 typeid
#+BEGIN_SRC c++
int value = 123;
auto x2 = (auto)value; // no casting using auto
auto x3 = static_cast<auto>(value); // same as above 
#+END_SRC
7. 定义在一个 auto 序列的变量必须始终推导成同一类型
#+BEGIN_SRC c++
auto x1 = 5, x2 = 5.0, x3='r';  // This is too much....we cannot combine like this
#+END_SRC
8. auto 不能自动推导成 CV-qualifiers（constant & volatile qualifiers），除非被声明为引用类型
#+BEGIN_SRC c++ 
const int i = 99;
auto j = i;       // j is int, rather than const int
j = 100           // Fine. As j is not constant
// Now let us try to have reference
auto& k = i;      // Now k is const int&
k = 100;          // Error. k is constant
// Similarly with volatile qualifer
#+END_SRC
9. auto 会退化成指向数组的指针，除非被声明为引用
#+BEGIN_SRC c++
int a[9];
auto j = a;
cout<<typeid(j).name()<<endl; // This will print int*
auto& k = a;
cout<<typeid(k).name()<<endl; // This will print int [9]
#+END_SRC
符号 & 表明是一个引用变量，能让接下来的代码能够修改数组的内容，而第一种语法不能。
** 遍历
*** 遍历 unordered_map
#+begin_src c++
unordered_map<char, int> mp;
for (auto& x : mp) {
    buckets[x.second].push_back(x.first);
}
#+END_SRC

* boolalpha
Sets the boolalpha format flag for the str stream.

When the boolalpha format flag is set, bool values are inserted/extracted by their textual representation: either true or false, instead of integral values.

example:
#+BEGIN_SRC c++
// modify boolalpha flag
#include <iostream>     // std::cout, std::boolalpha, std::noboolalpha

int main () {
  bool b = true;
  std::cout << std::boolalpha << b << '\n';
  std::cout << std::noboolalpha << b << '\n';
  return 0;
}
#+END_SRC
#+BEGIN_EXAMPLE
Output:
true
1
#+END_EXAMPLE
* C++四种类型转换运算符
隐式类型转换是安全的，显式类型转换是有风险的，C语言之所以增加强制类型转换的语法，就是为了强调风险，让程序员意识到自己在做什么。

但是，这种强调风险的方式还是比较粗放，粒度比较大，它并没有表明存在什么风险，风险程度如何。再者，C风格的强制类型转换统一使用( )，而( )在代码中随处可见，所以也不利于使用文本检索工具（例如 Windows 下的 Ctrl+F、Linux 下的 grep 命令、Mac 下的 Command+F）定位关键代码。

为了使潜在风险更加细化，使问题追溯更加方便，使书写格式更加规范，C++ 对类型转换进行了分类，并新增了四个关键字来予以支持，它们分别是：
| 关键字           | 说明                                                                                                                          |
|------------------+-------------------------------------------------------------------------------------------------------------------------------|
| static_cast      | 用于良性转换，一般不会导致意外发生，风险很低。                                                                                |
| const_cast       | 用于 const 与非 const、volatile 与非 volatile 之间的转换。                                                                    |
| reinterpret_cast | 高度危险的转换，这种转换仅仅是对二进制位的重新解释，不会借助已有的转换规则对数据进行调整，但是可以实现最灵活的 C++ 类型转换。 |
| dynamic_cast     | 借助 RTTI，用于类型安全的向下转型（Downcasting）。                                                                            |
这四个关键字的语法格式都是一样的，具体为：
#+BEGIN_SRC c++
xxx_cast<newType>(data)
#+END_SRC
newType 是要转换成的新类型，data 是被转换的数据。例如，老式的 C 风格的 double 转 int 的写法为：
#+BEGIN_SRC c
double scores = 95.5;
int n = (int)scores;
#+END_SRC
C++ 新风格的写法为：
#+BEGIN_SRC c++
double scores = 95.5;
int n = static_cast<int>(scores);
#+END_SRC

** static_cast
static_cast 只能用于良性转换，这样的转换风险较低，一般不会发生什么意外，例如：
原有的自动类型转换，例如 short 转 int、int 转 double、const 转非 const、向上转型等；
void 指针和具体类型指针之间的转换，例如 ~void *~ 转 ~int *~ 、 ~char *~ 转 ~void *~ 等；
有转换构造函数或者类型转换函数的类与其它类型之间的转换，例如 double 转 Complex（调用转换构造函数）、Complex 转 double（调用类型转换函数）。

需要注意的是，static_cast 不能用于无关类型之间的转换，因为这些转换都是有风险的，例如：
两个具体类型指针之间的转换，例如 int *转 double *、Student *转 int *等。不同类型的数据存储格式不一样，长度也不一样，用 A 类型的指针指向 B 类型的数据后，会按照 A 类型的方式来处理数据：如果是读取操作，可能会得到一堆没有意义的值；如果是写入操作，可能会使 B 类型的数据遭到破坏，当再次以 B 类型的方式读取数据时会得到一堆没有意义的值。
int 和指针之间的转换。将一个具体的地址赋值给指针变量是非常危险的，因为该地址上的内存可能没有分配，也可能没有读写权限，恰好是可用内存反而是小概率事件。

static_cast 也不能用来去掉表达式的 const 修饰和 volatile 修饰。换句话说，不能将 const/volatile 类型转换为非 const/volatile 类型。

static_cast 是“静态转换”的意思，也就是在编译期间转换，转换失败的话会抛出一个编译错误。

下面的代码演示了 static_cast 的正确用法和错误用法：
#+BEGIN_SRC c++
#include <iostream>
#include <cstdlib>
using namespace std;

class Complex{
public:
    Complex(double real = 0.0, double imag = 0.0): m_real(real), m_imag(imag){ }
public:
    operator double() const { return m_real; }  //类型转换函数
private:
    double m_real;
    double m_imag;
};

int main(){
    //下面是正确的用法
    int m = 100;
    Complex c(12.5, 23.8);
    long n = static_cast<long>(m);  //宽转换，没有信息丢失
    char ch = static_cast<char>(m);  //窄转换，可能会丢失信息
    int *p1 = static_cast<int*>( malloc(10 * sizeof(int)) );  //将void指针转换为具体类型指针
    void *p2 = static_cast<void*>(p1);  //将具体类型指针，转换为void指针
    double real= static_cast<double>(c);  //调用类型转换函数
   
    //下面的用法是错误的
    float *p3 = static_cast<float*>(p1);  //不能在两个具体类型的指针之间进行转换
    p3 = static_cast<float*>(0X2DF9);  //不能将整数转换为指针类型

    return 0;
}
#+END_SRC

** const_cast 
const_cast 比较好理解，它用来去掉表达式的 const 修饰或 volatile 修饰。换句话说，const_cast 就是用来将 const/volatile 类型转换为非 const/volatile 类型。

下面我们以 const 为例来说明 const_cast 的用法：
#+BEGIN_SRC c++
#include <iostream>
using namespace std;

int main(){
    const int n = 100;
    int *p = const_cast<int*>(&n);
    *p = 234;
    cout<<"n = "<<n<<endl;
    cout<<"*p = "<<*p<<endl;

    return 0;
}
#+END_SRC
运行结果：
n = 100
*p = 234

~&n~ 用来获取 n 的地址，它的类型为 ~const int *~ ，必须使用 const_cast 转换为 ~int *~ 类型后才能赋值给 p。由于 p 指向了 n，并且 n 占用的是栈内存，有写入权限，所以可以通过 p 修改 n 的值。

有读者可能会问，为什么通过 n 和 *p 输出的值不一样呢？这是因为 C++ 对常量的处理更像是编译时期的 ~#define~ ，是一个值替换的过程，代码中所有使用 n 的地方在编译期间就被替换成了 100。换句话说，第 8 行代码被修改成了下面的形式：
#+BEGIN_SRC c++
cout<<"n = "<<100<<endl;
#+END_SRC
这样一来，即使程序在运行期间修改 n 的值，也不会影响 cout 语句了。

使用 const_cast 进行强制类型转换可以突破 C/C++ 的常数限制，修改常数的值，因此有一定的危险性；但是程序员如果这样做的话，基本上会意识到这个问题，因此也还有一定的安全性。

** reinterpret_cast
reinterpret 是“重新解释”的意思，顾名思义，reinterpret_cast 这种转换仅仅是对二进制位的重新解释，不会借助已有的转换规则对数据进行调整，非常简单粗暴，所以风险很高。

reinterpret_cast 可以认为是 static_cast 的一种补充，一些 static_cast 不能完成的转换，就可以用 reinterpret_cast 来完成，例如两个具体类型指针之间的转换、int 和指针之间的转换（有些编译器只允许 int 转指针，不允许反过来）。

下面的代码代码演示了 reinterpret_cast 的使用：
#+BEGIN_SRC c++
#include <iostream>
using namespace std;

class A{
public:
    A(int a = 0, int b = 0): m_a(a), m_b(b){}
private:
    int m_a;
    int m_b;
};

int main(){
    //将 char* 转换为 float*
    char str[]="http://c.biancheng.net";
    float *p1 = reinterpret_cast<float*>(str);
    cout<<*p1<<endl;
    //将 int 转换为 int*
    int *p = reinterpret_cast<int*>(100);
    //将 A* 转换为 int*
    p = reinterpret_cast<int*>(new A(25, 96));
    cout<<*p<<endl;
   
    return 0;
}
#+END_SRC
运行结果：
3.0262e+29
25

可以想象，用一个 float 指针来操作一个 char 数组是一件多么荒诞和危险的事情，这样的转换方式不到万不得已的时候不要使用。将 ~A*~ 转换为 ~int*~ ，使用指针直接访问 private 成员刺穿了一个类的封装性，更好的办法是让类提供 get/set 函数，间接地访问成员变量。

** dynamic_cast
这部分内容我省略没写。
* C++ STL vector 添加元素（push_back()和 emplace_back()）详解
emplace_back() 和 push_back() 的区别，就在于底层实现的机制不同。push_back() 向容器尾部添加元素时，首先会创建这个元素，然后再将这个元素拷贝或者移动到容器中（如果是拷贝的话，事后会自行销毁先前创建的这个元素）；而 emplace_back() 在实现时，则是直接在容器尾部创建这个元素，省去了拷贝或移动元素的过程。
* 重载
重载指的是同一作用域内的几个函数名字相同但形参（形参数量或者形参类型）不同。
** 返回值不影响判断
返回值的不同不能用于区分重载函数。不允许同时存在除了返回类型外其他所有要素都相同的两个函数。
** 参数默认值不影响判断
下面两个函数是互相覆盖的关系
#+begin_src c++
  int myfunc(int a,double b);

  int myfunc(int a,double b=0.5);
#+END_SRC
** 形参名字不影响判断
#+begin_src c++
Record lookup (const Account &acct);
Record lookup (const Account&);

typedef Phone Telno;
Record lookup(const Phone&);
Record lookup(const Telno&);
#+end_src

** const 形参的判断方式
*** 顶层 const 不影响判断
#+begin_src c++
  Record lookup(const Phone);
  Record lookup(Phone);//重复声明

  Record lookup(Phone*);
  Record lookup(Phone* const);//重复声明
#+END_SRC
*** 底层 const 影响判断
#+begin_src c++
  Record lookup(Account&);//函数作用于Account的引用
  Record lookup(const Account&);//新函数,作用于常量引用

  Record lookup(Account*);//新函数,作用于指向Account的指针
  Record lookup(const Account*);//新函数,作用于指向常量的指针
#+END_SRC
由于非常量对象可以转换成 const,所以上面 4 个函数都能作用于非常量对象或者指向非常量对象的指针,此时编译器会优先选用非常量版本的函数.
** 隐式转换
*** 整型提升
将 char、unsigned char、signed char、shot、unsigned short 转换为 int 或 unsigned int。
*** 整型转换
可以在任意的两种整数类型中转换。
** 重载匹配顺序
精确匹配、类型提升、类型转换。

其中，一般的整型转换没有先后顺序。

** 重载与作用域
如果在内层作用域声明名字，将会隐藏外层作用域中声明的同名实体。在不同的作用域中无法重载函数名
#+begin_src c++
  string read();
  void print(const string &);
  void print(double);//重载print函数
  void fooBar(int ival)
  {
    bool read=false;//新作用域，隐藏了外层的read
    string s=read();//错误，read此时是一个布尔值
    void print(int);//新作用域，隐藏了之前的print
    print("Value:" );//错误
    print(ival);//正确
    print(3.14);//正确，此时调用的是print(int)
  }
#+END_SRC
如果把同名函数放在同一个函数中，则可以实现重载
#+begin_src c++
  void print(const string &);
  void print(double);//重载print函数
  void print(int);//新作用域，隐藏了之前的print
  void fooBar2(int ival)
  {
    print("Value:" );//调用print(const string &)
    print(ival);//调用print(int)
    print(3.14);//调用print(double)
  }

#+END_SRC
** 命名空间
下面两个函数是重载
#+begin_src c++
  namespacs IBM{
    int myfunc(int a);
  }
  namespacs SUN{
    using IBM::myfunc;
    int myfunc(double b);
  }
#+END_SRC
** 注意与继承覆盖区别开
子类如果有与父类相同名字（即使参数不同）的函数，将会覆盖掉父类方法。
#+begin_src c++
  class A{
    public:
    int myfunc(int a){
      return 0;
    }
  };
  class SubA : public A{
    public:
    int myfunc(int *p){
      return 0;
    }
  };
  SubA sa;
  sa.myfunc(1); //报错，不能将int转换为int*
#+END_SRC
** 操作符重载
对于内置数据类型的操作符，它预定义的意义不能被修改，也不能为内置数据类型定义其他操作符。
例如不能定义 int operator+(int, int);也不能定义 void operator+(int[],int[]).
** 实例
*** 实例 1
#+begin_src c++
#include <iostream>
using namespace std;

void myfunc(char a){
	   cout << "111 World";
};
void myfunc(long b){
	   cout << "222 World";
};
int main()
{
short c=100;
myfunc(c); //编译器会报错

return 0;
}
#+END_SRC
c 为 short 类型，先提升为 int 类型，由于 int 可以转换成 char 和 long，又由于类型转换匹配优先级相同，所以编译器不知道要匹配哪一个
*** 实例 2
#+begin_src c++
#include <iostream>
using namespace std;

void myfunc(char a){
   cout << "111 World";
};
void myfunc(int b){
   cout << "222 World";
};
int main()
{
   short c=100;
   myfunc(c);
   cout << "Hello World";
   return 0;
}
#+END_SRC
输出：
#+begin_example
222 WorldHello World
#+end_example
由于类型提升优先级高于类型转换，所以会匹配第二个函数。
* 多态
C++规定，当一个成员函数被声明为虚函数后，其派生类中的同名函数都自动成为虚函数。

多态的行为必须是在指针或者引用的情况下才能生效。
** 简单介绍
#+begin_src c++
#include "stdafx.h"
#include <iostream>
#include <stdlib.h>
using namespace std;

class Father
{
public:
    void Face()
    {
        cout << "Father's face" << endl;
    }

    void Say()
    {
        cout << "Father say hello" << endl;
    }
};


class Son:public Father
{
public:
    void Say()
    {
        cout << "Son say hello" << endl;
    }
};

void main()
{
    Son son;
    Father *pFather=&son; // 隐式类型转换
    pFather->Say();
}
#+end_src
输出的结果为:
#+DOWNLOADED: screenshot @ 2022-12-05 23:01:44
[[file:images/多态/2022-12-05_23-01-44_screenshot.png]]
c++编译器在编译的时候，要确定每个对象调用的函数（非虚函数）的地址，这称为早期绑定，
当我们将 Son 类的对象 son 的地址赋给 pFather 时，c++编译器进行了类型转换，此时 c++编译器认为变量 pFather 保存的就是 Father 对象的地址，当在 main 函数中执行 pFather->Say(),调用的当然就是 Father 对象的 Say 函数

要让编译器采用晚绑定，就要在基类中声明函数时使用 virtual 关键字，这样的函数我们就称之为虚函数，
一旦某个函数在基类中声明为 virtual，那么在所有的派生类中该函数都是 virtual，而不需要再显式地声明为 virtual。

#+begin_src c++
#include "stdafx.h"
#include <iostream>
#include <stdlib.h>
using namespace std;

class Father
{
public:
    void Face()
    {
        cout << "Father's face" << endl;
    }

    virtual void Say()
    {
        cout << "Father say hello" << endl;
    }
};


class Son:public Father
{
public:
    void Say()
    {
        cout << "Son say hello" << endl;
    }
};

void main()
{
    Son son;
    Father *pFather=&son; // 隐式类型转换
    pFather->Say();
}
#+end_src

#+DOWNLOADED: screenshot @ 2022-12-05 23:03:29
[[file:images/多态/2022-12-05_23-03-29_screenshot.png]]
** 虚表
如果一个类中有虚函数，编译器会为每个包含虚函数的类创建一个虚表(即 vtable)，该表是一个一维数组，在这个数组中存放每个虚函数的地址。

编译器另外还为每个对象提供了一个虚表指针(即 vptr)，这个指针指向了对象所属类的虚表。

在构造函数中进行虚表的创建和虚表指针的初始化，
在构造子类对象时，要先调用父类的构造函数，初始化父类对象的虚表指针，该虚表指针指向父类的虚表，
当执行子类的构造函数时，子类对象的虚表指针被初始化，指向自身的虚表。

虚表可以继承，如果子类没有重写虚函数，那么子类虚表中仍然会有该函数的地址，只不过这个地址指向的是基类的虚函数实现。
如果重写了相应的虚函数，那么虚表中的地址就会改变，指向自身的虚函数实现，如果派生类有自己的虚函数，那么虚表中就会添加该项。
** 虚表和虚表指针的运行方式
#+begin_src c++
#include<iostream.h>

class Base
 {
 public:
    virtual void function1() {cout<<"Base :: function1()\n";};
    virtual void function2() {cout<<"Base :: function2()\n";};
    virtual ~Base(){};
};

class D1: public Base
{
public:
   ~D1(){};
   virtual void function1() { cout<<"D1 :: function1()\n";};
};

class D2: public Base
{
public:
   ~D2(){};
   virtual void function2() { cout<< "D2 :: function2\n";};
};

int main()
{
  D1 *d = new D1;;
  Base *b = d;

  b->function1();
  b->function2();

  delete (b);

  return (0);
}

output:
D1 :: function1()
Base :: function2()
#+END_SRC
Here is a pictorial representation of Virtual Table and _vptr for the above code:
#+DOWNLOADED: screenshot @ 2022-12-26 22:59:51
[[file:images/多态/2022-12-26_22-59-51_screenshot.png]]
Here in function main b pointer gets assigned to D1's _vptr and now starts pointing to D1's vtable.
Then calling to a function1(), makes it's _vptr startightway calls D1's vtable function1() and so in turn calls D1's method
i.e. function1() as D1 has it's own function1() defined it's class.

Where as pointer b calling to a function2(), makes it's _vptr points to D1's vatble which in-turn pointing to Base class's vtable function2 () as shown in the diagram (as D1 class does not have it's own definition or function2()).

So, now calling delete on pointer b follows the _vptr - which is pointing to D1's vtable calls it's own class's destructor
i.e. D1 class's destructor and then calls the destrcutor of Base class - this as part of when dervied object gets deleted it turn deletes it's emebeded base object.
Thats why we must always make Base class's destrcutor as virtual if it has any virtual functions in it.
** 构造函数
C++标准规定了在构造函数中调用虚函数时，只会绑定到自己类的相应函数。虚函数在构造函数中不起作用。

*** 构造函数不能为虚函数
简言之：构造函数不能是虚函数，因为虚函数是基于对象的，构造函数是用来产生对象的，若构造函数是虚函数，则需要对象来调用，但是此时构造函数没有执行，就没有对象存在，产生矛盾，所以构造函数不能是虚函数。
**** 从存储空间角度来看
虚函数的调用需要虚函数表(vptr)指针，而该指针存放在对象的内存空间中，在构造函数中进行初始化工作，即初始化 vptr，让它指向正确的虚函数表。
所以需要调用构造函数才可以创建或初始化它的值，否则即使开辟了空间，该指针也为随机值；若构造函数声明为虚函数，那么由于对象还未创建，还没有内存空间，更没有虚函数表地址用来调用虚函数——构造函数了。

**** 从多态角度来看
构造一个对象的时候，必须知道对象的实际类型；而虚函数主要是实现多态，在运行时才可以明确调用对象，根据传入的对象类型来调用函数，
例如通过父类的指针或者引用来调用它的时候可以变成调用子类的那个成员函数
。而构造函数是在创建对象时自己主动调用的，不可能通过父类的指针或者引用去调用。那使用虚函数也就没有了实际意义。
在调用构造函数时，由于对象还未构造成功。编译器无法知道对象的实际类型，是该类本身，还是该类的一个派生类，或是更深层次的派生类。
并且构造函数的作用是提供初始化，在对象生命期仅仅运行一次，不是对象的动态行为，没有必要成为虚函数。

** 析构函数
*** 析构函数为什么必须是虚函数
当基类的析构函数为非虚函数时，删除一个基类指针指向的派生类实例时，只清理了派生类从基类继承过来的资源，而派生类自己独有的资源却没有被清理，这显然不是我们希望的。

如果一个类会被其他类继承，那么我们有必要将被继承的类（基类）的析构函数定义成虚函数。这样，释放基类指针指向的派生类实例时，先调用派生类的析构函数，再调用基类的析构函数，清理工作才能全面进行，才不会发生内存泄漏。
*** delete 子类指针
不管什么时候 delete 子类指针，都会调用父类析构函数（不管父类析构函数是不是虚函数）。

之所以要把父类析构函数定义为虚函数，是因为当父类指针指向子类对象时，delete 父类指针可以调用到子类的析构函数（之后会调用父类的析构）。
** 参数传递
*** 引用和值传递
#+begin_src c++
  class Parent{
  public:
      virtual void print();
  }
  class Son{
  public:
      void print();
  }
  void A(Parent &son){//传引用
      son.print();
  }
  void B(Parent son){//传值
      son.print();
  }
  main(){
    Son *p=new Son();
    A(*p);//调用子类的print
    B(*p);//调用父类的print
  }
#+END_SRC
第一次传引用相当于父类指针指向派生类；
第二次传值，是用派生类对象赋值给基类对象，仅仅拷贝了派生类的基类部分，因此调用基类版本函数。

多态的行为必须是在指针或者引用的情况下才能生效，对值变量来说，一定是执行静态绑定。
*** 默认参数
虚函数是动态绑定，但默认值是在编译期决定的，所以派生类的

#+begin_src c++
#include <iostream>
using namespace std;
 
class Base {
public:
    virtual void fun(int x = 111) {
        cout << "Base::fun(), x = " << x << endl;
    }
};
 
class Derived : public Base {
public:
    virtual void fun(int x=222) {
        cout << "Derived::fun(), x = " << x << endl;
    }
};
 
int main() {
    Derived d1;
    Base* p1 = &d1;
	Derived* p2=&d1; 
    p1->fun();
    p2->fun();
    return 0;
}
#+END_SRC
输出：
#+begin_example
Derived::fun(), x = 111
Derived::fun(), x = 222
#+end_example
注意，上面第一行打印的是派生类函数名，但是使用的默认值是基类的 111。
** 函数声明不同的虚函数是不同的
如下代码，基类的 display 方法加了 const，这导致派生类实际上有两个不同的虚方法：一个带 const，一个不带 const。

当用基类指针调用子类对象方法时，由于基类的虚函数表只有带 const 的方法，所以会调用到子类的带 const 的 display 方法。
#+begin_src c++
#include <iostream>
using namespace std;
 
class Base {
public:
    virtual void display() const {
        cout << "Base::display()" << endl;
    }
};
 
class Derived : public Base {
public:
    virtual void display() {
        cout << "Derived::display()" << endl;
    }
};
 
int main() {
    Derived d1;
    Base* p1 = &d1;
	Derived* p2=&d1; 
    p1->display();
    p2->display();
    return 0;
}#+END_SRC
输出：
#+begin_example
Base::display()
Derived::display()
#+end_example

如果去掉 const,则结果为：
#+begin_example
Derived::display()
Derived::display()
#+end_example
** 继承
#+begin_src c++
  class A
  ｛
  public :
  virtual void test();
  ｝;
  class B:public A{
    public:
    void test();
  }
  class C:public B{
    public:
    void test();
  }
#+END_SRC
则 B 的 test 函数以及 C 的 test 函数都是虚函数；即使 C 的 test 函数访问权限发生变化，也是虚函数。
#+begin_src c++
  class C:public B{
    private:
    void test();
  }
#+END_SRC

** 参考文章
[[https://www.go4expert.com/articles/virtual-table-vptr-t16544/][How Virtual Table and _vptr works]]
[[https://blog.csdn.net/qq_42247231/article/details/105109709][为什么析构函数必须是虚函数？为什么默认的析构函数不是虚函数？]]
* 多线程
** std::async
异步接口 std::async，通过这个接口可以简单的创建线程并通过 std::future 中获取结果。以往都是自己去封装线程实现自己的 async，现在有线程的跨平台接口可以使用就极大的方便了 C++多线程编程。

先看一下 std::async 的函数原型
#+begin_src c++
//(C++11 起) (C++17 前)
template< class Function, class... Args>
std::future<std::result_of_t<std::decay_t<Function>(std::decay_t<Args>...)>>
    async( Function&& f, Args&&... args );

//(C++11 起) (C++17 前)
template< class Function, class... Args >
std::future<std::result_of_t<std::decay_t<Function>(std::decay_t<Args>...)>>
    async( std::launch policy, Function&& f, Args&&... args );  
#+END_SRC
第一个参数是线程的创建策略，有两种策略可供选择：
- std::launch::async：在调用 async 就开始创建线程。
- std::launch::deferred：延迟加载方式创建线程。调用 async 时不创建线程，直到调用了 future 的 get 或者 wait 时才创建线程。
默认策略是：std::launch::async | std::launch::deferred 也就是两种策略的合集，具体什么意思后面详细再说

第二个参数是线程函数:
线程函数可接受 function, lambda expression, bind expression, or another function object

第三个参数是线程函数的参数:
不再说明

返回值 std::future

std::future 是一个模板类，它提供了一种访问异步操作结果的机制。从字面意思上看它表示未来，这个意思就非常贴切，因为她不是立即获取结果但是可以在某个时候以同步的方式来获取结果。我们可以通过查询 future 的状态来获取异步操作的结构。future_status 有三种状态：
- deferred：异步操作还未开始
- ready：异步操作已经完成
- timeout：异步操作超时，主要用于 std::future<T>.wait_for()

示例：
#+begin_src c++
//查询future的状态
std::future_status status;
do {
    status = future.wait_for(std::chrono::seconds(1));
    if (status == std::future_status::deferred) {
        std::cout << "deferred" << std::endl;
    } else if (status == std::future_status::timeout) {
        std::cout << "timeout" << std::endl;
    } else if (status == std::future_status::ready) {
        std::cout << "ready!" << std::endl;
    }
} while (status != std::future_status::ready);

#+END_SRC
std::future 获取结果的方式有三种：
- get：等待异步操作结束并返回结果
- wait：等待异步操作结束，但没有返回值
- waite_for：超时等待返回结果，上面示例中就是对超时等待的使用展示
d
** DONE 你好，C++的并发世界
CLOSED: [2024-10-12 周六 13:02]
** 线程管理
*** 线程启动
#+begin_src c++
#include <thread.h>
void do_some_work();
std::thread my_thread(do_some_work);

//std::thread 可以用可调用（callable）类型构造
class background_task
{
public:
    void operator()() const
    {
        do_something();
        do_something_else();
    }
};
background_task f;
std::thread my_thread(f);

//使用在前面命名函数对象的方式，或使用多组括号1，或使用新统一的初始化语法2,或lambda表达式，可以避免编译器将对象定义解析为函数声明,如下所示：
std::thread my_thread((background_task())); // 1
std::thread my_thread{background_task()}; // 2
std::thread my_thread([]{//3
    do_something();
    do_something_else();
});
#+end_src
*** 等待线程完成
如果需要等待线程，相关的 std::tread 实例需要使用 join()。

调用 join()的行为，还清理了线程相关的存储部分，这样 std::thread 对象将不再与已经完成的线程有任何关联。这意味着，只能对一个线程使用一次 join();一旦已经使用过 join()， std::thread 对象就不能再次加入了，当对其使用 joinable()时，将返回否（false）。

避免应用被抛出的异常所终止，就需要作出一个决定。通常，当倾向于在无异常的情况下使用 join()时，需要在异常处理过程中调用 join()，从而避免生命周期的问题。
#+begin_src c++
class thread_guard
{
std::thread& t;
public:
explicit thread_guard(std::thread& t_):
t(t_)
{}
~thread_guard()
{
if(t.joinable()) // 1
{
t.join(); // 2
}
}
thread_guard(thread_guard const&)=delete; // 3
thread_guard& operator=(thread_guard const&)=delete;
};
struct func; // 定义在清单2.1中
void f()
{
int some_local_state=0;
func my_func(some_local_state);
std::thread t(my_func);
thread_guard g(t);
do_something_in_current_thread();
}
#+end_src
*** 后台运行线程
#+begin_src c++
void edit_document(std::string const& filename)
{
open_document_and_display_gui(filename);
while(!done_editing())
{
user_command cmd=get_user_input();
if(cmd.type==open_new_document)
{
std::string const new_name=get_filename_from_user();
std::thread t(edit_document,new_name); // 1
t.detach(); // 2
}
else
{
process_user_input(cmd);
}
}
}
#+end_src
如果用户选择打开一个新文档，为了让迅速打开文档，需要启动一个新线程去打开新文档①，并分离线程②。这个例子也展示了传参启动线程的方法：不仅可以向 std::thread 构造函数①传递函数名，还可以传递函数所需的参数(实参)。
*** 向线程函数传递参数
#+begin_src c++
void f(int i, std::string const& s);
std::thread t(f, 3, "hello");


#+end_src
代码创建了一个调用 f(3, "hello")的线程。注意，函数 f 需要一个 std::string 对象作为第二个参数，但这里使用的是字符串的字面值，也就是 char const * 类型。之后，在线程的上下文中完成字面值向 std::string 对象的转化。

需要特别要注意，当指向动态变量的指针作为参数传递给线程的情况，函数会收到一个入参拷贝的引用,而不是入参的引用,
使用 std::bind ，就可以解决这个问题，使用 std::ref 将参数转换成引用的形式。
#+begin_src c++
std::thread t(update_data_for_widget,w,std::ref(data));
#+end_src
在这之后，update_data_for_widget 就会接收到一个 data 变量的引用，而非一个 data 变量拷贝的引用。

可以传递一个成员函数指针作为线程函数，并提供一个合适的对象指针作为第一个参数：
#+begin_src c++
class X
{
public:
void do_lengthy_work(int);
};
X my_x;
int num(0);
std::thread t(&X::do_lengthy_work, &my_x, num);//1
#+end_src
这段代码中，新线程将 my_x.do_lengthy_work()作为线程函数；my_x 的地址①作为指针对象提供给函数。也可以为成员函数提供参数： std::thread 构造函数的第三个参数就是成员函数的第一个参数，以此类推.
*** Transferring ownership of a thread
Several of the classes in the C++ Standard Library exhibit the same ownershipsemantics as std::unique_ptr, and std::thread is one of them.
Though std::thread instances don’t own a dynamic object in the same way as std::unique_ptr does, they do own a resource: each instance is responsible for managing a thread of execution.
Thisownership can be transferred between instances, because instances of std::thread are movable, even though they aren’t copyable.
This ensures that only one object is associated with a particular thread of execution at any one time while allowing programmers the option of transferring that ownership between objects.

The example shows the creation of two threads of execution and the transfer of ownership of those
threads among three std::thread instances, t1, t2, and t3:
#+begin_src c++
void some_function();
void some_other_function();
std::thread t1(some_function); // 1
std::thread t2=std::move(t1); // 2
t1=std::thread(some_other_function); // 3
std::thread t3; // 4
t3=std::move(t2); // 5
t1=std::move(t3); // 6 赋值操作将使程序崩溃
#+end_src
当显式使用 std::move() 创建 t2 后②，t1 的所有权就转移给了 t2。之后，t1 和执行线程已经没有关联了；执行 some_function 的函数现在与 t2 关联。
** 线程间共享数据
** 同步并发操作
** C++内存模型和原子类型操作
** 基于锁的并发数据结构设计
** 无锁并发数据结构设计
** 并发代码设计
** 高级线程管理
**章 多线程程序的测试和调试
* 定义抽象数据类型
#+BEGIN_SRC c++
struct ListNode {
    int val;
    ListNode *next;
    ListNode() : val(0), next(nullptr) {}
    ListNode(int x) : val(x), next(nullptr) {}
    ListNode(int x, ListNode *next) : val(x), next(next) {}
};
#+END_SRC

如果调用 ~ListNode(5)~ 那么 ~val=5~ ， ~next~ 指针为空指针
* false sharing,伪共享
https://www.cnblogs.com/cyfonly/p/5800758.html
* 函数指针
函数指针指向的是函数而非对象.
函数的类型由返回类型和形参类型共同决定,与函数名无关.
函数指针可以赋值为 nullptr 或者值为 0 的整型常量表达式.

函数 bool lengthCompare(const string &,const string &) 的类型是 bool(const string &,const string &).
如果想声明一个指向该函数的指针,只需要用指针替换函数名即可: bool (*pf)(const string &,const string &) (未初始化).
注意 *pf 左右两边的括号必不可少,如果没有括号,那么 pf 是一个返回值为 bool 指针的函数.

** 使用函数指针
当把函数名作为一个值使用时,该函数自动转换为指针.
#+begin_src c++
  pf = lengthCompare;  //pf指向名为lengthCompare的函数
  pf = &lengthCompare; //等价的赋值语句:取地址符是可选的
#+END_SRC

可以直接使用指向函数的指针调用该函数,无须提前解引用指针.
下面三个函数调用的方式是等价的:
#+begin_src c++
  bool b1 = pf("hello","goodbye");
  bool b2 = (*pf)("hello","goodbye");
  bool b3 = lengthCompare("hello","goodbye");
#+END_SRC

** 重载函数的指针
编译器通过指针类型决定选用哪个重载函数,指针类型必须与重载函数中的某一个精确匹配.
#+begin_src c++
  void ff(int *);
  void ff(unsigned int);

  void (*pf1)(unsigned int)=ff; //pf1 指向 ff(unsigned)
  void (*pf2)(int)=ff;          //错误:没有任何一个 ff 与该形参列表匹配
  double (*pf3)(int*)=ff;       //错误:ff 与 pf3 的返回值不匹配
#+END_
** 函数指针形参
和数组类似,虽然不能定义函数类型的形参,但是形参可以是指向函数的指针.
#+begin_src c++
  void useBigger(const string &s1,const string &s2,bool pf(const string &,const string &));//第三个形参是函数类型,它会自动转换为指向函数的指针
  void useBigger(const string &s1,const string &s2,bool (*pf)(const string &,const string &));//等价声明,显式地将形参定义成指向函数的指针

  useBigger(s1,s2,lengthCompare);//可以直接将函数作为实参使用,此时它会自动转换成指针
#+END_SRC

可以用类型别名和 decltype 简化使用函数指针的代码
#+begin_src c++
  //Func和Func2是函数类型
  typedef bool Func(const string&,const string&);
  typedef decltype(lengthCompare) Func2;//等价的类型
  //FuncP和FuncP2是指向函数的指针
#+END_SRC
* 互斥锁
** pthread_mutex_init()函数
该函数用于 C 函数的多线程编程中，互斥锁的初始化。
#+begin_src c++
int pthread_mutex_init(pthread_mutex_t *restrict mutex,
                       const pthread_mutexattr_t *restrict attr);
#+END_SRC
pthread_mutex_init()函数是以动态方式创建互斥锁的.

参数 attr 指定了新建互斥锁的属性。如果参数 attr 为 NULL，则使用默认的互斥锁属性，默认属性为快速互斥锁。

pthread_mutexattr_init()函数成功完成之后会返回零，其他任何返回值都表示出现了错误。

函数成功执行后，互斥锁被初始化为锁住态。

*** 互斥锁属性
互斥锁的属性在创建锁的时候指定，在 LinuxThreads 实现中仅有一个锁类型属性，不同的锁类型在试图对一个已经被锁定的互斥锁加锁时表现不同。当前（glibc2.2.3,linuxthreads0.9）有四个值可供选择：
- PTHREAD_MUTEX_TIMED_NP，这是缺省值，也就是普通锁。当一个线程加锁以后，其余请求锁的线程将形成一个等待队列，并在解锁后按优先级获得锁。这种锁策略保证了资源分配的公平性。
- PTHREAD_MUTEX_RECURSIVE_NP，嵌套锁，允许同一个线程对同一个锁成功获得多次，并通过多次 unlock 解锁。如果是不同线程请求，则在加锁线程解锁时重新竞争。
- PTHREAD_MUTEX_ERRORCHECK_NP，检错锁，如果同一个线程请求同一个锁，则返回 EDEADLK，否则与 PTHREAD_MUTEX_TIMED_NP 类型动作相同。这样就保证当不允许多次加锁时不会出现最简单情况下的死锁。
- PTHREAD_MUTEX_ADAPTIVE_NP，适应锁，动作最简单的锁类型，仅等待解锁后重新竞争。
* Hazard Pointer

#+DOWNLOADED: screenshot @ 2024-08-02 22:04:48
[[file:images/c++/Hazard_Pointer/2024-08-02_22-04-48_screenshot.png]]
** 解决了什么问题
在并发编程中，当我们在操作共享的内存对象时，需要考虑到其他线程是否有可能也正在访问同一对象，如果要释放该内存对象时不考虑这个问题，会引发严重的后果（访问悬空指针）。

线程互斥方法是解决这个最简单最直接的方法，访问共享内存时加锁即可保证没有其他线程正在访问同一对象，也就可以安全的释放内存了。但是如果我们正在操作的是一种 lock-free 的数据结构，我们自然不能容忍在这个问题上使用互斥来解决，这样会破坏 lock-free 的特性（不管任何线程失败，其他线程都能继续运行），那么，我们就需要一种同样 lock-free 的方法来解决共享内存对象的回收问题，Hazard Pointer 就是其中一种方法。

除了共享内存的回收问题之外，另一个在 lock-free 编程中不得不提到的就是大名鼎鼎 ABA 问题。依我的理解来看，ABA 问题和内存回收问题是相关的，都是内存的生命周期管理问题。具体来说，内存回收问题解的是共享内存什么时候能安全的回收，而 ABA 问题解的是共享内存什么时候能被安全的重新使用。因此，Hazard Pointer 也可以用来解决 ABA 问题。
** 和 GC 有什么区别？
一种你可能最为熟悉的解决内存回收问题的方案是 GC（垃圾回收）。GC 的确可以解决内存回收问题，也可以解决大部分的 ABA 问题（先释放后重用的使用模式），但是却不能解决所有的 ABA 问题。例如两个链表实现的栈，不断在两个栈之间交换节点（弹出到对面），这样做内存并没有被回收，但是却面临重用问题，有 ABA 风险。而 Hazard Pointer 可以结合数据结构解决这一问题。
** 和智能指针有什么区别？
智能指针也是用来解决内存回收问题的，其本质是自动引用计数，通过智能指针对象的复制和销毁来维护引用计数。但智能指针和 Hazard Pointer 所解决问题的场景有很大差别：智能指针并不是线程安全的（多线程访问同一智能指针）.

shared_ptr 使用引用计数，每一个 shared_ptr 的拷贝都指向相同的内存。每使用他一次，内部的引用计数加 1，每析构一次，内部的引用计数减 1，减为 0 时，删除所指向的堆内存。shared_ptr 内部的引用计数是安全的，但是对象的读取需要加锁。

C++ shared_ptr 是线程安全的吗？
2023-11-22
1,014
阅读 5 分钟
专栏： 
C++系列
shared_ptr 的线程安全问题
导读：C++面试中有时会有这样一个问题，shared_ptr 是线程安全的吗？对此问题，我们需要从三个并发场景进行考虑，拷贝 shared_ptr 的安全性、对 shared_ptr 赋值的安全性和读写 shared_ptr 指向内存区域的安全性。

对于以上问题，首先给出以下结论：

如果多个线程同时拷贝同一个 shared_ptr 对象，不会有问题，因为 shared_ptr 的引用计数是线程安全的。 如果多个线程同时修改同一个 shared_ptr 对象，不是线程安全的。 如果多个线程同时读写 shared_ptr 指向的内存对象，不是线程安全的。 下面通过简单程序实验证明：

1. 引用计数更新，线程安全
这里我们讨论对 shared_ptr 进行拷贝的情况，由于此操作读写的是引用计数，而引用计数的更新是原子操作，因此这种情况是线程安全的。下面这个例子，两个线程同时对同一个 shared_ptr 进行拷贝，引用计数的值总是 20001。

std::shared_ptr<int> p = std::make_shared<int>(0);
constexpr int N = 10000;
std::vector<std::shared_ptr<int>> sp_arr1(N);
std::vector<std::shared_ptr<int>> sp_arr2(N);

void increment_count(std::vector<std::shared_ptr<int>>& sp_arr) {
    for (int i = 0; i < N; i++) {
        sp_arr[i] = p;
    }
}

std::thread t1(increment_count, std::ref(sp_arr1));
std::thread t2(increment_count, std::ref(sp_arr2));
t1.join();
t2.join();
std::cout<< p.use_count() << std::endl; // always 20001
2. 同时读写内存区域，线程不安全
下面这个例子，两个线程同时对同一个 shared_ptr 指向内存的值进行自增操作，最终的结果不是我们期望的 20000。因此同时修改 shared_ptr 指向的内存区域不是线程安全的。


std::shared_ptr<int> p = std::make_shared<int>(0);
void modify_memory() {
    for (int i = 0; i < 10000; i++) {
        (*p)++;
    }
}

std::thread t1(modify_memory);
std::thread t2(modify_memory);
t1.join();
t2.join();
std::cout << "Final value of p: " << *p << std::endl; // possible result: 16171, not 20000
3. 直接修改 shared_ptr 对象本身的指向，线程不安全。
下面这个程序示例，两个线程同时修改同一个 shared_ptr 对象的指向，程序发生了异常终止。


std::shared_ptr<int> sp = std::make_shared<int>(1);
auto modify_sp_self = [&sp]() {
    for (int i = 0; i < 1000000; ++i) {
        sp = std::make_shared<int>(i);
    }
};

std::vector<std::thread> threads;
for (int i = 0; i < 10; ++i) {
    threads.emplace_back(modify_sp_self);
}
for (auto& t : threads) {
    t.join();
}
报错为：

pure virtual method called
terminate called without an active exception
用 gdb 查看函数调用栈，发现是在调用 std::shared_ptr<int>::~shared_ptr()时出错，

(gdb) bt
#0  __GI_raise (sig=sig@entry=6) at ../sysdeps/unix/sysv/linux/raise.c:50
#1  0x00007ffff7bc7859 in __GI_abort () at abort.c:79
#2  0x00007ffff7e73911 in ?? () from /lib/x86_64-linux-gnu/libstdc++.so.6
#3  0x00007ffff7e7f38c in ?? () from /lib/x86_64-linux-gnu/libstdc++.so.6
#4  0x00007ffff7e7f3f7 in std::terminate() () from /lib/x86_64-linux-gnu/libstdc++.so.6
#5  0x00007ffff7e80155 in __cxa_pure_virtual () from /lib/x86_64-linux-gnu/libstdc++.so.6
#6  0x00005555555576c2 in std::_Sp_counted_base<(__gnu_cxx::_Lock_policy)2>::_M_release() ()
#7  0x00005555555572fd in std::__shared_count<(__gnu_cxx::_Lock_policy)2>::~__shared_count() ()
#8  0x0000555555557136 in std::__shared_ptr<int, (__gnu_cxx::_Lock_policy)2>::~__shared_ptr() ()
#9  0x000055555555781c in std::__shared_ptr<int, (__gnu_cxx::_Lock_policy)2>::operator=(std::__shared_ptr<int, (__gnu_cxx::_Lock_policy)2>&&) ()
#10 0x00005555555573d0 in std::shared_ptr<int>::operator=(std::shared_ptr<int>&&) ()
#11 0x000055555555639f in main::{lambda()#1}::operator()() const ()
... 
其原因为：在并发修改的情况下，对正在析构的对象再次调用析构函数，导致了未定义的行为，从而发生了此异常。

对程序加锁后，程序可正常运行:

std::shared_ptr<int> sp = std::make_shared<int>(1);
std::mutex m;
auto modify = [&sp]() {
    // make the program thread safe
    std::lock_guard<std::mutex> lock(m);
    for (int i = 0; i < 1000000; ++i) {
        sp = std::make_shared<int>(i);
    }
};

std::vector<std::thread> threads;
for (int i = 0; i < 10; ++i) {
    threads.emplace_back(modify);
}
for (auto& t : threads) {
    t.join();
}
std::cout << *sp << std::endl;  // running as expected, result: 999999
总结
shared_ptr 未对指向的对象内存区域有线程安全保护，因此并发读写对应内存区域是不安全的。
由于赋值操作涉及原内存释放、修改指针指向等多个修改操作，其过程不是原子操作，因此对 shared_ptr 进行并发赋值不是线程安全的。
对 shared_ptr 进行并发拷贝，对数据指针和控制块指针仅进行读取并复制，然后对引用计数进行递增，而引用计数增加是原子操作。因此是线程安全的。
** 基本原理
首先看看 hazard pointer 使用的数据存储结构。如题图所示，我们需要为每个线程准备一些线程局部的内存，用来存储两部分内容：

pointers:用来存储这个线程当前正在访问的内存对象，正在访问的内存对象不能被任何线程释放
retire list:被这个线程删除的内存对象，但还没有释放
既然我们需要安全的释放内存，那么 hazard pointer 的思路也很清晰：
1. 每个线程都将自己正在访问且不希望被任何线程释放的内存对象存放在线程局部的 pointers 中
2. 当任何线程删除内存对象后，都需要先把该内存对象放入自己线程局部的 retire list
3. 当 retire list 中的内存对象数量超过一定限度时，扫描 retire list，找到没有被任何线程使用的内存节点并将其安全的释放

以上三步就构成了 hazard pointer 的全部内容。仔细分析流程会发现 pointers 是单写多读，而 retire list 是单写单读的，这个性质很重要，不然的话我们又需要另一种机制来保护 hazard pointer 了…
** 怎么用
hazard pointer 的使用是要结合具体的数据结构的，我们需要分析所要保护的数据结构的每一步操作，找出需要保护的内存对象并使用 hazard pointer 替换普通指针对危险的内存访问进行保护。还是以上次的 lock-free 队列来说，使用了 hazard pointer 后代码变为下面的样子：
#+begin_src c++
template <typename T>
void Queue<T>::enqueue(const T &data)
{
  qnode *node = new qnode();
  node->data = data;
  node->next = NULL;
  // qnode *t = NULL;
  HazardPointer<qnode> t(hazard_mgr_);
  qnode *next = NULL;
 
  while (true) {
    if (!t.acquire(&tail_)) {
      continue;
    }
    next = t->next;
    if (next) {
      __sync_bool_compare_and_swap(&tail_, t, next);
      continue;
    }
    if (__sync_bool_compare_and_swap(&t->next, NULL, node)) {
      break;
    }
  }
  __sync_bool_compare_and_swap(&tail_, t, node);
}
 
template <typename T>
bool Queue<T>::dequeue(T &data)
{
  qnode *t = NULL;
  // qnode *h = NULL;
  HazardPointer<qnode> h(hazard_mgr_);
  // qnode *next = NULL;
  HazardPointer<qnode> next(hazard_mgr_);
 
  while (true) {
    if (!h.acquire(&head_)) {
      continue;
    }
    t = tail_;
    next.acquire(&h->next);
    asm volatile("" ::: "memory");
    if (head_ != h) {
      continue;
    }
    if (!next) {
      return false;
    }
    if (h == t) {
      __sync_bool_compare_and_swap(&tail_, t, next);
      continue;
    }
    data = next->data;
    if (__sync_bool_compare_and_swap(&head_, h, next)) {
      break;
    }
  }
 
  /* h->next = (qnode *)1; // bad address, It's a trap! */
  /* delete h; */
  hazard_mgr_.retireNode(h);
  return true;
}
#+end_src

不要纠结在具体的实现定义上，可以看到的是队列的基本算法是没有改变的，区别在于我们使用 HazardPointer 保护了几个运行中需要持续保护的指针，在队列这个数据结构中，同一线程最多需要保存两个 pointer 就够了。

在获取内存对象地址时，我们使用 HazardPointer::acquire 方法将要保护的内存对象放入到 hazard pointer 中，在删除节点后，我们将内存对象交给 retireNode 方法，由 hazard pointer 负责安全的释放对应内存。
** 主流的安全内存回收方法对比
Folly 的 Hazard Pointer 实现中有一段注释，详细描述了 C++ 里几种主流的安全内存回收方法，列表如下：

|                        | 优点                        | 缺点                   | 场景              |
|------------------------+----------------------------+-----------------------+------------------|
| Locking                | 易用                        | 读高开销 / 抢占式 / 死锁 | 非性能敏感         |
| Reference Couting      | 自动回收 / 线程无关 / 免于死锁 | 读高开销 / 抢占式        | 需要自动回收       |
| Read-copy-update (RCU) | 简单 / 高速 / 可拓展          | 对阻塞敏感              | 性能敏感           |
| Hazard Pointer         | 高速 / 可拓展 / 阻塞场景可用   | 性能依赖 TLS            | 性能敏感 / 读多写少 |

C++ 标准库中提供了锁和引用计数方案。锁的缺点很明显，无论是哪种锁，在读的时候都会产生较大的开销。引用计数则相对好一些，但每次读取都需要修改引用计数，高并发场景下这样的原子操作也会成为性能瓶颈，毕竟原子加对应的 CPU 指令 lock add 也可以看成是微型锁。

Linux 内核中提供了 RCU 方法，笔者目前对此还没有太多的了解。

Hazard Pointer 适用于需要高性能读、读多写少的场景。其代码实现可参考 Folly 中的 HazPtr。
*** 引用计数的缺点
首先回忆下引用计数的做法：
#+begin_src 
#include <atomic>
#include <memory>

template <class T>
class ReferenceCount {
 public:
  ReferenceCount(std::unique_ptr<T> ptr) : ptr_(std::move(ptr)), cnt_(1) {}

  T *Ptr() const { return ptr_.get(); }

  ReferenceCount *Ref() {
    ++cnt_;
    return this;
  }

  void Deref() {
    if (--cnt_ == 0) {
      delete this;
    }
  }

 private:
  std::unique_ptr<T> ptr_;
  std::atomic_uint32_t cnt_;
};

#+end_src
仔细观察可以发现：
- 每一次的读取操作对应引用计数中增加的数值 1；
- 当所有的读取操作都完成时引用计数归 0，此时内存可以安全回收。

总结起来，当对象正在使用时，就不能回收内存。每一个“正在使用”都需要对应一个标记，引用计数使用的标记是计数数值一，对应的原子操作性能问题就成为它无法摆脱的原罪。而 Hazard Pointer 使用的标记更为轻巧，一般通过在链表中标记该对象的指针实现，回收时如果发现链表中有对应的指针就不进行内存回收，将标记的复杂度转移到回收部分，也就更适合读多写少的场景。
** 参考文章
[[https://m.tsingfun.com/it/cpp/hazard_pointer.html][C++ Lock-free Hazard Pointer（冒险指针）]]
[[http://blog.kongfy.com/2017/02/hazard-pointer/][Hazard Pointer]]
[[https://juejin.cn/post/7303739610055491636][C++ shared_ptr 是线程安全的吗？]]
* intptr_t、uintptr_t 数据类型的解析
#+begin_src c++
typedef  intptr_t      ngx_int_t;
typedef  uintptr_t    ngx_uint_t;
#+END_SRC
intptr_t 和 uintptr_t 是什么类型？以前没见过，于是查了一下。
这两个数据类型是 ISO C99 定义的，具体代码在 linux 平台的/usr/include/stdint.h 头文件中。

该头文件中定义 intptr_t 和 uintptr_t 这两个数据类型的代码片段如下：
#+begin_src c++
/* Types for `void *' pointers.  */
#if __WORDSIZE == 64
# ifndef __intptr_t_defined
typedef long int		intptr_t;
#  define __intptr_t_defined
# endif
typedef unsigned long int	uintptr_t;
#else
# ifndef __intptr_t_defined
typedef int			intptr_t;
#  define __intptr_t_defined
# endif
typedef unsigned int		uintptr_t;
#endif
#+END_SRC
在 64 位的机器上，intptr_t 和 uintptr_t 分别是 long int、unsigned long int 的别名；在 32 位的机器上，intptr_t 和 uintptr_t 分别是 int、unsigned int 的别名。

那么为什么要用 typedef 定义新的别名呢？我想主要是为了提高程序的可移植性（在 32 位和 64 位的机器上）。很明显，上述代码会根据宿主机器的位数为 intptr_t 和 uintptr_t 适配相应的数据类型。
另外，如注释所言，定义这两个数据类型别名也是为了“void *”指针。

在 C 语言中，任何类型的指针都可以转换为 void *类型，并且在将它转换回原来的类型时不会丢失信息。
** 参考文章
[[https://blog.csdn.net/cs_zhanyb/article/details/16973379][intptr_t、uintptr_t 数据类型的解析]]
* 继承
** 多重继承
非虚拟继承，B和 C 的对象分别保留一份 A 对象的内存空间，n处于不同的内存空间，因此是独立的不会相互影响，n的赋值不会覆盖；
如果 B 和 C 虚拟继承 A 类的话，A的对象只有一份，B和 C 对象中只是保存指向 A 对象的指针，n的赋值会覆盖。
#+begin_src c++
#include <iostream>
using namespace std;

class A
{
	public:
	int n;
};
class B:public A{};
class C:public A{};
class D:public B,public C{};

int main()
{
	D d;
	d.B::n=10;
	d.C::n=20;
	cout<<d.B::n<<","<<d.C::n;
	return 0;
}
#+END_SRC
** 虚继承
*** 菱形继承的问题

#+DOWNLOADED: screenshot @ 2023-03-14 22:32:32
[[file:images/继承/2023-03-14_22-32-32_screenshot.png]]
类 A 派生出类 B 和类 C，类 D 继承自类 B 和类 C，这个时候类 A 中的成员变量和成员函数继承到类 D 中变成了两份，一份来自 A-->B-->D 这条路径，另一份来自 A-->C-->D 这条路径。

在一个派生类中保留间接基类的多份同名成员，虽然可以在不同的成员变量中分别存放不同的数据，但大多数情况下这是多余的：因为保留多份成员变量不仅占用较多的存储空间，还容易产生命名冲突。
假如类 A 有一个成员变量 a，那么在类 D 中直接访问 a 就会产生歧义，编译器不知道它究竟来自 A -->B-->D 这条路径，还是来自 A-->C-->D 这条路径。
下面是菱形继承的具体实现：
#+begin_src c++
//间接基类A
class A{
protected:
    int m_a;
};

//直接基类B
class B: public A{
protected:
    int m_b;
};

//直接基类C
class C: public A{
protected:
    int m_c;
};

//派生类D
class D: public B, public C{
public:
    void seta(int a){ m_a = a; }  //命名冲突
    void setb(int b){ m_b = b; }  //正确
    void setc(int c){ m_c = c; }  //正确
    void setd(int d){ m_d = d; }  //正确
private:
    int m_d;
};

int main(){
    D d;
    return 0;
}
#+END_SRC
这段代码实现了上图所示的菱形继承，第 25 行代码试图直接访问成员变量 m_a，结果发生了错误，因为类 B 和类 C 中都有成员变量 m_a（从 A 类继承而来），编译器不知道选用哪一个，所以产生了歧义。

为了消除歧义，我们可以在 m_a 的前面指明它具体来自哪个类：
#+begin_src c++
void seta(int a){ B::m_a = a; }
#+END_SRC
这样表示使用 B 类的 m_a。当然也可以使用 C 类的：
#+begin_src c++
void seta(int a){ C::m_a = a; }
#+END_SRC
*** 虚继承（Virtual Inheritance）
为了解决多继承时的命名冲突和冗余数据问题，C++ 提出了虚继承，使得在派生类中只保留一份间接基类的成员。

在继承方式前面加上 virtual 关键字就是虚继承，请看下面的例子：
#+begin_src c++
//间接基类A
class A{
protected:
    int m_a;
};
//直接基类B
class B: virtual public A{  //虚继承
protected:
    int m_b;
};
//直接基类C
class C: virtual public A{  //虚继承
protected:
    int m_c;
};
//派生类D
class D: public B, public C{
public:
    void seta(int a){ m_a = a; }  //正确
    void setb(int b){ m_b = b; }  //正确
    void setc(int c){ m_c = c; }  //正确
    void setd(int d){ m_d = d; }  //正确
private:
    int m_d;
};
int main(){
    D d;
    return 0;
}
#+END_SRC
这段代码使用虚继承重新实现了上图所示的菱形继承，这样在派生类 D 中就只保留了一份成员变量 m_a，直接访问就不会再有歧义了。

虚继承的目的是让某个类做出声明，承诺愿意共享它的基类。
其中，这个被共享的基类就称为虚基类（Virtual Base Class），本例中的 A 就是一个虚基类。
在这种机制下，不论虚基类在继承体系中出现了多少次，在派生类中都只包含一份虚基类的成员。

现在让我们重新梳理一下本例的继承关系，如下图所示：

#+DOWNLOADED: screenshot @ 2023-03-14 22:43:51
[[file:images/继承/2023-03-14_22-43-51_screenshot.png]]

观察这个新的继承体系，我们会发现虚继承的一个不太直观的特征：必须在虚派生的真实需求出现前就已经完成虚派生的操作。
在上图中，当定义 D 类时才出现了对虚派生的需求，但是如果 B 类和 C 类不是从 A 类虚派生得到的，那么 D 类还是会保留 A 类的两份成员。

换个角度讲，虚派生只影响从指定了虚基类的派生类中进一步派生出来的类，它不会影响派生类本身。

在实际开发中，位于中间层次的基类将其继承声明为虚继承一般不会带来什么问题。
通常情况下，使用虚继承的类层次是由一个人或者一个项目组一次性设计完成的。
对于一个独立开发的类来说，很少需要基类中的某一个类是虚基类，况且新类的开发者也无法改变已经存在的类体系。

C++标准库中的 iostream 类就是一个虚继承的实际应用案例。
iostream 从 istream 和 ostream 直接继承而来，而 istream 和 ostream 又都继承自一个共同的名为 base_ios 的类，是典型的菱形继承。
此时 istream 和 ostream 必须采用虚继承，否则将导致 iostream 类中保留两份 base_ios 类的成员。

#+DOWNLOADED: screenshot @ 2023-03-14 22:51:26
[[file:images/继承/2023-03-14_22-51-26_screenshot.png]]
*** 虚基类成员的可见性
因为在虚继承的最终派生类中只保留了一份虚基类的成员，所以该成员可以被直接访问，不会产生二义性。
此外，如果虚基类的成员只被一条派生路径覆盖，那么仍然可以直接访问这个被覆盖的成员。
但是如果该成员被两条或多条路径覆盖了，那就不能直接访问了，此时必须指明该成员属于哪个类。

以图 2 中的菱形继承为例，假设 A 定义了一个名为 x 的成员变量，当我们在 D 中直接访问 x 时，会有三种可能性：
- 如果 B 和 C 中都没有 x 的定义，那么 x 将被解析为 A 的成员，此时不存在二义性。
- 如果 B 或 C 其中的一个类定义了 x，也不会有二义性，派生类的 x 比虚基类的 x 优先级更高。
- 如果 B 和 C 中都定义了 x，那么直接访问 x 将产生二义性问题。

可以看到，使用多继承经常会出现二义性问题，必须十分小心。上面的例子是简单的，如果继承的层次再多一些，关系更复杂一些，程序员就很容易陷人迷魂阵，程序的编写、调试和维护工作都会变得更加困难，
因我不提倡在程序中使用多继承，只有在比较简单和不易出现二义性的情况或实在必要时才使用多继承，能用单一继承解决的问题就不要使用多继承
。也正是由于这个原因，C++ 之后的很多面向对象的编程语言，例如 Java、C#、PHP 等，都不支持多继承。
** 访问控制
public 继承不改变父类中的成员的访问权限；
protected 继承时，public 和 protected 访问级别的成员变为 protected，private 还是 private；
private 继承时，父类所有成员变为 private。
** 派生类初始化基类对象
派生类的构造函数必须先调用基类构造函数才能初始化私有成员,如果不显示的调用基类的构造函数，则会调用默认的构造函数

下面的代码会出现编译错误，error C2512: “Base”: 没有合适的默认构造函数可用
#+begin_src c++
include <iostream>
using namespace std;

class Base
{
private:
    int n;

public:
    Base(int m):n(m){ cout<<"constructor is called\n";} //这里由于自己定义了构造函数,所以编译器不会合成默认构造函数
    ~Base(){}
};

class Derive:public Base
{
private:
    int n;

public:
    Derive(int m):n(m)//这里没有显示调用基类构造函数,所以会自动调用基类默认构造函数(即不带参数的构造函数),由于基类没有默认构造函数,导致编译出错
    {
    }
    ~Derive(){}
};

int main()
{
    Derive* a = new Derive(10);return 0;
}
#+END_SRC
正确形式应该为显示调用基类的构造函数
#+begin_src c++
public:
    Derive(int m):Base(m),n(m)
    {
    }
    ~Derive(){}
};
#+END_SRC

#+DOWNLOADED: screenshot @ 2023-04-18 22:38:37
[[file:images/继承/2023-04-18_22-38-37_screenshot.png]]

如果不显示的调用基类的构造函数，则会调用默认的构造函数:
#+begin_src c++
#include <iostream>
using namespace std;

class Base
{
private:
    int n;

public:
    Base(){ cout<<"default constructor is called\n"; n = 8;}
    Base(int m):n(m){ cout<<"constructor is called\n";}
    ~Base(){}
};

class Derive:public Base
{
private:
    int n;

public:
    Derive(int m):n(m)
    {
    }
    ~Derive(){}
};

int main()
{
    Derive* a = new Derive(10);
    return 0;
}
#+END_SRC

#+DOWNLOADED: screenshot @ 2023-04-18 22:39:14
[[file:images/继承/2023-04-18_22-39-14_screenshot.png]]

** 参考文章
[[http://c.biancheng.net/view/2280.html][C++虚继承和虚基类详解]]
[[https://www.cnblogs.com/GODYCA/archive/2013/01/17/2865279.html][C++派生类中如何初始化基类对象]]
* 拷贝、赋值、销毁
如果一个构造函数的第一个参数是自身类类型的引用，且任何额外参数都有默认值，则此构造函数是拷贝构造函数。
#+begin_src c++
  class Foo{
    public:
    Foo();//默认构造函数
    Foo(const Foo&);//拷贝构造函数，这里可以不带const
  }；
#+END_SRC

** 合成拷贝构造函数
如果没有为一个类定义拷贝构造函数，编译器会会为我们合成一个拷贝构造函数.

合成拷贝构造函数的情况:
- 如果一个类没有拷贝构造函数，但是含有一个类类型的成员变量，该类型含有拷贝构造函数，此时 编译器会为该类合成一个拷贝构造函数；
- 如果一个类没有拷贝构造函数，但是该类继承自含有拷贝构造函数的基类，此时编译器会为该类合成一个拷贝构造函数；
- 如果一个类没有拷贝构造函数，但是该类声明或继承了虚函数，此时编译器会为该类合成一个拷贝 构造函数；
- 如果一个类没有拷贝构造函数，但是该类含有虚基类，此时编译器会为该类合成一个拷贝构造函 数；

一般情况下，合成的拷贝构造函数会将其参数的成员（非 static 成员）逐个拷贝到正在创建的对象中。

每个成员的拷贝方式由数据类型决定：
- 类类型：使用其拷贝构造函数进行拷贝
- 内置类型：直接拷贝
- 数组：逐元素地拷贝，元素类型为类则用拷贝构造函数，元素类型为内置类型则直接拷贝
** 拷贝初始化
当使用直接初始化时，实际上是要求编译器使用普通的函数匹配来选择构造函数；
当使用拷贝初始化时，实际上是要求编译器将右侧运算对象拷贝到正在创建的对象中。
#+begin_src c++
  string dots(10,'.');            //直接初始化
  string s(dots);                 //直接初始化
  string s2=dots;                 //拷贝初始化
  string null_book="9-99";        //拷贝初始化
  string nines=string(100,'9');   //拷贝初始化
#+END_SRC
** 发生拷贝初始化的情况
1. 用=定义变量时
2. 将一个对象作为实参传递给一个非引用类型的形参
3. 从一个返回类型为非引用类型的函数返回一个对象
4. 用花括号列表初始化一个数组中元素或一个聚合类中成员

** 默认拷贝构造函数与深拷贝
系统默认的拷贝构造函数是浅拷贝。

默认拷贝构造函数以内存拷贝的方式将旧有对象的内存空间拷贝到新对象的内存空间。

如果类中有指针类型的类型的时候，默认拷贝构造函数只能复制指针属性的值，而不能复制指针属性所指向的内存,可能会出现野指针的问题.
为了避免内存问题,我们应该用显示拷贝构造函数进行深拷贝.
** 派生类的拷贝或移动构造函数
*** 当派生类定义了拷贝或移动构造函数，必须显式地调用基类的拷贝或移动构造函数，否则会调用基类的默认构造函数
#+begin_src c++
#include <iostream>

class Base {
 public:
  Base() { std::cout << "Base default constructor" << std::endl; }
  Base(const Base &b) { std::cout << "Base copy constructor" << std::endl; }
  Base(Base &&b) { std::cout << "Base move constructor" << std::endl; }
};

class Derived : public Base {
 public:
  Derived() { std::cout << "Derived default constructor" << std::endl; }
  Derived(const Derived &d) { std::cout << "Derived copy constructor" << std::endl; }
  Derived(Derived &&d) { std::cout << "Derived move constructor" << std::endl; }
};
 
int main() {
  Derived d;
  Derived d1(d);
  Derived d2(std::move(d));

  return 0;
}

#+END_SRC

输出结果：
#+begin_example
Base default constructor
Derived default constructor
Base default constructor
Derived copy constructor
Base default constructor
Derived move constructor
#+end_example
显式调用，将派生类修改为：
#+begin_src c++
 public:
  Derived() { std::cout << "Derived default constructor" << std::endl; }
  Derived(const Derived &d) : Base(d) { std::cout << "Derived copy constructor" << std::endl; }
  Derived(Derived &&d) : Base(std::move(d)) { std::cout << "Derived move constructor" << std::endl; }
};

#+END_SRC
class Derived : public Base {
输出结果：
#+begin_example
Base default constructor
Derived default constructor
Base copy constructor
Derived copy constructor
Base move constructor
Derived move constructor
#+end_example

*** 当派生类未定义拷贝或移动构造函数，若基类有拷贝和移动构造函数，则派生类将获得合成的拷贝和移动构造函数，且调用的是基类的拷贝或移动构造函数
#+begin_src c++
#include <iostream>

class Base {
 public:
  Base() { std::cout << "Base default constructor" << std::endl; }
  Base(const Base &b) { std::cout << "Base copy constructor" << std::endl; }
  Base(Base &&b) { std::cout << "Base move constructor" << std::endl; }
};

class Derived : public Base {
//  public:
//   Derived() { std::cout << "Derived default constructor" << std::endl; }
//   Derived(const Derived &d) : Base(d) { std::cout << "Derived copy constructor" << std::endl; }
//   Derived(Derived &&d) : Base(std::move(d)) { std::cout << "Derived move constructor" << std::endl; }
};
 
int main() {
  Derived d;
  Derived d1(d);
  Derived d2(std::move(d));

  return 0;
}

#+END_SRC
输出结果：
#+begin_example
Base default constructor
Base copy constructor
Base move constructor
#+end_example
** 右值

*** 右值引用
右值引用的标志是&&，顾名思义，右值引用专门为右值而生，可以指向右值，不能指向左值：
#+begin_src c++
int &&ref_a_right = 5; // ok

int a = 5;
int &&ref_a_left = a; // 编译不过，右值引用不可以指向左值

ref_a_right = 6; // 右值引用的用途：可以修改右值
#+end_src
**** 左值引用
左值引用大家都很熟悉，能指向左值，不能指向右值的就是左值引用：
#+begin_src c++
int a = 5;
int &ref_a = a; // 左值引用指向左值，编译通过
int &ref_a = 5; // 左值引用指向了右值，会编译失败
#+END_SRC
引用是变量的别名，由于右值没有地址，没法被修改，所以左值引用无法指向右值。

但是，const 左值引用是可以指向右值的：
#+begin_src c++
const int &ref_a = 5;  // 编译通过
#+END_SRC
const 左值引用不会修改指向值，因此可以指向右值，这也是为什么要使用 const &作为函数参数的原因之一，如 std::vector 的 push_back：
#+begin_src c++
void push_back (const value_type& val);
#+END_SRC
如果没有 const，vec.push_back(5)这样的代码就无法编译通过了。
**** 指向左值
std::move 可以让右值引用指向左值
#+begin_src c++
int a = 5; // a是个左值
int &ref_a_left = a; // 左值引用指向左值
int &&ref_a_right = std::move(a); // 通过std::move将左值转化为右值，可以被右值引用指向

cout << a; // 打印结果：5
#+end_src
std::move 的功能是把左值强制转化为右值，让右值引用可以指向左值,其实现等同于一个类型转换：static_cast<T&&>(lvalue)。

同样的，右值引用能指向右值，本质上也是把右值提升为一个左值，并定义一个右值引用通过 std::move 指向该左值：
#+begin_src c++
int &&ref_a = 5;
ref_a = 6;

等同于以下代码：

int temp = 5;
int &&ref_a = std::move(temp);
ref_a = 6;
#+end_src
**** 右值引用本身是左值
被声明出来的左、右值引用都是左值。 因为被声明出的左右值引用是有地址的，也位于等号左边。仔细看下边代码：
#+begin_src c++
// 形参是个右值引用
void change(int&& right_value) {
    right_value = 8;
}

int main() {
    int a = 5; // a是个左值
    int &ref_a_left = a; // ref_a_left是个左值引用
    int &&ref_a_right = std::move(a); // ref_a_right是个右值引用

    change(a); // 编译不过，a是左值，change参数要求右值
    change(ref_a_left); // 编译不过，左值引用ref_a_left本身也是个左值
    change(ref_a_right); // 编译不过，右值引用ref_a_right本身也是个左值

    change(std::move(a)); // 编译通过
    change(std::move(ref_a_right)); // 编译通过
    change(std::move(ref_a_left)); // 编译通过

    change(5); // 当然可以直接接右值，编译通过

    cout << &a << ' ';
    cout << &ref_a_left << ' ';
    cout << &ref_a_right;
    // 打印这三个左值的地址，都是一样的
}
#+end_src
右值引用既可以是左值也可以是右值，如果有名称则为左值，否则是右值。
**** 左右值引用的异同
1. 从性能上讲，左右值引用没有区别，传参使用左右值引用都可以避免拷贝。
2. 右值引用可以直接指向右值，也可以通过 std::move 指向左值；而左值引用只能指向左值(const 左值引用也能指向右值)。
3. 作为函数形参时，右值引用更灵活。虽然 const 左值引用也可以做到左右值都接受，但它无法修改，有一定局限性。
#+begin_src c++
  void f(const int& n) {
      n += 1; // 编译失败，const左值引用不能修改指向变量
  }

  void f2(int && n) {
      n += 1; // ok
  }


  int main() {
      f(5);
      f2(5);
  }
#+end_src
**** 右值引用和 std::move 的应用场景
**** 参考文章
[[https://zhuanlan.zhihu.com/p/335994370][一文读懂C++右值引用和std::move]]
按上文分析，std::move 只是类型转换工具，不会对性能有好处；右值引用在作为函数形参时更具灵活性，看上去还是挺鸡肋的。他们有什么实际应用场景吗？

3.1 实现移动语义
在实际场景中，右值引用和 std::move 被广泛用于在 STL 和自定义类中实现移动语义，避免拷贝，从而提升程序性能。 在没有右值引用之前，一个简单的数组类通常实现如下，有构造函数、拷贝构造函数、赋值运算符重载、析构函数等。深拷贝/浅拷贝在此不做讲解。

class Array {
public:
    Array(int size) : size_(size) {
        data = new int[size_];
    }
     
    // 深拷贝构造
    Array(const Array& temp_array) {
        size_ = temp_array.size_;
        data_ = new int[size_];
        for (int i = 0; i < size_; i ++) {
            data_[i] = temp_array.data_[i];
        }
    }
     
    // 深拷贝赋值
    Array& operator=(const Array& temp_array) {
        delete[] data_;
 
        size_ = temp_array.size_;
        data_ = new int[size_];
        for (int i = 0; i < size_; i ++) {
            data_[i] = temp_array.data_[i];
        }
    }
 
    ~Array() {
        delete[] data_;
    }
 
public:
    int *data_;
    int size_;
};
该类的拷贝构造函数、赋值运算符重载函数已经通过使用左值引用传参来避免一次多余拷贝了，但是内部实现要深拷贝，无法避免。 这时，有人提出一个想法：是不是可以提供一个移动构造函数，把被拷贝者的数据移动过来，被拷贝者后边就不要了，这样就可以避免深拷贝了，如：

class Array {
public:
    Array(int size) : size_(size) {
        data = new int[size_];
    }
     
    // 深拷贝构造
    Array(const Array& temp_array) {
        ...
    }
     
    // 深拷贝赋值
    Array& operator=(const Array& temp_array) {
        ...
    }
 
    // 移动构造函数，可以浅拷贝
    Array(const Array& temp_array, bool move) {
        data_ = temp_array.data_;
        size_ = temp_array.size_;
        // 为防止 temp_array 析构时 delete data，提前置空其 data_      
        temp_array.data_ = nullptr;
    }
     
 
    ~Array() {
        delete [] data_;
    }
 
public:
    int *data_;
    int size_;
};
这么做有 2 个问题：

不优雅，表示移动语义还需要一个额外的参数(或者其他方式)。
无法实现！temp_array 是个 const 左值引用，无法被修改，所以 temp_array.data_ = nullptr;这行会编译不过。当然函数参数可以改成非 const：Array(Array& temp_array, bool move){...}，这样也有问题，由于左值引用不能接右值，Array a = Array(Array(), true);这种调用方式就没法用了。
可以发现左值引用真是用的很不爽，右值引用的出现解决了这个问题，在 STL 的很多容器中，都实现了以右值引用为参数的移动构造函数和移动赋值重载函数，或者其他函数，最常见的如 std::vector 的 push_back 和 emplace_back。参数为左值引用意味着拷贝，为右值引用意味着移动。

class Array {
public:
    ......
 
    // 优雅
    Array(Array&& temp_array) {
        data_ = temp_array.data_;
        size_ = temp_array.size_;
        // 为防止 temp_array 析构时 delete data，提前置空其 data_      
        temp_array.data_ = nullptr;
    }
     
 
public:
    int *data_;
    int size_;
};
如何使用：

// 例 1：Array 用法
int main(){
    Array a;
 
    // 做一些操作
    .....
     
    // 左值 a，用 std::move 转化为右值
    Array b(std::move(a));
}
3.2 实例：vector::push_back 使用 std::move 提高性能
// 例 2：std::vector 和 std::string 的实际例子
int main() {
    std::string str1 = "aacasxs";
    std::vector<std::string> vec;
     
    vec.push_back(str1); // 传统方法，copy
    vec.push_back(std::move(str1)); // 调用移动语义的 push_back 方法，避免拷贝，str1 会失去原有值，变成空字符串
    vec.emplace_back(std::move(str1)); // emplace_back 效果相同，str1 会失去原有值
    vec.emplace_back("axcsddcas"); // 当然可以直接接右值
}
 
// std::vector 方法定义
void push_back (const value_type& val);
void push_back (value_type&& val);
 
void emplace_back (Args&&... args);
在 vector 和 string 这个场景，加个 std::move 会调用到移动语义函数，避免了深拷贝。

除非设计不允许移动，STL 类大都支持移动语义函数，即可移动的。 另外，编译器会默认在用户自定义的 class 和 struct 中生成移动语义函数，但前提是用户没有主动定义该类的拷贝构造等函数(具体规则自行百度哈)。 因此，可移动对象在<需要拷贝且被拷贝者之后不再被需要>的场景，建议使用 std::move 触发移动语义，提升性能。

moveable_objecta = moveable_objectb; 
改为： 
moveable_objecta = std::move(moveable_objectb);
还有些 STL 类是 move-only 的，比如 unique_ptr，这种类只有移动构造函数，因此只能移动(转移内部对象所有权，或者叫浅拷贝)，不能拷贝(深拷贝):

std::unique_ptr<A> ptr_a = std::make_unique<A>();

std::unique_ptr<A> ptr_b = std::move(ptr_a); // unique_ptr 只有‘移动赋值重载函数‘，参数是&& ，只能接右值，因此必须用 std::move 转换类型

std::unique_ptr<A> ptr_b = ptr_a; // 编译不通过
std::move 本身只做类型转换，对性能无影响。 我们可以在自己的类中实现移动语义，避免深拷贝，充分利用右值引用和 std::move 的语言特性。

4. 完美转发 std::forward
和 std::move 一样，它的兄弟 std::forward 也充满了迷惑性，虽然名字含义是转发，但他并不会做转发，同样也是做类型转换.

与 move 相比，forward 更强大，move 只能转出来右值，forward 都可以。

std::forward<T>(u)有两个参数：T与 u。 a. 当 T 为左值引用类型时，u将被转换为 T 类型的左值； b. 否则 u 将被转换为 T 类型右值。
举个例子，有 main，A，B 三个函数，调用关系为：main->A->B，建议先看懂 2.3 节对左右值引用本身是左值还是右值的讨论再看这里：

void B(int&& ref_r) {
    ref_r = 1;
}
 
// A、B 的入参是右值引用
// 有名字的右值引用是左值，因此 ref_r 是左值
void A(int&& ref_r) {
    B(ref_r);  // 错误，B的入参是右值引用，需要接右值，ref_r 是左值，编译失败
     
    B(std::move(ref_r)); // ok，std::move 把左值转为右值，编译通过
    B(std::forward<int>(ref_r));  // ok，std::forward 的 T 是 int 类型，属于条件 b，因此会把 ref_r 转为右值
}
 
int main() {
    int a = 5;
    A(std::move(a));
}
例 2：

void change2(int&& ref_r) {
    ref_r = 1;
}
 
void change3(int& ref_l) {
    ref_l = 1;
}
 
// change 的入参是右值引用
// 有名字的右值引用是 左值，因此 ref_r 是左值
void change(int&& ref_r) {
    change2(ref_r);  // 错误，change2 的入参是右值引用，需要接右值，ref_r 是左值，编译失败
     
    change2(std::move(ref_r)); // ok，std::move 把左值转为右值，编译通过
    change2(std::forward<int &&>(ref_r));  // ok，std::forward 的 T 是右值引用类型(int &&)，符合条件 b，因此 u(ref_r)会被转换为右值，编译通过
     
    change3(ref_r); // ok，change3 的入参是左值引用，需要接左值，ref_r 是左值，编译通过
    change3(std::forward<int &>(ref_r)); // ok，std::forward 的 T 是左值引用类型(int &)，符合条件 a，因此 u(ref_r)会被转换为左值，编译通过
    // 可见，forward 可以把值转换为左值或者右值
}
 
int main() {
    int a = 5;
    change(std::move(a));
}
上边的示例在日常编程中基本不会用到，std::forward 最主要运于模版编程的参数转发中，想深入了解需要学习万能引用(T &&)和引用折叠(eg:& && → ?)等知识，本文就不详细介绍这些了。

*** 参考文章
[[https://zhuanlan.zhihu.com/p/111792987][关于C++默认拷贝构造函数产生的问题的讨论]]
** 移动语义
考虑下面一个例子：
#+begin_src c++
class MyClass
{
public:
   MyClass(const std::string& s)
        : str{ s }
    {};
private:
    std::string str;
};
std::vector<MyClass> myClasses;
MyClass tmp{ "hello" };
myClasses.push_back(tmp);
myClasses.push_back(tmp);
#+END_SRC
在这个例子中，我们创建了一个容器以及一个 MyClass 对象 tmp，我们将 tmp 对象添加到容器中 2 次。每次添加时，都会发生一次拷贝操作。最终内存中的数据如图所示：
#+DOWNLOADED: screenshot @ 2023-08-23 22:49:51
[[file:images/c++/拷贝、赋值、销毁/2023-08-23_22-49-51_screenshot.png]]
现在问题来了，tmp 对象在被添加到容器中 2 次之后，就不需要了，也就是说，它的生命期即将结束。既然 tmp 对象不再需要了，那么第 2 次将其添加到容器中的操作是不是就可以不执行拷贝操作了，而是让容器直接取 tmp 对象的数据继续用。移动语义就是进行这种操作的.

所谓移动语义，就像其字面意思一样，即把数据从一个对象中转移到另一个对象中，从而避免拷贝操作所带来的性能损耗。

为了支持移动语义，C++11 引入了一种新的引用类型，称为“右值引用”，使用“&&”来声明。而我们最常使用的，使用“&”声明的引用，现在则称为“左值引用”。
*** 移动构造函数
移动构造函数是 C++11 引入的一种新的构造函数，它接收右值引用。
#+begin_src c++
class MyClass
{
public:
 MyClass()
    : val{ 998 }
  {
    name = new char[] { "Peter" };
  }
 // 实现移动构造函数
 MyClass(MyClass&& rValue) noexcept
    : val{ std::move(rValue.val) }  // 转移数据
  {
    rValue.val = 0;  // 清除被转移对象的数据
    name = rValue.name;  // 转移数据
    rValue.name = nullptr;  // 清除被转移对象的数据
  }
  ~MyClass()
  {
   if (nullptr != name)
    {
     delete[] name;
      name = nullptr;
    }
  }
private:
 int val;
 char* name;
};
MyClass A{};
MyClass B{ std::move(A) };  // 通过移动构造函数创建新对象B
#+END_SRC
在移动构造函数中，我们将传入对象 A 的数据转移给新创建的对象 B。同时，还需要关注的重点在于，我们需要把传入对象 A 的数据清除，不然就会产生多个对象共享同一份数据的问题。被转移数据的对象会处于“有效但未定义（valid but unspecified）”的状态.

通过移动构造函数创建对象 B 之后，内存中的布局如图所示：
#+DOWNLOADED: screenshot @ 2023-08-23 23:09:39
[[file:images/c++/拷贝、赋值、销毁/2023-08-23_23-09-39_screenshot.png]]
*** 移动赋值
C++11 还引入了移动赋值运算符。移动赋值运算符也是接收右值引用，它的实现和移动构造函数基本一致。在移动赋值运算符中，我们也是从传入的对象中转移数据，并将该对象的数据清除：
#+begin_src c++
class MyClass
{
public:
 MyClass()
    : val{ 998 }
  {
    name = new char[] { "Peter" };
  }
 MyClass(MyClass&& rValue) noexcept
    : val{ std::move(rValue.val) }
  {
    rValue.val = 0;
    name = rValue.name;
    rValue.name = nullptr;
  }
 // 移动赋值运算符
  MyClass& operator=(MyClass&& myClass) noexcept
  {
    val = myClass.val;
    myClass.val = 0;
    name = myClass.name;
    myClass.name = nullptr;
   return *this;
  }
  ~MyClass()
  {
   if (nullptr != name)
    {
     delete[] name;
      name = nullptr;
    }
  }
private:
 int val;
 char* name;
};
MyClass A{};
MyClass B{};
B = std::move(A);  // 使用移动赋值运算符将对象A赋值给对象B
#+END_SRC

** 拷贝语义
c++中对象中涉及其他对象或指针数据的话,执行拷贝操作可能会是一个很耗时的过程。

我们来看一个例子。假设我们有个类，该类中有一个 string 类型的成员变量，定义如下：
#+begin_src c++
class MyClass
{
public:
   MyClass(const std::string& s)
        : str{ s }
    {};
private:
    std::string str;
};
MyClass A{ "hello" };
#+END_SRC
当我们新建一个该类的对象 A，并传递参数“hello”时，对象 A 的成员变量 str 中会存储字符串“hello”。而为了存储字符串，string 类型会为其分配内存空间。因此，当前内存中的数据如图所示：

#+DOWNLOADED: screenshot @ 2023-08-23 22:47:28
[[file:images/c++/拷贝、赋值、销毁/2023-08-23_22-47-28_screenshot.png]]
现在，当我们定义了一个该类的新对象 B，且把对象 A 赋值给对象 B 时，会发生什么？即，我们执行如下语句：
#+begin_src c++
MyClass B = A;
#+END_SRC
当拷贝发生时，为了让 B 对象中的成员变量 str 也能够存储字符串“hello”，string 类型会为其分配内存空间，并将对象 A 的 str 中存储的数据复制过来。因此，经过拷贝操作后，此时内存中的数据如图所示：

#+DOWNLOADED: screenshot @ 2023-08-23 22:48:51
[[file:images/c++/拷贝、赋值、销毁/2023-08-23_22-48-51_screenshot.png]]

** 移动构造函数和移动赋值运算符的生成规则

#+DOWNLOADED: screenshot @ 2023-08-23 23:32:23
[[file:images/c++/拷贝、赋值、销毁/2023-08-23_23-32-23_screenshot.png]]

在 C++11 之前，我们拥有 4 个特殊成员函数，即构造函数、析构函数、拷贝构造函数以及拷贝赋值运算符。从 C++11 开始，我们多了 2 个特殊成员函数，即移动构造函数和移动赋值运算符。
*** deleted functions
在细说移动构造函数和移动赋值运算符的生成规则之前，我们先要说一说“已删除的函数(deleted functions)”。

在 C++11 中，可以使用语法=delete；来将函数定义为“已删除”。任何使用“已删除”函数的代码都会产生编译错误：
#+begin_src c++
class MyClass
{
public:
   void Test() = delete;
};
MyClass value;
value.Test();  // 编译错误：attempting to reference a deleted function
#+END_SRC
在之后的介绍中，我们需要关注到的点是在特定情况下，编译器会将移动构造函数和移动赋值运算符定义为 deleted。
*** 默认情况
在 C++11 之前，如果我们定义一个空类，编译器会自动为我们生成构造函数、析构函数、拷贝构造函数以及拷贝赋值运算符。该特性在移动语义上得以延伸。在 C++11 之后，如果我们定义一个空类，除了之前的 4 个特殊成员函数，编译器还会为我们生成移动构造函数和移动赋值运算符：
#+begin_src c++
class MyClass
{};
MyClass A{};  // OK，执行编译器默认生成的构造函数
MyClass B{ A };  // OK，执行编译器默认生成的拷贝构造函数
MyClass C{ std::move(A) };  // OK，执行编译器默认生成的移动构造函数
#+END_SRC
*** 当自己定义了拷贝操作之后
如果我们在类中定义了拷贝构造函数或者拷贝赋值运算符，那么编译器就不会自动生成移动构造函数和移动赋值运算符。此时，如果调用移动语义的话，由于编译器没有自动生成，因此会转而执行拷贝操作：
#+begin_src c++
class MyClass
{
public:
 MyClass()
  {}
 // 我们定义了拷贝构造函数，这会禁止编译器自动生成移动构造函数和移动赋值运算符
 MyClass(const MyClass& value)
  {}
};
MyClass A{};
MyClass B{ std::move(A) };  // 执行的是拷贝构造函数来创建对象B
#+END_SRC
*** 当我们自己定义了析构函数 析构函数的情况和定义拷贝操作一致，如果我们在类中定义了析构函数，那么编译器也不会自动生成移动构造函数和移动赋值运算符。此时，如果调用移动语义的话，同样会转而执行拷贝操作：
#+begin_src c++
class MyClass
{
public:
 // 我们定义了析构函数，这会禁止编译器自动生成移动构造函数和移动赋值运算符
  ~MyClass()
  {}
};
MyClass A{};
MyClass B{ std::move(A) };  // 执行的是拷贝构造函数来创建对象B
#+END_SRC
析构函数有一点值得注意，许多情况下，当一个类需要作为基类时，都需要声明一个 virtual 析构函数，此时需要特别留意是不是应该手动的为该类定义移动构造函数以及移动赋值运算符。此外，当子类派生时，如果子类没有实现自己的析构函数，那么将不会影响移动构造函数以及移动赋值运算符的自动生成：
#+begin_src c++
class MyBaseClass
{
public:
 virtual ~MyBaseClass()
  {}
};
class MyClass : MyBaseClass  // 子类没有实现自己的析构函数
{};
MyClass A{};
MyClass B{ std::move(A) };  // 这里将执行编译器自动生成的移动构造函数
#+END_SRC
*** 参考文章
[[https://bbs.huaweicloud.com/blogs/375866][一文入魂：再也不用担心我不懂C++移动语义了！]]
** noexcept
*** 为什么需要 noexcept
为了说明为什么需要 noexcept，我们还是从一个例子出发。我们定义 MyClass 类，并且我们先不对 MyClass 类的移动构造函数使用 noexcept：
#+begin_src c++
class MyClass
{
public:
   MyClass()
    {}
   MyClass(const MyClass& lValue)
    {
        std::cout << "拷贝构造函数" << std::endl;
    }
   MyClass(MyClass&& rValue)  // 注意这里，我们没有对移动构造函数使用noexcept
    {
        std::cout << "移动构造函数" << std::endl;
    }
private:
    std::string str{ "hello" };
};
#+END_SRC
接着，我们创建一个 MyClass 的对象 A，并且将其往 classes 容器中添加 2 次：
#+begin_src c++
MyClass A{};
std::vector<MyClass> classes;
classes.push_back(A);
classes.push_back(A);
#+END_SRC
现在，我们来梳理一下流程。classes 容器在定义时默认会申请 1 个元素的内存空间。当第 1 次执行 classes.push_back(A)；时，对象 A 会被拷贝到容器第 1 个元素的位置：

#+DOWNLOADED: screenshot @ 2023-08-23 23:31:08
[[file:images/c++/拷贝、赋值、销毁/2023-08-23_23-31-08_screenshot.png]]
当第 2 次执行 classes.push_back(A)；时，由于 classes 容器已没有多余的内存空间，因此它需要分配一块新的内存空间。在分配新的内存空间之后，classes 容器会做 2 个操作：将对象 A 拷贝到容器第 2 个元素的位置，以及将之前的元素放到新的内存空间中容器第 1 个元素的位置：
#+DOWNLOADED: screenshot @ 2023-08-23 23:33:22
[[file:images/c++/拷贝、赋值、销毁/2023-08-23_23-33-22_screenshot.png]]
如上图所示那般，老的元素是被拷贝到新的内存空间中的。是的，classes 容器确实使用的是拷贝构造函数。那么此时我们会想到，既然 classes 容器已经不需要之前的内存中的数据了，那么将老数据放到新的内存空间中应该使用移动语义，而非拷贝操作。

那么为什么 classes 容器没有使用移动语义呢？

此时，我们需要提及一个概念，即“强异常保证（strong exception guarantee）”。所谓强异常保证，即当我们调用一个函数时，如果发生了异常，那么应用程序的状态能够回滚到函数调用之前：

#+DOWNLOADED: screenshot @ 2023-08-23 23:33:42
[[file:images/c++/拷贝、赋值、销毁/2023-08-23_23-33-42_screenshot.png]]
那么强异常保证和决定使用移动语义或拷贝操作又有什么关系呢？

这是因为容器的 push_back 函数是具备强异常保证的，也就是说，当 push_back 函数在执行操作的过程中（由于内存不足需要申请新的内存、将老的元素放到新内存中等），如果发生了异常（内存空间不足无法申请等），push_back 函数需要确保应用程序的状态能够回滚到调用它之前。以上面的例子来说，当第 2 次执行 classes.push_back(A)；时，如果发生了异常，应用程序的状态会回滚到第 1 次执行 classes.push_back(A)；之后，即 classes 容器中只有一个元素。

由于我们的移动构造函数没有使用 noexcept 说明符，也就是我们没有保证移动构造函数不会抛出异常。因此，为了确保强异常保证，就只能使用拷贝构造函数了。那么拷贝构造函数同样没有保证不会抛出异常，为什么就能用呢？这是因为拷贝构造函数执行之后，被拷贝对象的原始数据是不会丢失的。因此，即使发生异常需要回滚，那些已经被拷贝的对象仍然完整且有效。但移动语义就不同了，被移动对象的原始数据是会被清除的，因此如果发生异常，那些已经被移动的对象的数据就没有了，找不回来了，也就无法完成状态回滚了。
*** 为移动语义使用 noexcept 说明符
在了解了以上的规则后，我们就清楚了，要想使用移动构造函数来将老的元素放到新的内存中，我们就需要告知编译器，我们的移动构造函数不会抛出异常，可以放心使用，这就是通过 noexcept 说明符完成的。

我们来修改下 MyClass 类的移动构造函数，为其加上 noexcept 说明符：
#+begin_src c++
class MyClass
{
public:
   MyClass()
    {}
   MyClass(const MyClass& lValue)
    {
        std::cout << "拷贝构造函数" << std::endl;
    }
   MyClass(MyClass&& rValue) noexcept  // 注意这里，为移动构造函数使用noexcept
    {
        std::cout << "移动构造函数" << std::endl;
    }
private:
    std::string str{ "hello" };
};
#+END_SRC
现在，我们再次执行上文的例子，会发现使用的是移动构造函数来创建新的内存中的元素了：

#+DOWNLOADED: screenshot @ 2023-08-23 23:35:08
[[file:images/c++/拷贝、赋值、销毁/2023-08-23_23-35-08_screenshot.png]]
关于 noexcept 说明符，是个庞大的话题，这里我们只是粗略的提及和移动语义有关的部分。值得注意的是，noexcept 说明符是我们对于不会抛出异常的保证，如果在执行的过程中有异常被抛出了，应用程序将会直接终止执行。
** 使用移动语义时需要注意的其他内容
*** 编译器生成的移动构造函数和移动赋值运算符
前文我们提及，在特定情况下，编译器会为我们自动生成移动构造函数和移动赋值运算符。在自动生成的函数中，编译器执行的是逐成员的移动语义。

假设我们的类包含一个 int 类型和一个 std::string 类型的成员：
#+begin_src c++
class MyClass
{
private:
   int val;
    std::string str;
};
#+END_SRC
那么编译器为我们自动生成的移动构造函数和移动赋值运算符类似于如下所示：
#+begin_src c++
class MyClass
{
public:
   // 编译器自动生成的移动构造函数类似这样，执行逐成员的移动语义
   MyClass(MyClass&& rValue) noexcept
        : val{ std::move(rValue.val) }
        , str{ std::move(rValue.str) }
    {}
   // 编译器自动生成的移动赋值运算符类似这样，执行逐成员的移动语义
    MyClass& operator=(MyClass&& rValue) noexcept
    {
        val = std::move(rValue.val);
        str = std::move(rValue.str);
       return *this;
    }
private:
   int val;
    std::string str;
};
#+END_SRC
*** 被移动对象的状态
当一个对象被移动之后，该对象仍然是有效的，你可以继续使用它，最终它会被销毁，执行析构函数。

C++在其文档中表明，所有标准库中的对象，当被移动之后，会处于一个“有效但未定义的状态（valid but unspecified state）”。

C++并没有强制的规定限制被移动对象必须处于什么状态，并且当类型需要满足不同用途时它的要求也不一致（例如用于 key 的类型要求被移动对象仍然能够进行排序），因此我们在实现自己的类型时需要根据具体情况来分析。但通常来说，我们应该尽可能的贴近 C++标准库中的类型规范。但不管如何，以下这一点是我们必须考虑的：

保证被移动对象能够被正确的析构。

为什么必须保证这一点呢？这是因为被移动对象只是处于一个特殊的状态，对于运行时来说，仍然是有效的，最终也会执行析构函数进行销毁。

例如在之前我们的 MyClass 类型定义中，当我们执行移动语义后，被移动对象的 name 指针会被置空。当执行析构函数时，我们就可以简单的通过判空来避免指针的无效释放，这就确保了被移动对象能够正确的析构：
#+begin_src c++
class MyClass
{
public:
   MyClass()
        : val{ 998 }
    {
        name = new char[] { "Peter" };
    }
   MyClass(MyClass&& rValue) noexcept
        : val{ std::move(rValue.val) }
    {
        rValue.val = 0;
        name = rValue.name;
        rValue.name = nullptr;  // 置空被移动对象的指针
    }
    MyClass& operator=(MyClass&& myClass) noexcept
    {
        val = myClass.val;
        myClass.val = 0;
        name = myClass.name;
        myClass.name = nullptr;  // 置空被移动对象的指针
       return *this;
    }
    ~MyClass()
    {
       if (nullptr != name)  // 通过判空来避免指针的无效释放
        {
           delete[] name;
            name = nullptr;
        }
    }
private:
   int val;
   char* name;
};
#+END_SRC
*** 避免非必要的 std::move 调用
在 C++中，存在称为“NRVO（named return value optimization，命名返回值优化）”的技术，即如果函数返回一个临时对象，则该对象会直接给函数调用方使用，而不会再创建一个新对象。听起来有点晦涩，我们来看一个例子：
#+begin_src c++
class MyClass
{};
MyClass GetTemporary()
{
    MyClass A{};
   return A;
}
MyClass myClass = GetTemporary();  // 注意这里
#+END_SRC
在上面的例子中，GetTemporary 函数会创建一个临时的 MyClass 对象 A，接着在函数结束时返回。在没有 NRVO 的情况下，当执行语句 MyClass myClass=GetTemporary()；时，会调用 MyClass 类的拷贝构造函数，通过对象 A 来拷贝创建 myClass 对象。因此，整个流程如图所示：

#+DOWNLOADED: screenshot @ 2023-08-23 23:39:02
[[file:images/c++/拷贝、赋值、销毁/2023-08-23_23-39-02_screenshot.png]]
我们可以发现，在创建完 myClass 对象之后，对象 A 就被销毁了，这无疑是一种浪费。因此，编译器会启用 NRVO，直接让 myClass 对象使用对象 A。这样一来，在整个过程中，我们只有一次创建对象 A 时构造函数的调用开销，省去了拷贝构造函数以及析构函数的调用开销：

* 类
** 构造函数
*** 构造函数初始值列表
构造函数初始值是成员名字的一个列表，每个名字后面紧跟括号括起来的（或者在花括号内的）成员初始值。
不同成员的初始化通过逗号分隔开来。
#+begin_src c++
Data(const std::string &s,int n,double p) : bookNo(s),sold(n),revenue(p*n){}
#+END_SRC
没有出现在构造函数初始值列表中的成员将通过相应的类内初始值（如果存在的话）初始化，或者执行默认初始化。
**** 构造函数初始值列表与类内初始化值的区别
由于外部无法看到类内的私有变量，所以外部是无法感知类内的私有变量的初始值的；
但是构造函数是公开的，外部可以通过构造函数对私有变量的初始值进行设置。
** 定义类型成员
类可以自定义某种类型在类中的别名
#+begin_src c++
  class Screen{
    public:
    typedef std::string::size_type pos; //自定义类型别名
    private:
    pos cursor = 0;
    pos height = 0, width = 0;
    std::string contents;
  }
#+END_SRC

#+DOWNLOADED: screenshot @ 2023-08-23 23:39:17
[[file:images/c++/lambda表达式/2023-08-23_23-39-17_screenshot.png]]
为 NRVO 点赞！

此时，可能有细心的小伙伴已经发现了，这种返回临时对象的情况不就是移动语义发挥的场景嘛。没错，机智的你是不是会想到如下的修改：
#+begin_src c++
MyClass GetTemporary()
{
    MyClass A{};
   return std::move(A);  // 使用移动语义
}
#+END_SRC
这样一来，通过移动语义，即使没有 NRVO，也可以避免拷贝操作。乍看上去没啥毛病，但我们忽略了一种情况，那就是返回的对象类型并没有实现移动语义。

让我们来分析一下这种情况，我们改写一下 MyClass 类：
#+begin_src c++
class MyClass
{
public:
    ~MyClass()  // 注意这里，通过声明析构函数，我们禁止了编译器去实现默认移动构造函数
    {}
};
#+END_SRC
现在，MyClass 类型没有实现移动语义，当我们执行语句 MyClass myClass=GetTemporary()；时，编译器没有办法调用移动构造函数来创建 myClass 对象。同时，遗憾的是，由于 std::move(A)返回的类型是 MyClass&&，与函数的返回类型 MyClass 不一致，因此编译器也不会使用 NRVO。最终，编译器只能调用拷贝构造函数来创建 myClass 对象。

因此，当返回局部对象时，我们不用画蛇添足，直接返回对象即可，编译器会优先使用最佳的 NRVO，在没有 NRVO 的情况下，会尝试执行移动构造函数，最后才是开销最大的拷贝构造函数。

#+DOWNLOADED: screenshot @ 2023-08-23 23:40:54
[[file:images/c++/类/2023-08-23_23-40-54_screenshot.png]]

* lambda 表达式
The predicates we pass to an algorithm must have exactly one or two parameters,depending on whether the algorithm takes a unary or binary predicate, respectively.However, sometimes we want to do processing that requires more arguments than the algorithm’s predicate allows.

A lambda expression represents a callable unit of code. It can be thought of as an unnamed, inline function. Like any function, a lambda has a return type, a parameter list, and a function body. Unlike a function, lambdas may be defined inside a function.A lamba expression has the form 
~[capture list] (parameter list) -> return type { function body }~

where capture list is an (often empty) list of local variables defined in the enclosing function; return type, parameter list, and function body are the same as in any ordinary function. However, unlike ordinary functions, a lambda must use a trailing return to specify its return type.

We can omit either or both of the parameter list and return type but must always include the capture list and function body:
#+BEGIN_SRC c++
auto f = [] { return 42; };
cout << f() << endl; // prints 42
#+END_SRC
Here, we’ve defined f as a callable object that takes no arguments and returns 42.
* likely 和 unlikely
* lock free
** 无锁队列
本文介绍无锁队列的一种实现。实现基于 x86 体系结构，Linux 环境。
*** 初始化
和大部分无锁数据结构的实现一样，这个无锁队列的实现也是基于链表的，声明如下：
#+begin_src c++
#ifndef _QUEUE_H_
#define _QUEUE_H_

#define CACHE_ALIGN_SIZE 64
#define CACHE_ALIGNED __attribute__((aligned(CACHE_ALIGN_SIZE)))

template <typename T>
class Queue
{
public:
  Queue() : head_(NULL), tail_(NULL)
  {
    head_ = tail_ = new qnode();
    head_->next = NULL;
  }

  virtual ~Queue()
  {
    T tmp;
    while (dequeue(tmp)) {
    }

    delete head_;
  }

  void enqueue(const T &data);
  bool dequeue(T &data);
private:
  class qnode
  {
  public:
    T data;
    qnode *next;
  };

  qnode * head_ CACHE_ALIGNED;
  qnode * tail_ CACHE_ALIGNED;
};

#endif /* _QUEUE_H_ */

#+end_src
初始化后队列的头尾都指向一个 dummy 节点，并且头尾指针都按照 cache line 对齐，以避免产生 false sharing 问题。
*** 进队（enqueue）
进队操作分三步：
1. 创建新节点
2. 将当前尾节点的 next 指针指向新节点
3. 修改尾指针指向新创建的节点
其中第二步和第三步在常规的队列实现中往往需要借助于锁来保证原子性，如果不使用锁会怎么样？

除了第一步是没有竞争的，第二步和第三步在并发执行的时候都会有竞争（都是对共享变量的 read-modify-write 操作），这要求我们需要使用原子操作来实现这两步。然而仅仅这样也还是不够的，这不能保证第二步和第三步的原子性，因此需要一些特殊的处理，看代码：
#+begin_src c++
template <typename T>
void Queue<T>::enqueue(const T &data)
{
  qnode *node = new qnode();
  node->data = data;
  node->next = NULL;
  qnode *t = NULL;
  qnode *next = NULL;

  while (true) {
    t = tail_;
    next = t->next;
    asm volatile("" ::: "memory");
    if (tail_ != t) {
      continue;
    }
    if (next) {
      __sync_bool_compare_and_swap(&tail_, t, next);
      continue;
    }
    if (__sync_bool_compare_and_swap(&t->next, NULL, node)) {
      break;
    }
  }
  __sync_bool_compare_and_swap(&tail_, t, node);
}

#+end_src

注意代码 17-20 行，这段逻辑就是处理两个操作不原子的关键所在。当并发执行进队时，通过循环检查并向前推进尾指针来保证拿到最新的尾指针。

另一段有意思的代码是 13-16 行，这一行对变量 t 进行检查，目的在于确认 t 和 next 的值是一致的，但是在这个特定的情景中我理解实际上可以删去而不影响正确性，因为后续的 CAS 操作同样会检查这一条件。
*** 出队（dequeue）
出队操作相对入队要简单不少，只要把头指针向后移并拿出数据就可以了。但是在无锁并发的情况下仍有不少细节需要考虑，直接看代码：
#+begin_src c++
template <typename T>
bool Queue<T>::dequeue(T &data)
{
  qnode *t = NULL;
  qnode *h = NULL;
  qnode *next = NULL;

  while (true) {
    h = head_;
    t = tail_;
    next = h->next;
    asm volatile("" ::: "memory");
    if (head_ != h) {
      continue;
    }
    if (!next) {
      return false;
    }
    if (h == t) {
      __sync_bool_compare_and_swap(&tail_, t, next);
      continue;
    }
    data = next->data;
    if (__sync_bool_compare_and_swap(&head_, h, next)) {
      break;
    }
  }

  h->next = (qnode *)1; // bad address, It's a trap!
  /* delete h; */
  return true;
}

#+end_src

需要解释的地方不多，只有一个比较有意思的地方，在代码的 12-15 行有一个检查，这个检查和之前提到的一样，是用来保证 h 和 next 变量是一致的。和进队过程中的那个不同的是，这段逻辑不是可有可无的，因为在 23 行对 next 指针的访问发生在 CAS 操作之前，如果访问了已经出队的节点则会导致程序崩溃。
*** What’s next?
到这里看上去这个无锁队列已经完成了，并且可以正确的运行。但你一定会发现一个严重的问题：这个队列中的内存从来没有被释放所以在不断的泄露。

没错，这就是无锁数据结构普遍存在的问题，因为没有使用互斥的同步机制，所以很难找到一个安全的释放内存的时机。你可能会认为在完成出队后释放掉内存不就可以了么？但是由于没有使用同步机制，我们无法保证这个已经出队的节点没有被其他并发线程持有，如果此时释放内存，Boom…如果之后这个内存又被重用，那又可能会遇到著名的 ABA 问题。

那这个无锁队列岂不是没用了么？当然不是，只是我们需要一种与之配套的内存生命周期管理机制，比如 Linux 内核中广泛使用的 RCU，又比如我之后会介绍的 Hazard Pointer。
*** 一点解释
你可能注意到了我在出队逻辑的 29-30 行写了两行略有些奇怪的代码，这里我来做一些解释。实际上这里本应该执行的操作是释放 h 指向的节点占用的内存，但是我在论文 1 原本算法的基础上做了一点改动，删除了 modify count 的部分（一种常用的避免 ABA 问题的方法），这就导致如果真的执行了内存释放就会产生 ABA 问题。因此我不对内存进行释放，但是修改节点保存的内容为一个非法指针，让内存非法访问的问题暴露出来（比如你可以尝试去掉出队代码 12-15 行的检查，这一段真的非常精妙，值得细细品味）。

我之所以做这样的修改，并不是因为论文中提出的算法不好，恰恰相反，论文中的算法非常精妙，但通用性不足，我只是单纯的为了引出一种更为通用的内存生命周期管理机制：Hazard Pointer。
* new 创建类对象与不 new 区别
#+BEGIN_SRC c++
A a;

A * a = new a();
#+END_SRC
以上两种方式皆可实现类的实例化,区别在于：
1. 前者在堆栈中分配内存，后者为动态内存分配，在一般应用中是没有什么区别的，但动态内存分配会使对象的可控性增强。
2. 前者在栈中分配内存，后者在堆中分配内存
3. 大程序用 new，小程序直接申请
4. new 必须 delete 删除;不用 new 的方式，系统会自动回收内存

* new 和 delete
new 和 delete 不是函数，它们都是 C++ 定义的关键字，通过特定的语法可以组成表达式。
** operator new 和 operator delete
这两个其实是 C++ 语言标准库的库函数，原型分别如下：
#+begin_src c++
void *operator new(size_t);     //allocate an object
void *operator delete(void *);    //free an object

void *operator new[](size_t);     //allocate an array
void *operator delete[](void *);    //free an array
#+END_SRC
C++ Primer 一书上说这不是重载 new 和 delete 表达式（如 operator= 就是重载 = 操作符），因为 new 和 delete 是不允许重载的。只是用 operator new 和 operator delete 来命名。

** new 和 delete 背后机制
定义一个类 A：
#+begin_src c++
class A
{
public:
    A(int v) : var(v)
    {
        fopen_s(&file, "test", "r");
    }
    ~A()
    {
        fclose(file);
    }

private:
    int var;
    FILE *file;
};
#+END_SRC
类 A 中有两个私有成员，有一个构造函数和一个析构函数，构造函数中初始化私有变量 var 以及打开一个文件，析构函数关闭打开的文件。
*** new
我们使用
#+begin_src c++
class A *pA = new A(10);
#+END_SRC
来创建一个类的对象，返回其指针 pA。如下图所示 new 背后完成的工作：

#+DOWNLOADED: screenshot @ 2022-12-26 21:54:30
[[file:images/new和delete/2022-12-26_21-54-30_screenshot.png]]
简单总结一下：
1. 首先需要调用上面提到的 operator new 标准库函数，传入的参数为 class A 的大小，这里为 8 个字节，至于为什么是 8 个字节，你可以看看《深入 C++ 对象模型》一书，这里不做多解释。这样函数返回的是分配内存的起始地址，这里假设是 0x007da290。
2. 上面分配的内存是未初始化的，也是未类型化的，第二步就在这一块原始的内存上对类对象进行初始化，调用的是相应的构造函数，这里是调用 A:A(10); 这个函数，从图中也可以看到对这块申请的内存进行了初始化，var=10, file 指向打开的文件。
3. 最后一步就是返回新分配并构造好的对象的指针，这里 pA 就指向 0x007da290 这块内存，pA 的类型为类 A 对象的指针。
所有这三步，你都可以通过反汇编找到相应的汇编代码。
*** delete
如果这时想释放掉申请的类的对象怎么办？当然我们可以使用下面的语句来完成：
#+begin_src c++
delete pA;
#+END_SRC
delete 所做的事情如下图所示：

#+DOWNLOADED: screenshot @ 2022-12-26 21:57:23
[[file:images/new和delete/2022-12-26_21-57-23_screenshot.png]]
delete 就做了两件事情：
1. 调用 pA 指向对象的析构函数，对打开的文件进行关闭。
2. 通过上面提到的标准库函数 operator delete 来释放该对象的内存，传入函数的参数为 pA 的值，也就是 0x007d290。
** 如何申请和释放一个数组？
我们经常要用到动态分配一个数组，也许是这样的：
#+begin_src c++
string *psa = new string[10];      //array of 10 empty strings
int *pia = new int[10];           //array of 10 uninitialized ints
#+END_SRC
上面在申请一个数组时都用到了 new [] 这个表达式来完成，
按照我们上面讲到的 new 和 delete 知识，第一个数组是 string 类型，分配了保存对象的内存空间之后，将调用 string 类型的默认构造函数依次初始化数组中每个元素；
第二个是申请具有内置类型的数组，分配了存储 10 个 int 对象的内存空间，但并没有初始化。

如果我们想释放空间了，可以用下面两条语句：
#+begin_src c++
delete [] psa;
delete [] pia;
#+END_SRC
都用到 delete [] 表达式，注意这地方的 [] 一般情况下不能漏掉！
我们也可以想象这两个语句分别干了什么：第一个对 10 个 string 对象分别调用析构函数，然后再释放掉为对象分配的所有内存空间；
第二个因为是内置类型不存在析构函数，直接释放为 10 个 int 型分配的所有内存空间。

这里对于第一种情况就有一个问题了：我们如何知道 psa 指向对象的数组的大小？怎么知道调用几次析构函数？

这个问题直接导致我们需要在 new [] 一个对象数组时，需要保存数组的维度，C++ 的做法是在分配数组空间时多分配了 4 个字节的大小，专门保存数组的大小，在 delete [] 时就可以取出这个保存的数，就知道了需要调用析构函数多少次了。

还是用图来说明比较清楚，我们定义了一个类 A，但不具体描述类的内容，这个类中有显示的构造函数、析构函数等。那么 当我们调用
#+begin_src c++
class A *pAa = new A[3];
#+END_SRC
时需要做的事情如下：

#+DOWNLOADED: screenshot @ 2022-12-26 22:01:35
[[file:images/new和delete/2022-12-26_22-01-35_screenshot.png]]
从这个图中我们可以看到申请时在数组对象的上面还多分配了 4 个字节用来保存数组的大小，但是最终返回的是对象数组的指针，而不是所有分配空间的起始地址。

这样的话，释放就很简单了：
#+begin_src c++
delete []pAa;
#+END_SRC

#+DOWNLOADED: screenshot @ 2022-12-26 22:02:26
[[file:images/new和delete/2022-12-26_22-02-26_screenshot.png]]
里要注意的两点是：
1. 调用析构函数的次数是从数组对象指针前面的 4 个字节中取出；
2. 传入 operator delete[] 函数的参数不是数组对象的指针 pAa，而是 pAa 的值减 4。
** new/delete 、new []/delete[] 要配对使用
因为 new/delete、new[]/delete[] 的工作原理有差别，所以需要配对使用。

如果将 new[]与 delete 混用，有可能会出现内存泄漏，下面举个例子进行说明
#+begin_src c++
int *pia = new int[10];
delete pia;
#+END_SRC
如果是内置类型或者是无自定义的析构函数的类类，那么由于没有析构函数，这样写不会有问题。

如果是带有自定义析构函数的类类型，用 new [] 来创建类对象数组，而用 delete 来释放就会发生内存泄漏：
#+begin_src c++
class A *pAa = new class A[3];
delete pAa;
#+END_SRC
那么 delete pAa; 做了两件事：
1. 调用一次 pAa 指向的对象的析构函数；
2. 调用 operator delete(pAa); 释放内存。

显然，这里只对数组的第一个类对象调用了析构函数，后面的两个对象均没调用析构函数，
如果类对象中申请了大量的内存需要在析构函数中释放，而你却在销毁数组对象时少调用了析构函数，这会造成内存泄漏。

第二点就是致命的了！直接释放 pAa 指向的内存空间，这个总是会造成严重的段错误，程序必然会奔溃！
因为分配的空间的起始地址是 pAa 指向的地方减去 4 个字节的地方。
你应该传入参数设为那个地址！
** 参考文章
[[https://www.cnblogs.com/hazir/p/new_and_delete.htlm][浅谈 C++ 中的 new/delete 和 new[]/delete[]​]]
* map
** map 的排序
*** 按 key 排序
實際上 map 內部所有的資料本來就是按 key 排序的。分析 map 結構定義，發現 map 的按 key 排序是通過第 3 個引數（比較函式的函式物件）實現的。

其中，less 為其預設的函式物件，所以如果我們不指定引數 3，map 鍵值對就會按照預設方法進行儲存。當我們希望它能以不同的方式進行排序，就需要重新指定引數 3。

如果只是呼叫 C++標準庫自帶的方法，我們只需如下所示，在宣告 map 物件時指定第 3 引數即可。
*** 按 value 排序
由于 sort 只能对序列容器（如 vector、list、deque）进行排序，而 map 虽然也是一个集合容器，但却不是线性存储的（比如红黑树）。
因此并不能直接用 sort 对 map 进行按 value 排序。

* optional

** 例子 
场景：如果有这样一个函数，通过返回值来判断计算结果是否有效，如果结果有效，才能使用结果 。

例如：计算 a、b 相除。b有可能为 0，所以需要考虑相除结果是否有效。
#+BEGIN_SRC c++
bool div_int(int a, int b, int &result) {
    if (b == 0) {
        return false;
    }
    result = a / b;
    return true;
}

TEST_F(before_optional) {
    int result = 0; // 接收结果
    auto ret = div_int(2, 1, result);
    ASSERT(ret);
    ASSERT_EQ(2, result); // 如果返回值为true, 结果才有效

    auto b = div_int(2, 0, result);
    ASSERT(!b);
}
#+END_SRC
这样的使用方式很不方便，需要两个变量来描述结果。这种场景下应该使用 c++17 中的 std::optional。我们用 std::optional 改写上面这个例子：
#+BEGIN_SRC c++
//div_int可以通过optional优化：optional中，结果是否有效和结果都保存在其中
std::optional<int> div_int(int a, int b) {
    if (b != 0) {
        return std::make_optional<int>(a / b);
    }
    return {};
}

TEST_F(optional) {
    auto ret = div_int(2, 1);
    ASSERT(ret);
    ASSERT_EQ(2, ret.value()); // 如果ret为true, 直接从ret中获取结果

    auto ret2 = div_int(2, 0);
    ASSERT(!ret2); // 结果无效

    // 如果ret2为false，获取访问value将会 抛出异常
    try {
        ret2.value();
    } catch (std::exception e) {
        std::cout << e.what() << std::endl;
    }
}
#+END_SRC
如果开发项目中没有支持到 c++17 可以用 boost 库中的 optional。
* printf("%5s”,“abcdefg ”)
执行 printf( “ %5s ” , “abcdefg ” ) 后，则输出结果为:abcdefg
- "%5s",表示输出至少 5 个字符，不够的话，左侧用空格补。
- %.5s，最多输出 5 个字符

* 全局构造与析构函数
我们知道一般的 C/C++ 的程序是从 main 函数开始的，然后在 main 函数结束后程序结束。但是不然，在 main 函数开始执行前，已经有其他的指令被执行了。

为了程序的顺利执行，首先要初始化执行环境，比如堆分配初始化（malloc, free) ，线程子系统等，这里先提一下：C++ 的全局对象构造函数就是在这一时期被执行的。即 C++ 的全局对象构造函数在 main 函数之前执行，而 C++ 全局对象的析构函数在 main 函数之后被执行。

linux 系统中，一般程序的入口是“ _start ", 这个函数是 Linux 系统库(Glibc)的一部分。当我们的程序与 Glibc 库链接在一起形成最终的可执行文件以后，这个函数就是程序的初始化部分的入口，程序的初始化部分完成一系列初始化过程以后，就会调用 main 函数来执行程序的主体。在 main 函数执行完成以后，返回到初始化部分，会进行一系列清理工作，然后结束进程。

对于有些场合，程序的一些特性的操作必须在 main 函数之前执行，还有一些操作必须在 Mian 函数之后执行，这里再提一下 C++ .因为最具代表性的就是 C++ 的全局对象的构造与析构函数。因此 ELF（linux 里一种文件格式)文件定义了两种段涉及到了这种信息。

§ .init  该段里边保存的是可执行命令，它构成了进程的初始化代码。因此，当一个程序开始运行时，在 main 函数被调用前 Glibc 的初始化部分安排执行这个段中的代码。

§ .fini  该段保存着进程终止代码指令。因此，当一个程序的 main 函数正常退出时，Glibc 会安排执行这个段中的代码。

因此，这两个段.init 和 .fini 的存在有着特别的目的，如果一个函数放到了.init 段，在 main 函数执行前，系统就会执行它。同理，假如一个函数放到了.fini 段，在 main 函数返回后函数就会被执行。利用这两个特征，C++ 的全局构造函数和析构函数就是这样来的。

** 参考文章
[[https://www.cnblogs.com/dormant/p/5065665.html][C++ 的全局构造与析构函数]]
* sort
C++ STL 标准库中的 sort() 函数，本质就是一个模板函数。该函数专门用来对容器或普通数组中指定范围内的元素进行排序，排序规则默认以元素值的大小做升序排序，除此之外我们也可以选择标准库提供的其它排序规则（比如 std::greater 降序排序规则），甚至还可以自定义排序规则。

值得一提的是，sort() 函数位于头文件中，因此在使用该函数前，程序中应包含如下语句：
#+BEGIN_SRC c++
#include <algorithm>
#+END_SRC
sort() 函数有 2 种用法，其语法格式分别为：
#+BEGIN_SRC c++
//对 [first, last) 区域内的元素做默认的升序排序
void sort (RandomAccessIterator first, RandomAccessIterator last);
//按照指定的 comp 排序规则，对 [first, last) 区域内的元素进行排序
void sort (RandomAccessIterator first, RandomAccessIterator last, Compare comp);
#+END_SRC
其中，first 和 last 都为随机访问迭代器，它们的组合 [first, last) 用来指定要排序的目标区域；另外在第 2 种格式中，comp 可以是 C++ STL 标准库提供的排序规则（比如 std::greater），也可以是自定义的排序规则。

数组排序样例：
#+BEGIN_SRC c++
#include <algorithm>
#include <algorithm>

using namespace std;

int main(){
    int arr[] = {2,6,3,5,4,8,1,0,9,10};
    sort(arr, arr+10);
    for(int i = 0;i < 10;i++)
        cout << arr[i] << " ";
}
// out
/*
0 1 2 3 4 5 6 8 9 10
*/
#+END_SRC
** 使用 STL 标准库提供的排序规则
#+BEGIN_SRC c++
int main(){
    int arr[] = {2,6,3,5,4,8,1,0,9,10};
    sort(arr, arr+10, std::greater<int>());
    for(int i = 0;i < 10;i++)
        cout << arr[i] << " ";
    cout << endl;
    sort(arr, arr+10, std::less<int>());
    for(int i = 0;i < 10;i++)
        cout << arr[i] << " ";
}
// out
/*
10 9 8 6 5 4 3 2 1 0
0 1 2 3 4 5 6 8 9 10
*/
#+END_SRC
** 使用自定义比较器
#+BEGIN_SRC c++
bool cmp(const int a, const int b){
    return a < b;
}
int main(){
    int arr[] = {2,6,3,5,4,8,1,0,9,10};
    sort(arr, arr+10, cmp);
    for(int i = 0;i < 10;i++)
        cout << arr[i] << " ";
}
// out
/*
0 1 2 3 4 5 6 8 9 10
*/
#+END_SRC
** 使用 lambda 表达式自定义比较器
#+BEGIN_SRC c++
int main(){
    int arr[] = {2,6,3,5,4,8,1,0,9,10};
    sort(arr, arr+10, [](const int a, const int b){
         return a < b;
         });
    for(int i = 0;i < 10;i++)
        cout << arr[i] << " ";
}
// out
/*
0 1 2 3 4 5 6 8 9 10
*/
#+END_SRC
** 对 map 进行排序
C++ STL 中的 map 默认以 key 排序的。

如果想对 value 进行排序，可以将 map 的 key 和 value 以 pair 的形式装到 vector 中，对 vector 进行排序。
#+begin_src c++
int main()
{
    unordered_map<int, int> iMap;
    iMap[1] = 20;
    iMap[2] = 10;
    iMap[5] = 30;
    iMap[4] = 0;

    vector<pair<int, int>> vtMap;
    for (auto it = iMap.begin(); it != iMap.end(); it++)
        vtMap.push_back(make_pair(it->first, it->second));

    sort(vtMap.begin(), vtMap.end(), 
        [](const pair<int, int> &x, const pair<int, int> &y) -> int {
        return x.second < y.second;
    });

    for (auto it = vtMap.begin(); it != vtMap.end(); it++)
        cout << it->first << ':' << it->second << '\n';
    return 0;
}
#+END_SRC
运行结果： 
#+DOWNLOADED: screenshot @ 2022-08-21 11:11:46
[[file:images/c++/sort/2022-08-21_11-11-46_screenshot.png]]

** 二维 vector 排序
*** 自定义排序函数
#+begin_src c++
static bool cmp(const vector<int>& a,const vector<int>& b){
   return a.back()<b.back();
}
sort(points.begin(),points.end(),cmp);
#+END_SRC
*** Lambda 函数
#+begin_src c++
sort(points.begin(),points.end(),[](vector<int>a, vector<int>b){return a[1]<b[1];}//速度比方法1稍慢
#+END_SRC
** 参考文章
[[https://www.cnblogs.com/zhhfan/p/14789325.html][C++中使用sort对常见容器排序]]
[[https://blog.csdn.net/liguojie12/article/details/113800426][C++ 二维vector排序(sort用法)]]
* string
** 初始化
string test1;    //空串

string test2 = "内容"; //使用=

string test3("内容");   //使用引用字符数组作为参数传给构造函数

string test4(test2); //用一个 string 初始化另一而 string

string test5(test2,pos,num); //从 test2 中的第 pos 个位置开始，拷贝个数为 num 个字符

string test6 = test2 + "内容" + test3 //混合初始化

string test7 = test2.substr(pos,num); //从 test2 中的第 pos 个位置开始，拷贝个数为 num 个字符

string test8 = test2.substr(); //参数列表为空则会拷贝 test2 的整个对象（复制 test2 的简便方法）

string test9(num,ch); //拷贝 num 个字符型 ch 到 test9

** c_str()
c_str() gives you a pointer to a temporary.
The results of c_str() are valid only through the lifetime of the temporary.
The lifetime of the temporary in most cases is to the end of the full expression, which is often the semicolon.

示例:

#+begin_src c++
#include <iostream>
using namespace std;

static string SomeFunction()
{
    string str="111";
    // does some string stuff
    return str;
}

string str = SomeFunction();//这里实际上将SomeFunction()返回的临时值进行了拷贝,存放在了str里
const char* strConverted = str.c_str(); // strConverted stores the value of the string properly
const char* charArray= SomeFunction().c_str(); // charArray是一个指针,指向SomeFunction().c_str()返回的临时变量的值,由于该临时变量在分号后被清理,所以charArray指向了随机值


int main()
{

	cout << strConverted<<endl;
	cout << charArray;//charArray是随机值

   return 0;
}
#+END_SRC
结果:
#+begin_example
111
R
#+end_example>
*** 参考文章
[[https://stackoverflow.com/questions/27627413/why-does-calling-c-str-on-a-function-that-returns-a-string-not-work][Why does calling c_str() on a function that returns a string not work?]]
* string_view 使用介绍
C++中与字符串有两种风格，分别是 C 风格的字符串、std::string 字符串。C风格的字符串性能更高，但是也不方便操作使用。如下示例：
#+BEGIN_SRC c++
#include <iostream>
#include <string>
 
int main()
{
    //C风格字符串总是以null结尾
    char cstr1[] = { 'y', 'a', 'n', 'g', NULL};
    char cstr2[5];
    strcpy(cstr1, cstr2);
    std::cout << cstr2 << std::endl;
 
    //C++风格的字符串操作更方便，但是性能不如C风格字符串
    std::string str = "yang";
    std::string str2 = str;
}
#+END_SRC

C++17 中我们可以使用 std::string_view 来获取一个字符串的视图，字符串视图并不真正的创建或者拷贝字符串，而只是拥有一个字符串的查看功能。std::string_view 比 std::string 的性能要高很多，因为每个 std::string 都独自拥有一份字符串的拷贝，而 std::string_view 只是记录了自己对应的字符串的指针和偏移位置。当我们在只是查看字符串的函数中可以直接使用 std::string_view 来代替 std::string。
#+BEGIN_SRC c++
#include <iostream>
#include <string>
#include <string_view>
 
int main()
{
 
    const char* cstr = "yangxunwu";
    std::string_view stringView1(cstr);
    std::string_view stringView2(cstr, 4);
    std::cout << "stringView1: " << stringView1 << ", stringView2: " << stringView2 << std::endl;
 
    std::string str = "yangxunwu";
    std::string_view stringView3(str.c_str());
    std::string_view stringView4(str.c_str(), 4);
    std::cout << "stringView3: " << stringView1 << ", stringView4: " << stringView2 << std::endl;
}
#+END_SRC
输出
* static_assert
c++引入了 static_assert 关键字，用来实现编译期间的断言，叫静态断言。

语法：static_assert（常量表达式，要提示的字符串）；

如果第一个参数常量表达式的值为 false，会产生一条编译错误，错误位置就是该 static_assert 语句所在行，第二个参数就是错误提示字符串。

然后通过调用 abort 来终止程序运行。
* std
** std::atomic
*** std::atomic<T>::exchange
#+begin_src c++
T exchange( T desired, std::memory_order order =
                           std::memory_order_seq_cst ) noexcept; (1)	(since C++11)
T exchange( T desired, std::memory_order order =
                           std::memory_order_seq_cst ) volatile noexcept; (2)	(since C++11)
#+end_src
Atomically replaces the underlying value with desired (a read-modify-write operation). Memory is affected according to the value of order.

It is deprecated if std::atomic<T>::is_always_lock_free is false and overload (2) participates in overload resolution. (since C++20)

exchage 用于交换,返回的值是旧值.
**** Parameters
desired	-	value to assign
order	-	memory order constraints to enforce
**** Return value
The value of the atomic variable before the call.
**** Example
#+begin_src c++
#include <algorithm>
#include <atomic>
#include <cstddef>
#include <iostream>
#include <syncstream>
#include <thread>
#include <vector>
 
int main()
{
    constexpr int thread_count{5};
    constexpr int sum{5};
 
    std::atomic<int> atom{0};
    std::atomic<int> counter{0};
 
    auto increment_to_sum = [&](const int id)
    {
        for (int next = 0; next < sum;)
        {
            // each thread is writing a value from its own knowledge
            const int current = atom.exchange(next);
            counter++;
            // sync writing to prevent from interrupting by other threads
            std::osyncstream(std::cout)
                << "Thread #" << id << " (id=" << std::this_thread::get_id()
                << ") wrote " << next << " replacing the old value "
                << current << ".\n";
            next = std::max(current, next) + 1;
        }
    };
 
    std::vector<std::thread> v;
    for (std::size_t i = 0; i < thread_count; ++i)
        v.emplace_back(increment_to_sum, i);
 
    for (auto& tr : v)
        tr.join();
 
    std::cout << thread_count << " threads take "
              << counter << " times in total to "
              << "increment 0 to " << sum << ".\n";
}
#+end_src
Possible output:
#+begin_example
Thread #1 (id=139722332333824) wrote 0 replacing the old value 0.
Thread #2 (id=139722323941120) wrote 0 replacing the old value 0.
Thread #1 (id=139722332333824) wrote 1 replacing the old value 0.
Thread #1 (id=139722332333824) wrote 2 replacing the old value 1.
Thread #1 (id=139722332333824) wrote 3 replacing the old value 2.
Thread #1 (id=139722332333824) wrote 4 replacing the old value 3.
Thread #0 (id=139722340726528) wrote 0 replacing the old value 0.
Thread #3 (id=139722315548416) wrote 0 replacing the old value 0.
Thread #3 (id=139722315548416) wrote 1 replacing the old value 4.
Thread #0 (id=139722340726528) wrote 1 replacing the old value 1.
Thread #4 (id=139722307155712) wrote 0 replacing the old value 1.
Thread #4 (id=139722307155712) wrote 2 replacing the old value 2.
Thread #4 (id=139722307155712) wrote 3 replacing the old value 2.
Thread #4 (id=139722307155712) wrote 4 replacing the old value 3.
Thread #2 (id=139722323941120) wrote 1 replacing the old value 0.
Thread #0 (id=139722340726528) wrote 2 replacing the old value 1.
Thread #2 (id=139722323941120) wrote 2 replacing the old value 4.
Thread #0 (id=139722340726528) wrote 3 replacing the old value 2.
Thread #0 (id=139722340726528) wrote 4 replacing the old value 3.
5 threads take 19 times in total to increment 0 to 5.
#+end_example
*** 基本数据类型的特化
对于大部分内建类型，C++11 提供了一些特化：
#+begin_example
std::atomic_bool std::atomic<bool>
std::atomic_char std::atomic<char>
std::atomic_schar std::atomic<signed char>
std::atomic_uchar std::atomic<unsigned char>
std::atomic_short std::atomic<short>
std::atomic_ushort std::atomic<unsigned short>
std::atomic_int std::atomic<int>
std::atomic_uint std::atomic<unsigned int>
std::atomic_long std::atomic<long>
······
//更多类型见：http://en.cppreference.com/w/cpp/atomic/atomic
#+end_example

实际上这些特化就是相当于取了一个别名，本质上是同样的定义。而对于整形的特化而言，会有一些特殊的成员函数，例如原子加 fetch_add、原子减 fetch_sub、原子与 fetch_and、原子或 fetch_or 等。常见操作符++、--、+=、&= 等也有对应的重载版本。
*** is_lock_free
atomic 有一个成员函数 is_lock_free 可以告诉我们指定类型的原子量是使用了原子 CPU 指令实现了原子操作，还是依然使用的加锁的方式来实现原子操作。

#+begin_example
The standard does not specify if atomic objects are lock-free. On a platform that doesn't provide lock-free atomic operations for a type T, atomic<T> objects may be implemented using a mutex, which wouldn't be lock-free. In that case, any containers using these objects in their implementation would not be lock-free either.

The standard does provide a way to check if an atomic<T> variable is lock-free: you can use var.is_lock_free() or atomic_is_lock_free(&var). These functions are guaranteed to always return the same value for the same type T on a given program execution. For basic types such as int, There are also macros provided (e.g. ATOMIC_INT_LOCK_FREE) which specify if lock-free atomic access to that type is available.
#+end_example
*** 参考文章
[[https://en.cppreference.com/w/cpp/atomic/atomic/exchange][cppreference.com]]
[[https://stackoverflow.com/questions/10106936/are-atomic-variables-lock-free][Are atomic variables lock-free? [duplicate]​]]
[[https://stackoverflow.com/questions/12275214/what-does-the-is-lock-free-property-of-stdatomic-mean][What does the is_lock_free property of std::atomic mean?]]
** std::tuple 和 std::tie 的用法简介
tuple 即元组，可以理解为 pair 的扩展，可以用来将不同类型的元素存放在一起，常用于函数的多返回值。

*** 定义与初始化
tuple 可以使用初始化列表进行赋值。

tuple<int,double,string> t3 = {1, 2.0, "3"};

*** 访问
可以使用 get<常量表达式>(tuple_name)来访问或修改 tuple 的元素（返回引用）
#+begin_src c++
get<0>(t3) = 4;
cout << get<1>(t3) << endl;
#+end_src
会输出 2

*** 批量赋值
std::tie 会将变量的引用整合成一个 tuple，从而实现批量赋值。
#+begin_src c++
int i; double d; string s;
tie(i, d, s) = t3;

cout << i << " " << d << " " << s << endl;
#+end_src
会输出 4 2 3

还可以使用 std::ignore 忽略某些 tuple 中的某些返回值，如

tie(i, ignore, s) = t3;

*** 其它
需要注意的是，tie 无法直接从初始化列表获得值，比如下面第 5 行会编译错误。
#+begin_src c++
int i; double d; string s;
tuple<int,double,string> t3 = {1, 2.0, "3"};
tie(i, d, s) = t3;
t3 = {1, 2.0, "3"};
tie(i, d, s) = {1, 2.0, "3"};
#+end_src

*** 参考文章
[[https://blog.csdn.net/m0_37809890/article/details/89367406][std::tuple 和 std::tie 的用法简介]]
** std::forward
std::forward 通常是用于完美转发的，它会将输入的参数原封不动地传递到下一个函数中，
这个“原封不动”指的是，如果输入的参数是左值，那么传递给下一个函数的参数的也是左值；
如果输入的参数是右值，那么传递给下一个函数的参数的也是右值。

*** 参考文章
[[https://zhuanlan.zhihu.com/p/92486775][浅谈std::forward]]
** std::optional
在需要多个返回值的时候，可以下面用的 pair 形式，将返回值定义成结构体：
#+begin_src C++
#include <iostream>

using namespace std;

struct Out {
    string out1 { "" };
    string out2 { "" };
};

pair<bool, Out> func(const string& in) {
    Out o;
    if (in.size() == 0)
        return { false, o };
    o.out1 = "hello";
    o.out2 = "world";
    return { true, o };
}

int main() {
    if (auto [status, o] = func("hi"); status) {
        cout << o.out1 << endl;
        cout << o.out2 << endl;
    }
    return 0;
}
#+end_src

From cppreference -std::optional
#+begin_example
The class template std::optional manages an optional contained value, i.e. a value that may or may not be present.
A common use case for optional is the return value of a function that may fail. As opposed to other approaches, such as std::pair<T,bool>, optional handles expensive-to-construct objects well and is more readable, as the intent is expressed explicitly.
类模板 std::optional 管理一个可选的容纳值，即可以存在也可以不存在的值。
一种常见的 optional 使用情况是一个可能失败的函数的返回值。与其他手段，如 std::pair<T,bool> 相比， optional 良好地处理构造开销高昂的对象，并更加可读，因为它显式表达意图。
#+end_example
std::optional 是在 C++ 17 中引入到标准库中的，C++ 17 之前的版本可以通过 boost::optional 实现几乎相同的功能。

我们来看一下使用 std::optional 来实现上面那段代码的样子
#+begin_src c++
#include <iostream>
#include <optional>

using namespace std;

struct Out {
    string out1 { "" };
    string out2 { "" };
};

optional<Out> func(const string& in) {
    Out o;
    if (in.size() == 0)
        return nullopt;
    o.out1 = "hello";
    o.out2 = "world";
    return { o };
}

int main() {
    if (auto ret = func("hi"); ret.has_value()) {
        cout << ret->out1 << endl;
        cout << ret->out2 << endl;
    }
    return 0;
}
#+end_src
这段代码中我们看到了部分 std::optional 的用法，std::nullopt 是 C++ 17 中提供的没有值的 optional 的表达形式，等同于 { } 。

创建一个 optional 的方法：
#+begin_src c++
// 空 optiolal
optional<int> oEmpty;
optional<float> oFloat = nullopt;

optional<int> oInt(10);
optional oIntDeduced(10);  // type deduction

// make_optional
auto oDouble = std::make_optional(3.0);
auto oComplex = make_optional<complex<double>>(3.0, 4.0);

// in_place
optional<complex<double>> o7{in_place, 3.0, 4.0};

// initializer list
optional<vector<int>> oVec(in_place, {1, 2, 3});

// 拷贝赋值
auto oIntCopy = oInt;
访问 optional 对象中数据的方法：

// 跟迭代器的使用类似，访问没有 value 的 optional 的行为是未定义的
cout << (*ret).out1 << endl; 
cout << ret->out1 << endl;

// 当没有 value 时调用该方法将 throws std::bad_optional_access 异常
cout << ret.value().out1 << endl;

// 当没有 value 调用该方法时将使用传入的默认值
Out defaultVal;
cout << ret.value_or(defaultVal).out1 << endl;
#+end_src
使用 std::optional 带来的好处：
- 省去了运行状态的 bool 值的声明，让代码更简洁，更注重返回值本身的语意
- 不用担心额外的动态内存分配
** std::ref 和 std::cref
std::ref 用于包装按引用传递的值。
std::cref 用于包装按 const 引用传递的值。

C++11 中引入 std::ref 用于取某个变量的引用，这个引入是为了解决一些传参问题。

函数式编程（如 std::bind）在使用时，是对参数直接拷贝，而不是引用。下面通过例子说明

示例 1：
#+begin_src c++
void f(int& n1, int& n2, const int& n3)
{
    std::cout << "In function: " << n1 << ' ' << n2 << ' ' << n3 << '\n';
    ++n1; // increments the copy of n1 stored in the function object
    ++n2; // increments the main()'s n2
    // ++n3; // compile error
}

int main()
{
    int n1 = 1, n2 = 2, n3 = 3;
    std::function<void()> bound_f = std::bind(f, n1, std::ref(n2), std::cref(n3));
    n1 = 10;
    n2 = 11;
    n3 = 12;
    std::cout << "Before function: " << n1 << ' ' << n2 << ' ' << n3 << '\n';
    bound_f();
    std::cout << "After function: " << n1 << ' ' << n2 << ' ' << n3 << '\n';
}

#+END_SRC
输出：
#+begin_example
Before function: 10 11 12
In function: 1 11 12
After function: 10 12 12
#+end_example
上述代码在执行 std::bind 后，在函数 f() 中 n1 的值仍然是 1，n2 和 n3 改成了修改的值，说明 std::bind 使用的是参数的拷贝而不是引用，因此必须显示利用 std::ref 来进行引用绑定。
具体为什么 std::bind 不使用引用，可能确实有一些需求，使得 C++11 的设计者认为默认应该采用拷贝，如果使用者有需求，加上 std::ref 即可。

示例 2：
#+begin_src c++
void threadFunc(std::string &str, int a)
{
    str = "change by threadFunc";
    a = 13;
}

int main()
{
    std::string str("main");
    int a = 9;
    std::thread th(threadFunc, std::ref(str), a);

    th.join();

    std::cout<<"str = " << str << std::endl;
    std::cout<<"a = " << a << std::endl;

    return 0;
}
#+END_SRC
输出：
#+begin_example
str = change by threadFunc
a = 9
#+end_example
可以看到，和 std::bind 类似，多线程的 std::thread 也是必须显式通过 std::ref 来绑定引用进行传参，否则，形参的引用声明是无效的。
** std::span
提供连续对象序列的轻量级视图。 span 提供了一种安全的方法来对在内存中背靠背排列的对象进行迭代和索引。 例如存储在内置数组中的对象 std::array 或 std::vector。

如果你通常使用指针和索引访问一系列背靠背对象，则 span 是一种更安全、轻量级的替代方案。

要设置 span 的大小，可以在编译时通过将大小指定为模板参数，也可以在运行时指定 dynamic_extent.

* STL
** STL 版本介绍
*** HP STL。
HP STL 是 Alexandar Stepanov 在惠普 Palo Alto 实验室工作时，与 Meng Lee 合作完成的。
其他版本的 C++ STL，一般是以 HP STL 为蓝本实现出来的。
HP STL 是 C++ STL 的第一个实现版本，而且开放源代码。
*** SGI STL
由 Silicon Graphics Computer Systems 公司参照 HP STL 实现，主要设计者仍然是 STL 之父 Alexandar Stepanov。
被 Linux 的 C++编译器 GCC 所采用。
SGI STL 是开源软件，源码可读性甚高。
*** STL Port
为了使 SGI STL 的基本代码都适用于 VC++和 C++ Builder 等多种编译器，俄国人 Boris Fomitchev 建立了一个 free 项目来开发 STLPort。
跨平台适用于 VC++、C++ Builder、GCC 等。  可以与 BOOST 配合使用，实现跨平台代码。
STL Port 是开放源码的。
*** P.J.Plauger STL
由 P.J.Plauger 参照 HP STL 实现出来的。
被 Visual C++编译器所采用。
不是开源的。
*** Rouge Wave STL
由 Rouge Wave 公司参照 HP STL 实现，用于 Borland C++编译器中，这个版本的 STL 也不是开源的。
用于 Borland C++编译器中。
不是开源的。
** 六大组件
STl 提供六大组件,彼此可以组合套用:
1. 容器(containers):各种数据结构，如 vector，list，deque，set，map,用来存放数据
2. 算法（algorithms) :各种常用算法如 sort，search，copy，erase。从实现的角度来看，STL 算法是一种 function template。
3. 迭代器（ iterators):扮演容器与算法之间的胶合剂，是所谓的“泛型指针”，共有五种类型，以及其它衍生变化。从实现的角度来看，迭代器是一种将 operator*, operator->， operator++, operator--等指针相关操作予以重载的 class template。所有 STL 容器都附带有自己专属的迭代器。原生指针(nativepointer)也是一种迭代器。
4、仿函数( functors) :行为类似函数，可作为算法的某种策略( policy)，仿函数就是使一个类的使用看上去像一个函数。其实现就是类中实现一个 operator()，这个类就有了类似函数的行为，就是一个仿函数类了。从实现的角度来看,仿函数是一种重载了 operator()的 class 或 class template。一般函数指针可视为狭义的仿函数。
5. 配接器( adapters) :一种用来修饰容器( containers）或仿函数（ functors)或迭代器(iterators）接口的东西。例如，STL 提供的 queue 和 stack，虽然看似容器，其实只能算是一种容器配接器，因为它们的底部完全借助 deque，所有操作都由底层的 deque 供应。改变 functor 接口者，称为 function adapter;改变 container 接口者,称为 container adapter:改变 iterator 接口者，称为 iterator adapter。
6.配置器（ allocators) :负责空间配置与管理。从实现的角度来看，配置器是一个实现了动态空间配置、空间管理、空间释放的 class template。
#+DOWNLOADED: screenshot @ 2023-07-31 23:17:55
[[file:images/c++/STL/2023-07-31_23-17-55_screenshot.png]]

** 临时对象的运用
临时对象指的是一种无名对象.

临时对象的产生(例如拷贝操作)往往降低效率,但有时可以用来简化程序.

刻意制造临时对象的方法是，在型别名称之后直接加一对小括号，并可指定初值，
例如 shape(3,5）或 int(8)，其意义相当于调用相应的 constructor 且不指定对象名称。
STL 最常将此技巧应用于仿函数（ functor）与算法的搭配上，例如:

#+begin_src c++
// file: 1config-temporary-object.cpp 
// 本例测试仿函式用于 for_each()的情形
// vc6[o] cb4[o] gcc[o] 

// 匿名对象使用

#include <vector>
#include <algorithm>
#include <iostream>

using namespace std;

template <typename T>
class print {
public:
    void operator() (const T& elem) {
        cout << elem << ' ';
    }
};

int main() {
    int ia[6] = {0, 1, 2, 3, 4, 5};
    vector<int> iv(ia, ia + 6);
    
    // print<int>() 是一个匿名对象(临时对象)，不是函数调用
    for_each(iv.begin(), iv.end(), print<int>());
}
#+END_SRC
最后一行便是产生“function template 具现体”print<int>的一个临时对象。
这个对象将被传人 for_each()之中起作用。当 for_each()结束时，这个临时对象也就结束了它的生命。

** function call 操作符（operator())
函数调用操作(C++语法中的左右小括号）也可以被重载。

许多 STL 算法都提供了两个版本，一个用于一般状况（例如排序时以递增方式排列),一个用于特殊状况(例如排序时由使用者指定以何种特殊关系进行排列)。

在特殊情况下，需要用户指定某个条件或某个策略，而条件或策略的背后由一整组操作构成，便需要某种特殊的东西来代表这“一整组操作”。
代表“一整组操作”的，当然是函数。过去 C 语言时代，欲将函数当做参数传递，唯有通过函数指针（(pointer to function，或称 function pointer）才能达成，例如:
#+begin_src c++
// file: 1qsort.cpp

// c++使用函数对象/仿函数实现一组动作
// c使用函数指针实现一组动作，但是无法存储状态在里面

#include <cstdlib>
#include <ctime>
#include <iostream>
using namespace std;

int fcmp(const void *elem1, const void *elem2);

int main() {
    int ia[10];
    // int ia[10] = {32, 92, 67, 58, 10, 4, 25, 52, 59, 54};
    srand((unsigned int)time(NULL));
    for (int i = 0; i < 10; i++) {
        ia[i] = rand() % 100 + 1;
        cout << ia[i] << " ";
    }
    cout << endl;

    // 快速排序
    qsort(ia, sizeof(ia) / sizeof(int), sizeof(int), fcmp);

    for (int i = 0; i < 10; i++) {
        cout << ia[i] << " ";
    }
}

int fcmp(const void* elem1, const void* elem2) {
    const int *i1 = (const int *)elem1;
    const int *i2 = (const int *)elem2;

    if (*i1 < *i2)
        return -1;
    else if (*i1 == *i2)
        return 0;
    else
        return 1;
}
#+END_SRC
但是函数指针有缺点,最重要的是它无法持有自己的状态(所谓局部状态, localstates)，也无法达到组件技术中的可适配性（adaptability)——--也就是无法再将某些修饰条件加诸于其上而改变其状态。

为此，STL 算法的特殊版本所接受的所谓“条件”或“策略”或“一整组操作”，都以仿函数形式呈现。
所谓仿函数(functor）就是使用起来像函数一样的东西。
如果你针对某个 class 进行 operator()重载，它就成为一个仿函数。至于要成为一个可配接的仿函数，还需要做一些额外的努力.

下面是一个将 operator()重载的例子:
#+begin_src c++
// file: 1functor.cpp

#include <iostream>
using namespace std;

// 重载了函数调用符()的类或结构体，因此plus为仿函数
template <class T>
struct plus {
    // const 后置修饰为常函数
    T operator() (const T& x, const T& y) const {
        return x + y;
    }
};

// 重载了函数调用符()的类或结构体，因此minus为仿函数
template <class T>
 struct minus {
     // const 后置修饰为常函数
     T operator() (const T& x, const T& y) const {
         return x - y;
     }
 };


int main() {
    // 生成仿函数对象
    plus<int> plusobj;
    minus<int> minusobj;

    cout << plusobj(3, 5) << endl;
    cout << minusobj(3, 5) << endl;

    // 以下直接产生仿函数的临时对象(第一对小括号),并调用之(第二对小括号)
    cout << plus<int>()(3, 5) << endl;
    cout << minus<int>()(3, 5) << endl;
}
#+END_SRC
上述的 plus<T>和 minus<T>已经非常接近 STL 的实现了，唯一的差别在于它缺乏“可配接能力”。

** 空间配置器
空间配置器(allocator)可以配置内存\\磁盘或其它辅助存储介质.

*** 空间配置器的标准接口
根据 STL 的规范，以下是 allocator 的必要接口
#+begin_example
allocator:: value_type

allocator::pointer

allocator:: const pointerallocator : :reference

allocator::const_referenceal1ocator : :size_type

allocator::difference_type

allocator::rebind :一个嵌套的(nested) class template。 class rebind<U>拥有唯-一成员 other，那是一个 typedef，代表 allocator<U>

allocator::allocator ( ) :default constructor

allocator::allocator (const allocator& ) :copy constructor

template cclass Usallocator : :allocator ( const allocator<U>&) :泛化的 copy constructor

allocator::-allocator ( ) :default constructor

pointer allocator::address (reference x) const :返回某个对象的地址。算式 a.address (x〉等同于&x

const_pointer allocator::address (const_reference x) const :返回某个 const 对象的地址。算式 a.address(x〉等同于&x

pointer allocator::allocate(size_type n, cosnt void* = 0) :配置空间，足以存储 n 个 r 对象。第二参数是个提示。实现上可能会利用它来增进区域性(locality)，或完全忽略之

void allocator::deallocate(pointer p, size_type n) :归还先前配置的空间

size_type allocator::max_size ( ) const :返回可成功配置的最大量

void allocator::construct (pointer p, const T& ) :等同于 new (const void* ) p)T(x)

void allocator::destroy(pointer p) :等同于 p->~T ()

#+end_example>

*** 设计一个简单的空间配置器，JJ:allocator
根据前述的标准接口，我们可以自行完成一个功能简单、接口不怎么齐全的 allocator 如下:
#+begin_src c++
// file: 2jjalloc.h

#ifndef __JJALLOC__
#define __JJALLOC_

#include <new>      // for placement new
#include <cstddef>  // for ptrdiff_t, size_t
#include <cstdlib>  // for exit()
#include <climits>  // for UINT_MAX
#include <iostream> // for cerr
using namespace std;

// 在全局命名空间中有一个自带的、隐藏的operator new专门用来分配内存。
// 默认情况下编译器会将new这个关键字翻译成这个operator new和相应的构造函数。
// 但在有的情况下，用户自己会在类中重载operator new，这种情况下，编译器默认会使用类中重载的operator new
// （本质上因为编译器会从命名空间由内而外查找自己想要的函数，选用第一个）。
// 如果我们想要继续使用默认的operator new，就应该写成::new 字面意思就是调用最外层命名空间中的operator new
// 值得一提的是最外层的（也是默认的）operator new也是可以被重载的。通过这种方式我们可以改变所有new的部分行为。

namespace JJ {
    // 配置空间，足以储存 n个 T对象。第二自变量是个提示。
    // 可能会利用它来增进区域性（locality），或完全忽略之。
    template <class T>
    inline T* _allocate(ptrdiff_t size, T*) {
        set_new_handler(0);
        T *tmp = (T *)(::operator new((size_t)(size * sizeof(T))));
        if (tmp == 0) {
            cerr << "out of memory" << endl;
            exit(1);
        }
        return tmp;
    }

    // 归还先前配置的空间
    template <class T>
    inline void _deallocate(T* buffer) {
        ::operator delete(buffer);
    }

    // 等同于 new(const void*) p) T(x)
    template <class T1, class T2>
    inline void _construct(T1* p, const T2& value) {
        new (p) T1(value);   // placement new. invoke ctor of T1
    }

    // 等同于 p->~T()。
    template <class T>
    inline void _destroy(T* ptr) {
        ptr->~T();
    }

    template <class T>
    class allocator {
    public:
        typedef T          value_type;
        typedef T *        pointer;
        typedef const T *  const_pointer;
        typedef T &        reference;
        typedef const T &  const_reference;
        typedef size_t     size_type;
        typedef ptrdiff_t  difference_type;

        // rebind allocator of type U
        template <class U>
        struct rebind {
            typedef allocator<U> other;
        };

        // hint used for locality. ref. [Austern], p189
        pointer allocate(size_type n, const void* hint=0) {
            return _allocate((difference_type)n, (pointer)0);
        }

        void deallocate(pointer p, size_type n) {
            _deallocate(p);
        }

        void construct(pointer p, const T& value) {
            _construct(p, value);
        }

        void destroy(pointer p) {
            _destroy(p);
        }

        // 传回某个对象的地址。a.address(x)等同于 &x
        pointer address(reference x) {
            return (pointer)&x;
        }

        // 传回某个 const对象的地址。a.address(x)等同于 &x
        const_pointer const_address(const_reference x) {
            return (const_pointer)&x;
        }

        // 传回可成功配置的最大量
        size_type max_size() const {
            return size_type(UINT_MAX / sizeof(T));
        }
    };
}
#endif

#+END_SRC

*** 具备次配置力(sub-allocation)的 SGI 空间配置器
SGI STL 的配置器与众不同，也与标准规范不同，其名称是 a1loc 而非 a1locator，而且不接受任何参数。换句话说，如果你要在程序中明白采用 SGI 配置器，则不能采用标准写法:
#+begin_src c++
vector<int, std::allocator<int> > iv; // in vc or CB
#+END_SRC
必须这么写:
#+begin_src c++
vector<int , std: :a1loc> iv ; // in ccc
#+END_SRC
SGI STL allocator 未能符合标准规格，这个事实通常不会给我们带来困扰，因为通常我们使用缺省的空间配置器，很少需要自行指定配置器名称，而 SGI STL 的每一个容器都已经指定其缺省的空间配置器为 a1loc。例如下面的 vector 声明:
#+begin_src c++
template <class T, class A1lod alloc> //缺省使用alloc为配置器
class vector i ... };
#+END_SRC

**** SGI 标准的空间配置器，std::allocator
虽然 SGI 也定义有一个符合部分标准、名为 allocator 的配置器，但 SGI 自己从未用过它，也不建议我们使用。主要原因是效率不佳，只把 C++的::operator new 和::operator delete 做一层薄薄的包装而已。

**** std:alloc
***** 对象构造和对象析构
--般而言，我们所习惯的 C++内存配置操作和释放操作是这样的:
#+begin_src c++
class Foo { ... };
Foo*pf = new Foo ; //配置内存，然后构造对象
delete pf ; //将对象析构,然后释放内存
#+END_SRC
这其中的 new 算式内含两阶段操作:
(1)调用::operator new 配置内存;
(2)调用 Foo::Foo()构造对象内容。

delete 算式也内含两阶段操作:
(1)调用 Foo::~Foo(）将对象析构;
(2）调用::operator delete 释放内存。

STL allocator 将这两阶段操作区分开来。
内存配置操作由 alloc:allocate()负责，
内存释放操作由 alloc::dealloate()负责;
对象构造操作由::construct()负责，
对象析构操作由::destroy()负责。

STL 标准规格告诉我们，配置器定义于<memory>之中，SGI <menory>内含以下两个文件:
#+begin_src c++
#include <stl_alloc.h>  //负责内存空间的配置与释放
#include <stl_construct.h>  //负责对象内容的构造与析构
#+END_SRC
内存空间的配置/释放与对象内容的构造/析构，分别着落在这两个文件身上。
其中<st1_construct.h>定义有两个基本函数:构造用的 construct()和析构用的 destroy ()。

#+DOWNLOADED: screenshot @ 2023-08-03 23:16:19
[[file:images/c++/STL/2023-08-03_23-16-19_screenshot.png]]
***** 空间的配置和释放
对象构造前的空间配置和对象析构后的空间释放，由<stl_alloc.h>负责，SGI 对此的设计哲学如下:
- 向 system heap 要求空间。
- 考虑多线程（( multi-threads）状态。
- 考虑内存不足时的应变措施。
- 考虑过多“小型区块”可能造成的内存碎片(fragment)问题。

C++的内存配置基本操作是::operator new()，内存释放基本操作是::operator delete()。
这两个全局函数相当于 C 的 malloc()和 free(〉函数。

考虑到小型区块所可能造成的内存破碎问题，SGI 设计了双层级配置器，
第一级配置器直接使用 malloc()和 free()，
第二级配置器则视情况采用不同的策略:当配置区块超过 128 bytes 时，视之为“足够大”，便调用第一级配置器;当配置区块小于 128 bytes 时，视之为“过小”，采用复杂的 memory pool 整理方式，而不再求助于第一级配置器。
整个设计究竟只开放第一级配置器，或是同时开放第二级配置器，取决于__USE_MALLOC 是否被定义(我们可以轻易测试出来，SGI STL 并未定义__USE_MALLOC)
#+begin_src c++
# ifdef __USE_MALLOC
...
typedef __malloc_alloc_template<0> ma1loc_alloc;
typedef malloc_alloc alloc; //令alloc为第一级配置器
# else
...
// 令alloc 为第二级配置器
typedef __default_alloc_template<__NODE_ALLOCATOR_THREADS，0> alloc;
#endif /* ! __USE__MALLOC */

#+END_SRC
其中_malloc_alloc_template 就是第一级配置器，__default_alloc_template 就是第二级配置器。
提醒:alloc 并不接受任何 template 型别参数。

无论 alloc 被定义为第一级或第二级配置器，SGI 还为它再包装一个接口如下，使配置器的接口能够符合 STL 规格:
#+begin_src c++
template <class T, class Alloc>
class simple_alloc
{
public:
    static T *allocate(size_t n)
    {
        return 0 == n ? 0 : (T *)Alloc::allocate(n * sizeof(T));
    }
    static T *allocate(void)
    {
        return (T *)Alloc::allocate(sizeof(T));
    }
    static void deallocate(T *p, size_t n)
    {
        if (0 != n)
            Alloc::deallocate(p, n * sizeof(T));
    }
    static void deallocate(T *p)
    {
        Alloc::deallocate(p, sizeof(T));
    }
};
#+END_SRC
其内部四个成员函数其实都是单纯的转调用，调用传递给配置器（可能是第一级也可能是第二级）的成员函数。这个接口使配置器的配置单位从 bytes 转为个别元素的大小(sizeof(T) ) .SGI STL 容器全都使用这个 simple_alloc 接口、例如:
#+begin_src c++
template <class T, class Alloc = alloc> // 預設使用 alloc 為配置器
class vector
{
protected:
    // 专属空间配置器,每次配置一个元素大小
    typedef simple_alloc<value_type, Alloc> data_allocator;
    void deallocate()
    {
        if (...)
            data_allocator::deallocate(start, end_of_storage - start);
    }
    ...
};
#+END_SRC
一、.二级配置器的关系，接口包装，及实际运用方式，可于图 2-2 略见端倪。

#+DOWNLOADED: screenshot @ 2023-08-04 22:55:05
[[file:images/c++/STL/2023-08-04_22-55-05_screenshot.png]]

#+DOWNLOADED: screenshot @ 2023-08-04 22:55:34
[[file:images/c++/STL/2023-08-04_22-55-34_screenshot.png]]
***** 第一级配置器 __malloc_alloc_template
第一级配置器的代码:
#+begin_src c++
// Malloc-based allocator.  Typically slower than default alloc below.
// Typically thread-safe and more storage efficient.
#ifdef __STL_STATIC_TEMPLATE_MEMBER_BUG
# ifdef __DECLARE_GLOBALS_HERE
    void (* __malloc_alloc_oom_handler)() = 0;
    // g++ 2.7.2 does not handle static template data members.
# else
    extern void (* __malloc_alloc_oom_handler)();
# endif
#endif

//一般而言是 thread-safe，并且对于空间的运用比较高效（efficient）。
//以下是第一级配置器。
//注意，无「template型别参数」。至于「非型别参数」inst，完全没派上用场。
template <int __inst>
class __malloc_alloc_template {

private:
// 函数指针，处理内存不足情况
  static void* _S_oom_malloc(size_t);
  static void* _S_oom_realloc(void*, size_t);

#ifndef __STL_STATIC_TEMPLATE_MEMBER_BUG
  static void (* __malloc_alloc_oom_handler)();
#endif

public:

  static void* allocate(size_t __n)
  {
    // 第一级配置器直接使用malloc
    void* __result = malloc(__n);
    // 无法满足需求时，改用oom方法
    if (0 == __result) __result = _S_oom_malloc(__n);
    return __result;
  }

  static void deallocate(void* __p, size_t /* __n */)
  {
    free(__p); // 第一级配置器直接使用free
  }

  static void* reallocate(void* __p, size_t /* old_sz */, size_t __new_sz)
  {
    // 第一级配置器直接使用realloc()
    void* __result = realloc(__p, __new_sz);
    // 无法满足需求时使用oom_realloc()
    if (0 == __result) __result = _S_oom_realloc(__p, __new_sz);
    return __result;
  }

  // 以下模拟c++的set_new_handler(),可以指定自己的oom handler
  static void (* __set_malloc_handler(void (*__f)()))()
  {
    void (* __old)() = __malloc_alloc_oom_handler;
    __malloc_alloc_oom_handler = __f;
    return(__old);
  }

};

// malloc_alloc out-of-memory handling

#ifndef __STL_STATIC_TEMPLATE_MEMBER_BUG
template <int __inst>
// 由客户端设定
void (* __malloc_alloc_template<__inst>::__malloc_alloc_oom_handler)() = 0;
#endif

template <int __inst>
void*
__malloc_alloc_template<__inst>::_S_oom_malloc(size_t __n)
{
    void (* __my_malloc_handler)();
    void* __result;

    for (;;) { // 不断尝试释放、配置、再释放、再配置
        __my_malloc_handler = __malloc_alloc_oom_handler;
        if (0 == __my_malloc_handler) { __THROW_BAD_ALLOC; }
        (*__my_malloc_handler)();  // 企图释放内存
        __result = malloc(__n);   // 尝试配置内存
        if (__result) return(__result);
    }
}

template <int __inst>
void* __malloc_alloc_template<__inst>::_S_oom_realloc(void* __p, size_t __n)
{
    void (* __my_malloc_handler)();
    void* __result;

    for (;;) {  // 同上
        __my_malloc_handler = __malloc_alloc_oom_handler;
        if (0 == __my_malloc_handler) { __THROW_BAD_ALLOC; }
        (*__my_malloc_handler)();
        __result = realloc(__p, __n);
        if (__result) return(__result);
    }
}

// 直接将inst参数设置为0
typedef __malloc_alloc_template<0> malloc_alloc;
#+END_SRC
第一级配置器以 malloc() , free() , realloc()等 C 函数执行实际的内存配置、释放、重配置操作，并实现出类似 C++ new-handler 的机制。
是的，它不能直接运用 C++ new-handler 机制，因为它并非使用::operator new 来配置内存.
所谓 C++ new handler 机制是，你可以要求系统在内存配置需求无法被满足时，调用一个你所指定的函数。换句话说，一旦 ::operator new 无法完成任务，在丢出 std:bad_alloc 异常状态之前，会先调用由客端指定的处理例程。该处理例程通常即被称为 new-handler。new-handler 解决内存不足的做法有特定的模式，请参考《Effective C++》2e 条款 7。

注意，SGI 以 malloc 而非 : :operator new 来配置内存（我所能够想象的一个原因是历史因素，另一个原因是 C+并未提供相应于 realloc()的内存配置操作），因此，SGI 不能直接使用 C++的 set_new_handler()，必须仿真--个类似的 set_mailoc_handler()。

请注意，SGI 第一级配置器的 allocate()和 realloc()都是在调用 malloc()和 realloc()不成功后,改调用 oom_malloc()和 oom_realloc() 。
后两者都有内循环，不断调用“内存不足处理例程”，期望在某次调用之后，获得足够的内存而圆满完成任务。但如果“内存不足处理例程”并未被客端设定，oom_malloc()和 oom_realloc(〉便老实不客气地调用__THROw_BAD_ALLOC，丢出 bad_alloc 异常信息，或利用 exit(1)硬生生中止程序。

记住，设计“内存不足处理例程”是客端的责任，设定“内存不足处理例程”也是客端的责任。再一次提醒你，“内存不足处理例程”解决问题的做法有着特定的模式，请参考[Meyers98]条款 7。
***** 第二级配置器__default_alloc_tem plate 剖析

** 迭代器
迭代器( iterators）是一种抽象的设计概念，现实程序语言中并没有直接对应于这个概念的实物。
《Design Patterns》一书提供有 23 个设计模式( design patterns)的完整描述，其中 iterator 模式定义如下:
提供一种方法，使之能够依序巡访某个聚合物（容器）所含的各个元素，而又无需暴露该聚合物的内部表述方式。

*** 迭代器设计思维——STL 关键所在
不论是泛型思维或 STL 的实际运用，迭代器（ iterators）都扮演着重要的角色。
STL 的中心思想在于:将数据容器( containers）和算法（ algorithms）分开，彼此独立设计，最后再以一帖胶着剂将它们撮合在一起。
容器和算法的泛型化，从技术角度来看并不困难，C++的 class templates 和 function templates 可分别达成目标。如何设计出两者之间的良好胶着剂，才是大难题。

以下是容器、算法、迭代器（ iterator，扮演粘胶角色）的合作展示。以算法 find()为例，它接受两个迭代器和一个“搜寻目标”:
#+begin_src c++
template <class _InputIter, class _Predicate>
inline _InputIter find_if(_InputIter __first, _InputIter __last,
                          _Predicate __pred,
                          input_iterator_tag)
{
  while (__first != __last && !__pred(*__first))
    ++__first;
  return __first;
}
#+END_SRC
只要给予不同的迭代器,find()便能够对不同的容器进行查找操作.
#+begin_src c++
#include <vector>
#include <list>
#include <deque>
#include <algorithm>
#include <iostream>
using namespace std;

// 迭代器是㆒种行为类似指针的对象，对operator*和operator->进行重载

int main() {
    const int arraySize = 7;
    int ia[arraySize] = {0, 1, 2, 3, 4, 5, 6};

    vector<int> ivect(ia, ia + arraySize);
    list<int> ilist(ia, ia + arraySize);
    deque<int> ideque(ia, ia + arraySize);

    vector<int>::iterator it1 = find(ivect.begin(), ivect.end(), 4);
    if (it1!=ivect.end())
        cout << "4 not found." << endl;
    else
        cout << "4 found. " << *it1 << endl;

    list<int>::iterator it2 = find(ilist.begin(), ilist.end(), 6);
    if (it2!=ilist.end())
        cout << "6 not found." << endl;
    else
        cout << "6 found. " << *it2 << endl;

    deque<int>::iterator it3 = find(ideque.begin(), ideque.end(), 8);
    if (it3!=ideque.end())
        cout << "8 not found." << endl;
    else
        cout << "8 found. " << *it3 << endl;
}
#+END_SRC

*** 迭代器( iterator)是一种智能指针
迭代器是一种行为类似指针的对象,而指针的各种行为中最常见也最重要的便是内容提领(dereference）和成员访问( member access)，因此，迭代器最重要的编程工作就是对 operator*和 operator->进行重载（overloading）工作。

关于这一点，C++标准程序库有一个 auto_ptr 可供我们参考。
这是一个用来包装原生指针（native pointer)的对象.

现在我们来为 list（链表）设计一个迭代器 1。假设 list 及其节点的结构如下:
#+begin_src c++
template <typename T>
class List {
// 定义public以供访问
public:
    void insert_front(T value);
    void insert_end(T value);
    void display(std::ostream &os = std::cout) const;
    ListItem<T> * front() {
        return _front;
    }
    List();

private:
    ListItem<T> *_end;
    ListItem<T> *_front;
    long _size;
};

template <typename T>
class ListItem {
public:
    T value() const {
        return _value;
    }

    ListItem* next() const {
        return _next;
    }

    void set_next(ListItem* i) {
        _next = i;
    }

    ListItem(T value) : _value(value) {
        _next = NULL;
    }

private:
    T _value;
    ListItem *_next;
};
#+END_SRC
首先,我们需要为它设计一个仃类似指针的外衣，也就是一个迭代器。
当我们提领(dereference)这一迭代器时，专回的应该是个 Listrtem 对象:
当我们递增该迭代器时，它应该指向下一个 istrtem 对象。
为了让该迭代器适用于任何型态的节点，而不只限于 Listitem,戈们可以将它设计为一个 class template:
#+begin_src c++
// file: 3mylist-iter.h

// #include "3_2_mylist.h"

template <class Item>
struct ListIter {
    Item *ptr; // 保持与容器的联系

    // default ctor
    ListIter(Item* p =0) : ptr(p) {}

    // 解引用 dereference
    Item& operator*() const {
        return *ptr;
    }

    // member access
    Item* operator->() const {
        return ptr;
    }

    // prefix increment, 返回对象
    ListIter& operator++() {
        ptr = ptr->next();
        return *this;
    }

    // postfix increment, 返回值（新对象）
    // int为占位符，提示编译器这是后自增
    ListIter operator++(int) {
        ListIter temp = *this;
        ++*this; // 调用前面的前自增
        return temp;
    }

    bool operator==(const ListIter& i) const {
        return ptr == i.ptr;
    }

    bool operator!=(const ListIter& i) const {
        return ptr != i.ptr;
    }
};
#+END_SRC
现在可以将 List 和 find()借由 ListIter 粘合起来:
#+begin_src c++
// file: 3mylist-iter-test.cpp
#include "3_2_algorithm.h"
#include "3_2_mylist-iter.h"
#include "3_2_mylist.h"
using namespace std;



// 如果不写全局比较函数，则需要更改find函数判定
template <typename T> bool operator!=(const ListItem<T>& item, T n) { 
    return item.value() != n; 
} 

int main() {
    List<int> mylist;
    

    for (int i = 0; i < 5; ++i) {
        mylist.insert_front(i);
        mylist.insert_end(i + 2);
    }

    mylist.display();

    ListIter<ListItem<int>> begin(mylist.front());
    ListIter<ListItem<int>> end;
    ListIter<ListItem<int>> iter;
    iter = find(begin, end, 3);
    if (iter == end)
        cout << "not found" << endl;
    else
        cout << "found. " << iter->value() << endl;

    iter = find(begin, end, 7);
    if (iter == end)
        cout << "not found" << endl;
    else
        cout << "found. " << iter->value() << endl;
}
#+END_SRC
注意，由于 find ()函数内以*iter != value 来检查元素值是否吻合，本例之中 value 的型别是 int，iter 的型别是 Listrtem<int>，两者之间并可供使用的 operator !=，所以我必须另外写一个全局的 operator!=重载函娄并以 int 和 ListItem<int>作为它的两个参数型别.

为了完成一个针对 List 而设计的迭代器，我们无可避免曝露了太多 List 细节：
在 main()为了制作 begin 和 end 两个迭代器，我们曝露了 ListItem；
在 ListIter class 为了达成 operator++的目的，我们曝露了 ListItem 的操作函式 next()。
如果不是为了迭代器，ListItem 原本应该完全隐藏起来不曝光的。
换句话说，要设计出 ListIter，首先必须对 List 的细节有非常丰富的了解。
既然这无可避免，干脆就把迭代器的开发工作交给 List 的设计者好了，
如此一来所有细节反而得以封装起来不被使用者看到。
这正是为什么每一种  STL  容器都提供有专属迭代器的缘故。

*** 迭代器相应型别( associated types )
上述的 ListIter 提供了一个迭代器雏形。如果将思想拉得更高远-一些，我们便会发现，在算法中运用迭代器时，很可能会用到其相应型别( associated type) .
什么是相应型别?迭代器所指之物的型别便是其一。

假设算法中有必要声明一个变量,以“迭代器所指对象的型别”为型别,如何是好?毕竟 C++只支持 sizeof(),并未支持 typeof().
即便动用 RTTI 性质中的 typeid()，获得的也只是型别名称，不能拿来做变量声明之用。
解决办法是:利用 function template 的参数推导( argument deducation)机制。例如:


#+DOWNLOADED: screenshot @ 2023-08-05 16:08:25
[[file:images/c++/STL/2023-08-05_16-08-25_screenshot.png]]
我们以 func()为对外接口，却把实际操作全部置于 func_impl()之中。
由于 func_impl()是一个 function template,一旦被调用,编译器会自动进行 template 参数推导。
于是导出型别 T，顺利解决了问题。
迭代器相应型别( associated types）不只是“迭代器所指对象的型别”一种而已。
根据经验，最常用的相应型别有五种，然而并非任何情况下任何一种都可利用上述的 template 参数推导机制来取得.我们需要更全面的解法。

*** Traits 编程技法——STL 源代码门钥
迭代器所指对象的型别，称为该迭代器的 value type。上述的参数型别推导技巧虽然可用于 value type，却非全面可用:万一 value type 必须用于函数的传回值，就束手无策了，毕竟函数的“template 参数推导机制”推而导之的只是参数，无法推导函数的回返值型别。
我们需要其它方法。声明内嵌型别似乎是个好主意，像这样:

#+DOWNLOADED: screenshot @ 2023-08-05 16:20:30
[[file:images/c++/STL/2023-08-05_16-20-30_screenshot.png]]
注意，func()的回返型别必须加上关键词 typename，因为 T 是一个 template 参数，在它被编译器具现化之前，编译器对 T 一无所知，
换句话说，编译器此时并不知道 MyIter<T>::value_type 代表的是一个型别或是一个 member function 或是一个 data member。
关键词 typename 的用意在于告诉编译器这是一个型别，如此才能顺利通过编译。

看起来不错。但是有个隐晦的陷阱:并不是所有迭代器都是 class type。原生指针就不是!如果不是 class type，就无法为它定义内嵌型别。
但 STL(以及整个泛型思维）绝对必须接受原生指针作为一种迭代器，所以上面这样还不够。

有没有办法可以让上述的一般化概念针对特定情况（例如针对原生指针）做特殊化处理呢?
是的,template partial specialization 可以做到。

**** Partial Specialization（偏特化)的意义
大致的意义是:如果 class template 拥有一个以上的 template 参数，我们可以针对其中某个（或数个，但非全部)template 参数进行特化工作。
换句话说，我们可以在泛化设计中提供一个特化版本（也就是将泛化版本中的某些 template 参数赋予明确的指定）。

假设有一个 class template 如下:
#+begin_src c++
template<typename U, typename V, typename T>
class c { ... };
#+END_SRC
partial 
specialization 的字面意义容易误导我们以为，所谓“偏特化版”一定是对 template 参数 U 或 V 或 T(或某种组合)指定某个参数值.

其实不然,[Austern99]对于 partial specialization 的意义说得十分得体:“所谓 partial specialization 的意思是提供另一份 template 定义式，而其本身仍为 templatized”。
《泛型思维》一书对 partial specialization 的定义是:“针对（任何) template 参数更进一步的条件限制所设计出来的一个特化版本”。
由此，面对以下这么一个 class template:
#+begin_src c++
template<typename T>
class c { ... };//这个泛化版本允许（接受)T为任何型别
#+END_SRC
我们便很容易接受它有一个形式如下的 partial specialization:
#+begin_src c++
template<typename T>
class C<T*> { ... }; //这个特化版本仅适用于“T为原生指针”的情况
                     //T为原生指针”便是“T为任何型别”的-个更进一-步的条件限制
#+END_SRC
有了这项利器，我们便可以解决前述“内嵌型别”未能解决的问题。
先前的问题是，原生指针并非 class，因此无法为它们定义内嵌型别。现在，我们可以针对“迭代器之 template 参数为指针”者，设计特化版的迭代器。

下面这个 class template 专门用来“萃取”迭代器的特性，而 value type 正是迭代器的特性之一:
#+begin_src c++
template <class I>
struct iterator_traits { //traits 意为“特性”
  typedef typename I::value_type value_type;
};
#+END_SRC
这个所谓的 traits，其意义是，如果 I 定义有自己的 value type，那么通过这个 tralts 的作用，萃取出来的 value_type 就是 I::value_type。
换句话说，如果 I 定义有自己的 value type，先前那个 func()可以改写成这样:
#+begin_src c++
template <class I>
typename iterator_traitsc<I>::value type // 这一整行是函数回返型别
func(I ite)
{ return *ite; }
#+END_SRC
但这除了多一层间接性，又带来什么好处呢?好处是 traits 可以拥有特化版本。现在，我们令 iterator..traites 拥有一个 partial specializations 如下:
template <class T>
struct iterator_traits<T*> { l/偏特化版--迭代器是个原生指针 typedef  value..type;
} ;
于是,原生指针 int*︰虽然不是一种 class type,亦可通过 traits 取其 valuetype。这就解决了先前的问题。
但是请注意，针对“指向常数对象的指针( pointer-to-const) ”，下面这个式子得到什么结果:
iterator_traits<const int* > : : value_type
获得的是 const int 而非 int。这是我们期望的吗?我们希望利用这种机制来声明一个暂时变量，使其型别与迭代器的 value type 相同，而现在，声明一-个无法赋值（因 const 之故）的暂时变量，没什么用!因此，如果迭代器是个 pointer-to-const,我们应该设法令其 value type 为一个 non-const 型别.没问题，只要另外设计一个特化版本，就能解决这个问题:

* struct 和 class 的区别
struct 的默认访问级别为 public，而 class 的默认访问级别是 private。
* 数组


** 数组形参
数组有两个特殊性质:
- 不允许拷贝数组
- 使用数组时(通常)会将其转换为指针

由于不能拷贝数组,所以不能以值传递的方式使用数组参数.
因为数组会被转换为指针,所以当为函数传递一个数组时,实际上传递的是指向数组首元素的指针.

下面三个函数是等价的:
#+begin_src c++
  void print(const int*);
  void print(const int[]);
  void print(const int[10]);//这里的维度表示我们期望数组含有多少个元素,实际上编译器不会帮我们做检查

  int i=0,j[2]={0,1};
  print(&i);//正确,&i的类型是int*
  print(j);//正确,j转换为int*并指向j[0].数组的大小对函数的调用并没有影响
#+END_SRC
上面三个函数的唯一形参都是 const int*类型.
当编译器处理对 print 函数的调用时,只检查传入的参数是否是 const int*类型.

*** 管理数组形参大小的常用技术
**** 使用标记指定数组长度
这种方法要求数组本身包含一个结束标记.

典型例子是 C 语言风格字符串.
C 风格字符串在最后一个字符后面跟着一个空字符.
函数在处理 C 风格字符串时遇到空字符停止.
**** 使用标准库规范
这种方式指的是调用函数时同时传递数组首元素和尾后元素的指针.
#+begin_src c++
  void print(const int *beg,const int *end)
  {
    while(beg!=end)
      cout<<*beg++<<endl;//输出当前元素并将指针移动一个位置
  }
  int j[2]={0,1};
  print(begin(i),end(j));
#+END_SRC
**** 显示传递一个表示数组大小的形参
#+begin_src c++
  void print(const int ia[],size_t size)
  {
    for(size_t i=0;i!=size;++i){
      cout<<ia[i]<<endl;
    }
  }
  int j[]={0,1};
  print(j,end(j)-begin(j));
#+END_SRC
* 设计模式
** 设计原则
找出应用中可能需要变化之处,将它们独立出来,不要和那些不需要变化得代码混在一起.

针对接口编程(针对超类型编程),而不是针对实现编程.

多用组合,少用继承.

为了交互对象之间的松耦合设计而努力.
松耦合的设计将对象之间的互相依赖降到最低,让我们能够建立有弹性的 OO 系统应对变化.

类应该对扩展开放,对修改关闭.

依赖倒置原则:要依赖抽象,不要依赖具体类.高层组件(指的是比较抽象的组件)和底层组件都应该依赖于抽象.
避免违反依赖倒置原则的方法:
- 变量不可以持有具体类的引用
- 不要让类派生自具体类
- 不要覆盖基类中已实现的方法

最少知识原则:尽量减少对象之间的交互,不要让太多的类耦合在一起.
尽量不要调用从另一个调用中返回的对象的方法.
在任何对象的方法内,我们应该只调用属于以下范围的方法:
- 该对象本身
- 被当做方法的参数而传递进来的对象
- 此方法创建或实例化的任何对象
- 对象的任何组件

好莱坞原则:别调用(打电话给)我们,我们会调用(打电话给)你.
在好莱坞原则下,高层组件(我们)控制何时以及如何让低层组件参与工作,但低层组件(你)绝对不可以直接调用高层组件.

一个类应该只有一个
** 策略模式
策略模式定义了算法族,分别封装起来,让它们之间可以相互替换,此模式让算法独立于使用算法的客户.
*** 介绍
意图：定义一系列的算法,把它们一个个封装起来, 并且使它们可相互替换。

主要解决：在有多种算法相似的情况下，使用 if...else 所带来的复杂和难以维护。

何时使用：一个系统有许多许多类，而区分它们的只是他们直接的行为。

如何解决：将这些算法封装成一个一个的类，任意地替换。

关键代码：实现同一个接口。

应用实例： 1、诸葛亮的锦囊妙计，每一个锦囊就是一个策略。 2、旅行的出游方式，选择骑自行车、坐汽车，每一种旅行方式都是一个策略。 3、JAVA AWT 中的 LayoutManager。

优点： 1、算法可以自由切换。 2、避免使用多重条件判断。 3、扩展性良好。

缺点： 1、策略类会增多。 2、所有策略类都需要对外暴露。

使用场景： 1、如果在一个系统里面有许多类，它们之间的区别仅在于它们的行为，那么使用策略模式可以动态地让一个对象在许多行为中选择一种行为。 2、一个系统需要动态地在几种算法中选择一种。 3、如果一个对象有很多的行为，如果不用恰当的模式，这些行为就只好使用多重的条件选择语句来实现。

注意事项：如果一个系统的策略多于四个，就需要考虑使用混合模式，解决策略类膨胀的问题。
*** 实现
我们将创建一个定义活动的 Strategy 接口和实现了 Strategy 接口的实体策略类。Context 是一个使用了某种策略的类。

StrategyPatternDemo，我们的演示类使用 Context 和策略对象来演示 Context 在它所配置或使用的策略改变时的行为变化。
#+DOWNLOADED: screenshot @ 2023-05-18 23:08:10
[[file:images/c++/设计模式/2023-05-18_23-08-10_screenshot.png]]
步骤 1:
创建一个接口。

Strategy.java
#+begin_src java
public interface Strategy {
   public int doOperation(int num1, int num2);
}
#+end_src

步骤 2:
创建实现接口的实体类。

OperationAdd.java
#+begin_src java
public class OperationAdd implements Strategy{
   @Override
   public int doOperation(int num1, int num2) {
      return num1 + num2;
   }
}
#+end_src
OperationSubtract.java
#+begin_src java
public class OperationSubtract implements Strategy{
   @Override
   public int doOperation(int num1, int num2) {
      return num1 - num2;
   }
}
#+end_src
OperationMultiply.java
#+begin_src java
public class OperationMultiply implements Strategy{
   @Override
   public int doOperation(int num1, int num2) {
      return num1 * num2;
   }
}
#+end_src
步骤 3
创建 Context 类。

Context.java
#+begin_src java
public class Context {
   private Strategy strategy;
 
   public Context(Strategy strategy){
      this.strategy = strategy;
   }
 
   public int executeStrategy(int num1, int num2){
      return strategy.doOperation(num1, num2);
   }
}
#+end_src
步骤 4
使用 Context 来查看当它改变策略 Strategy 时的行为变化。

StrategyPatternDemo.java
#+begin_src java
public class StrategyPatternDemo {
   public static void main(String[] args) {
      Context context = new Context(new OperationAdd());    
      System.out.println("10 + 5 = " + context.executeStrategy(10, 5));
 
      context = new Context(new OperationSubtract());      
      System.out.println("10 - 5 = " + context.executeStrategy(10, 5));
 
      context = new Context(new OperationMultiply());    
      System.out.println("10 * 5 = " + context.executeStrategy(10, 5));
   }
}
#+end_src

步骤 5
执行程序，输出结果：
#+begin_example
10 + 5 = 15
10 - 5 = 5
10 * 5 = 50
#+end_example>
** 观察者模式
观察者模式定义了对象之间的一对多依赖,当一个对象改变状态时,所有的依赖着都会收到更新并自动更新.

观察者模式提供了一种对象设计,让主题和观察者之间松耦合.

#+begin_src java
  public interface Subject{
      private ArrayList observers;
      private float temperature;
      private float humidity;
      private float pressure;

      public WeatherData(){
          observers = new ArrayList();
      }

      public void registerObserver(Observer o){
          observers.add(o);
      }

      public void removeObserver(Observer o);{
          int i = observers.indexOf(o);
          if(i>=0){
              observers.remove(i);
          }
      }

      public void notifyObservers(){
          for(int i = 0;i < observers.size();i++){
              Observer observer = (Observer)observers.ger(i);
              observer.update(temperature,humidity,pressure);
          }
      }

      public void measurementsChanged(){
          notifyobservers();
      }
  }

  public interface Observer{
      public void update(float temp,float humidity,float pressure);
  }

  public interface DisplayElement{
      public void display();
  }
#+end_src
** 装饰着模式
装饰着模式动态地将责任附加到对象上,若要扩展功能,装饰者提供了比继承更有弹性的替代方案.

#+begin_src java
  //抽象组件
  public abstract class Beverage{
    String description = "Unknown Beverage";

    public String getDescription(){
        return description;
    }

    public abstract double cost(){};
  }

  //抽象装饰者
  public abstract class CondimentDecorator extends Beverage{ //调料
      public abstract String getDescription();
  }
  //具体组件
  public class Espresso extends Beverage{
      public Espresso(){
          description = "Espresso";
      }

      public double cost(){
          return 1.99;
      }
  }
  //具体组件
  public class HouseBlend extends Beverage{
      public Houseblend(){
          description = "House Blend Coffee";
      }

      public double cost(){
          return .89;
      }
  }
  public class DarkRoast extends Beverage{};

  //具体装饰者
  public class Mocha extends Condimentdecorator{
      Beverage beverage;

      public Mocha(Beverage beverage){
          this.beverage = beverage;
      }

      public String getDescription(){
          return beverage.getDescription() + ", Mocah";
      }

      public double cost(){
          return .20 + beverage.cost();
      }
  }
  public class Whip extends Condimentdecorator{};
  public class Soy extends Condimentdecorator{};
  //测试代码
  public class StarbuzzCoffee{
      Beverage beverage = new Espresso();
      Sysrem.out.println(beverage.getDescription() + " $" + beverage.cost());

      Beverage beverage2 = new DarkRoast();//新建一个DarkRoast对象
      bevarage2 = new Mocha(bevarage2);//用Mocha装饰它
      bevarage2 = new Mocha(bevarage2);//用第二个Mocha装饰
      bevarage2 = new Whip(bevarage2);//用Whip装饰它
      System.out.println(bevarage2.getDescription() + " $" + bevarage2.cost());

      Beverage beverage3 = new HouseBlend();
      bevarage3 = new Soy(bevarage3);
      bevarage3 = new Mocha(bevarage3);
      bevarage3 = new Whip(bevarage3);
      System.out.println(bevarage3.getDescription() + " $" + bevarage3.cost());
  }
#+END_SRC
** 工厂模式
工厂模式（Factory Pattern）是 Java 中最常用的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。

在工厂模式中，我们在创建对象时不会对客户端暴露创建逻辑，并且是通过使用一个共同的接口来指向新创建的对象。

工厂模式定义了一个创建对象的接口,但由子类决定要实例化的类是哪一个.工厂方法让类把实例化推迟到子类.
*** 介绍
意图：定义一个创建对象的接口，让其子类自己决定实例化哪一个工厂类，工厂模式使其创建过程延迟到子类进行。

主要解决：主要解决接口选择的问题。

何时使用：我们明确地计划不同条件下创建不同实例时。

如何解决：让其子类实现工厂接口，返回的也是一个抽象的产品。

关键代码：创建过程在其子类执行。

应用实例：
1、您需要一辆汽车，可以直接从工厂里面提货，而不用去管这辆汽车是怎么做出来的，以及这个汽车里面的具体实现。
2、Hibernate 换数据库只需换方言和驱动就可以。

优点： 1、一个调用者想创建一个对象，只要知道其名称就可以了。 2、扩展性高，如果想增加一个产品，只要扩展一个工厂类就可以。 3、屏蔽产品的具体实现，调用者只关心产品的接口。

缺点：每次增加一个产品时，都需要增加一个具体类和对象实现工厂，使得系统中类的个数成倍增加，在一定程度上增加了系统的复杂度，同时也增加了系统具体类的依赖。这并不是什么好事。

使用场景：
1、日志记录器：记录可能记录到本地硬盘、系统事件、远程服务器等，用户可以选择记录日志到什么地方。
2、数据库访问，当用户不知道最后系统采用哪一类数据库，以及数据库可能有变化时。 3、设计一个连接服务器的框架，需要三个协议，"POP3"、"IMAP"、"HTTP"，可以把这三个作为产品类，共同实现一个接口。

注意事项：作为一种创建类模式，在任何需要生成复杂对象的地方，都可以使用工厂方法模式。
有一点需要注意的地方就是复杂对象适合使用工厂模式，而简单对象，特别是只需要通过 new 就可以完成创建的对象，无需使用工厂模式。
如果使用工厂模式，就需要引入一个工厂类，会增加系统的复杂度。
*** 实现
我们将创建一个 Shape 接口和实现 Shape 接口的实体类。下一步是定义工厂类 ShapeFactory。

FactoryPatternDemo 类使用 ShapeFactory 来获取 Shape 对象。它将向 ShapeFactory 传递信息（CIRCLE / RECTANGLE / SQUARE），以便获取它所需对象的类型。

#+DOWNLOADED: screenshot @ 2023-05-24 22:43:46
[[file:images/c++/设计模式/2023-05-24_22-43-46_screenshot.png]]
步骤 1,
创建一个接口:

Shape.java
#+begin_src java
public interface Shape {
   void draw();
}
#+end_src>
步骤 2
创建实现接口的实体类。

Rectangle.java
#+begin_src java
public class Rectangle implements Shape {
 
   @Override
   public void draw() {
      System.out.println("Inside Rectangle::draw() method.");
   }
}
#+end_src
Square.java
#+begin_src java
public class Square implements Shape {
 
   @Override
   public void draw() {
      System.out.println("Inside Square::draw() method.");
   }
}
#+end_src
Circle.java
#+begin_src java
public class Circle implements Shape {
 
   @Override
   public void draw() {
      System.out.println("Inside Circle::draw() method.");
   }
}
#+end_src
步骤 3
创建一个工厂，生成基于给定信息的实体类的对象。

ShapeFactory.java
#+begin_src java
public class ShapeFactory {
   //使用 getShape 方法获取形状类型的对象
   public Shape getShape(String shapeType){
      if(shapeType == null){
         return null;
      }
      if(shapeType.equalsIgnoreCase("CIRCLE")){
         return new Circle();
      } else if(shapeType.equalsIgnoreCase("RECTANGLE")){
         return new Rectangle();
      } else if(shapeType.equalsIgnoreCase("SQUARE")){
         return new Square();
      }
      return null;
   }
}
#+end_src
步骤 4
使用该工厂，通过传递类型信息来获取实体类的对象。

FactoryPatternDemo.java
#+begin_src java
public class FactoryPatternDemo {

   public static void main(String[] args) {
      ShapeFactory shapeFactory = new ShapeFactory();

      //获取 Circle 的对象，并调用它的 draw 方法
      Shape shape1 = shapeFactory.getShape("CIRCLE");

      //调用 Circle 的 draw 方法
      shape1.draw();

      //获取 Rectangle 的对象，并调用它的 draw 方法
      Shape shape2 = shapeFactory.getShape("RECTANGLE");

      //调用 Rectangle 的 draw 方法
      shape2.draw();

      //获取 Square 的对象，并调用它的 draw 方法
      Shape shape3 = shapeFactory.getShape("SQUARE");

      //调用 Square 的 draw 方法
      shape3.draw();
   }
}
#+end_src
步骤 5
执行程序，输出结果：
#+begin_example
Inside Circle::draw() method.
Inside Rectangle::draw() method.
Inside Square::draw() method.
#+end_example
** 抽象工厂模式
抽象工厂模式（Abstract Factory Pattern）是围绕一个超级工厂创建其他工厂。
该超级工厂又称为其他工厂的工厂。
这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。

在抽象工厂模式中，接口是负责创建一个相关对象的工厂，不需要显式指定它们的类。每个生成的工厂都能按照工厂模式提供对象。

*** 介绍
意图：提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。

主要解决：主要解决接口选择的问题。

何时使用：系统的产品有多于一个的产品族，而系统只消费其中某一族的产品。

如何解决：在一个产品族里面，定义多个产品。

关键代码：在一个工厂里聚合多个同类产品。

应用实例：工作了，为了参加一些聚会，肯定有两套或多套衣服吧，比如说有商务装（成套，一系列具体产品）、时尚装（成套，一系列具体产品），甚至对于一个家庭来说，可能有商务女装、商务男装、时尚女装、时尚男装，这些也都是成套的，即一系列具体产品。假设一种情况（现实中是不存在的，但有利于说明抽象工厂模式），在您的家中，某一个衣柜（具体工厂）只能存放某一种这样的衣服（成套，一系列具体产品），每次拿这种成套的衣服时也自然要从这个衣柜中取出了。用 OOP 的思想去理解，所有的衣柜（具体工厂）都是衣柜类的（抽象工厂）某一个，而每一件成套的衣服又包括具体的上衣（某一具体产品），裤子（某一具体产品），这些具体的上衣其实也都是上衣（抽象产品），具体的裤子也都是裤子（另一个抽象产品）。

优点：当一个产品族中的多个对象被设计成一起工作时，它能保证客户端始终只使用同一个产品族中的对象。

缺点：产品族扩展非常困难，要增加一个系列的某一产品，既要在抽象的 Creator 里加代码，又要在具体的里面加代码。

使用场景： 1、QQ 换皮肤，一整套一起换。 2、生成不同操作系统的程序。

注意事项：产品族难扩展，产品等级易扩展。

*** 实现
我们将创建 Shape 和 Color 接口和实现这些接口的实体类。
下一步是创建抽象工厂类 AbstractFactory。
接着定义工厂类 ShapeFactory 和 ColorFactory，这两个工厂类都是扩展了 AbstractFactory。
然后创建一个工厂创造器/生成器类 FactoryProducer。

AbstractFactoryPatternDemo 类使用 FactoryProducer 来获取 AbstractFactory 对象。
它将向 AbstractFactory 传递形状信息 Shape（CIRCLE / RECTANGLE / SQUARE），以便获取它所需对象的类型。
同时它还向 AbstractFactory 传递颜色信息 Color（RED / GREEN / BLUE），以便获取它所需对象的类型。

#+DOWNLOADED: screenshot @ 2023-05-25 22:03:34
[[file:images/c++/设计模式/2023-05-25_22-03-34_screenshot.png]]
步骤 1
为形状创建一个接口。

Shape.java
#+begin_src java
public interface Shape {
   void draw();
}
#+end_src
步骤 2
创建实现接口的实体类。

Rectangle.java
#+begin_src java
public class Rectangle implements Shape {
 
   @Override
   public void draw() {
      System.out.println("Inside Rectangle::draw() method.");
   }
}
#+end_src
Square.java
#+begin_src java
public class Square implements Shape {
 
   @Override
   public void draw() {
      System.out.println("Inside Square::draw() method.");
   }
}
#+end_src
Circle.java
#+begin_src java
public class Circle implements Shape {
 
   @Override
   public void draw() {
      System.out.println("Inside Circle::draw() method.");
   }
}
#+end_src
步骤 3
为颜色创建一个接口。

Color.java
#+begin_src java
public interface Color {
   void fill();
}
#+end_src
步骤 4
创建实现接口的实体类。

Red.java
#+begin_src java
public class Red implements Color {
 
   @Override
   public void fill() {
      System.out.println("Inside Red::fill() method.");
   }
}
#+end_src
Green.java
#+begin_src java
public class Green implements Color {
 
   @Override
   public void fill() {
      System.out.println("Inside Green::fill() method.");
   }
}
#+end_src
Blue.java
#+begin_src java
public class Blue implements Color {
 
   @Override
   public void fill() {
      System.out.println("Inside Blue::fill() method.");
   }
}
#+end_src
步骤 5
为 Color 和 Shape 对象创建抽象类来获取工厂。

AbstractFactory.java
#+begin_src java
public abstract class AbstractFactory {
   public abstract Color getColor(String color);
   public abstract Shape getShape(String shape);
}
#+end_src
步骤 6
创建扩展了 AbstractFactory 的工厂类，基于给定的信息生成实体类的对象。

ShapeFactory.java
#+begin_src java
public class ShapeFactory extends AbstractFactory {
    
   @Override
   public Shape getShape(String shapeType){
      if(shapeType == null){
         return null;
      }        
      if(shapeType.equalsIgnoreCase("CIRCLE")){
         return new Circle();
      } else if(shapeType.equalsIgnoreCase("RECTANGLE")){
         return new Rectangle();
      } else if(shapeType.equalsIgnoreCase("SQUARE")){
         return new Square();
      }
      return null;
   }
   
   @Override
   public Color getColor(String color) {
      return null;
   }
}
#+end_src
ColorFactory.java
#+begin_src java
public class ColorFactory extends AbstractFactory {
    
   @Override
   public Shape getShape(String shapeType){
      return null;
   }
   
   @Override
   public Color getColor(String color) {
      if(color == null){
         return null;
      }        
      if(color.equalsIgnoreCase("RED")){
         return new Red();
      } else if(color.equalsIgnoreCase("GREEN")){
         return new Green();
      } else if(color.equalsIgnoreCase("BLUE")){
         return new Blue();
      }
      return null;
   }
}
#+end_src
步骤 7
创建一个工厂创造器/生成器类，通过传递形状或颜色信息来获取工厂。

FactoryProducer.java
#+begin_src java
public class FactoryProducer {
   public static AbstractFactory getFactory(String choice){
      if(choice.equalsIgnoreCase("SHAPE")){
         return new ShapeFactory();
      } else if(choice.equalsIgnoreCase("COLOR")){
         return new ColorFactory();
      }
      return null;
   }
}
#+end_src
步骤 8
使用 FactoryProducer 来获取 AbstractFactory，通过传递类型信息来获取实体类的对象。

AbstractFactoryPatternDemo.java
#+begin_src java
public class AbstractFactoryPatternDemo {
   public static void main(String[] args) {
 
      //获取形状工厂
      AbstractFactory shapeFactory = FactoryProducer.getFactory("SHAPE");
 
      //获取形状为 Circle 的对象
      Shape shape1 = shapeFactory.getShape("CIRCLE");
 
      //调用 Circle 的 draw 方法
      shape1.draw();
 
      //获取形状为 Rectangle 的对象
      Shape shape2 = shapeFactory.getShape("RECTANGLE");
 
      //调用 Rectangle 的 draw 方法
      shape2.draw();
      
      //获取形状为 Square 的对象
      Shape shape3 = shapeFactory.getShape("SQUARE");
 
      //调用 Square 的 draw 方法
      shape3.draw();
 
      //获取颜色工厂
      AbstractFactory colorFactory = FactoryProducer.getFactory("COLOR");
 
      //获取颜色为 Red 的对象
      Color color1 = colorFactory.getColor("RED");
 
      //调用 Red 的 fill 方法
      color1.fill();
 
      //获取颜色为 Green 的对象
      Color color2 = colorFactory.getColor("GREEN");
 
      //调用 Green 的 fill 方法
      color2.fill();
 
      //获取颜色为 Blue 的对象
      Color color3 = colorFactory.getColor("BLUE");
 
      //调用 Blue 的 fill 方法
      color3.fill();
   }
}
#+end_src
步骤 9
执行程序，输出结果：
#+begin_example
Inside Circle::draw() method.
Inside Rectangle::draw() method.
Inside Square::draw() method.
Inside Red::fill() method.
Inside Green::fill() method.
Inside Blue::fill() method.
#+end_example

** 单件模式
单件模式确保一个类只有一个实例,并提供一个全局访问点.

** 命令模式
命令模式将"请求"封装成对象,以便使用不同的请求\队列或者例子来参数化其它对象.命令模式也支持可撤销的操作.

#+DOWNLOADED: screenshot @ 2023-05-25 23:30:25
[[file:images/c++/设计模式/2023-05-25_23-30-25_screenshot.png]]

#+begin_src java
  public interface Command {
    public void execute();
  }

  public class LightOnCommand implements Command{
      Light light;

      public LightOnCommand(Light light){
          this.light = light;
      }

      public void execute(){
          light.on();
      }
  }

  public class SimpleRemoteControl{
      Command slot;

      public Simpleremotecontrol(){}

      public void setCommand(Command command){
          slot = command;
      }

      public void buttonWasPressed(){
          slot.execute();
      }
  }

  public class RemoteControlTest{
      public static void main(String[] args){
          Simpleremotecontrol remote = new Simpleremotecontrol();
          Light light = new Light();
          LightOncommand lightOn = new LightOncommand(light);

          remote.setCommand(lightOn);
          remote.buttonwaspressed();
      }
  }
#+end_src
** 适配器模式
适配器模式将一个类的接口,转换成客户期望的另一个接口.
** 外观模式
外观模式提供了一个统一的接口,用来访问子系统中的一群接口.外观定义了一个高层接口,让子系统更容易使用.
** 模板方法模式
模板方法定义了一个算法的步骤,并允许子类为一个或多个步骤提供实现.

模板方法模式在一个方法中定义一个算法的骨架,而将一些步骤延迟到子类中.模板方法使得子类可以在不改变算法结构的情况下,重新定义算法中的某些步骤.

当子类必须提供算法中的某个方法或步骤的实现时,则使用抽象方法;
如果算法中的某个步骤是可选的,就使用钩子让子类选择是否实现该步骤.

每一个具体的子类都必须定义所有的抽象方法,并未模板方法中未定义步骤提供完整的实现.

** 迭代器模式
迭代器模式提供一种方法顺序访问一个聚合对象中的各个元素,而又不暴露其内部的表示.
** 组合模式
组合模式允许将对象组合成树形结构来表现"整体/部分"层次结构.组合能让客户以一致的方式处理个别对象以及对象组合.
** 状态模式
状态模式允许对象在内部状态改变时改变它的行为,对象看起来好像修改了它的类.
状态模式将状态封装成独立的类,并将状态委托到当前状态的对象.

Contest(上下文)是一个类,它可以拥有一些内部状态.
State 接口定义了一个所有具体状态的共同接口,任何状态都实现这个相同的接口.这样一来,状态之间可以互相替换.
#+DOWNLOADED: screenshot @ 2023-05-29 23:21:43
[[file:images/c++/设计模式/2023-05-29_23-21-43_screenshot.png]]

* STL 容器底层数据结构总结
** vector
vector 是我们用到最多的数据结构，其底层数据结构是数组，由于数组的特点，vector 也具有以下特性：
1、O(1)时间的快速访问；
2、顺序存储，所以插入到非尾结点位置所需时间复杂度为 O(n)，删除也一样；
3、扩容规则：
当我们新建一个 vector 的时候，会首先分配给他一片连续的内存空间，如 std::vector<int> vec，当通过 push_back 向其中增加元素时，如果初始分配空间已满，就会引起 vector 扩容，其扩容规则在 gcc 下以 2 倍方式完成：
首先重新申请一个 2 倍大的内存空间；
然后将原空间的内容拷贝过来；
最后将原空间内容进行释放，将内存交还给操作系统；

测试代码如下：
#+BEGIN_SRC c++
#include<iostream>
#include<vector>
using namespace std;

void mycapacity(const vector<int>& vec)
{
    cout << "分配总空间大小为：" << vec.capacity() << endl;
}

void mysize(const vector<int>& vec)
{
    cout << "已用空间大小为：" << vec.size() << endl;
}

void myprint(const vector<int>& vec)
{
    for (int i = 0; i < vec.size(); ++i)
        cout << vec[i] << ",";
    cout << endl;
}


int main()
{
    vector<int> vec;
    cout << "起始状态：" << endl;
    mycapacity(vec);
    mysize(vec);
    cout << "========================" << endl;

    for (int i = 0; i < 10; ++i) {
        vec.push_back(i);
        cout << "压入第" << i+1 << "个元素之后：" << endl;
        myprint(vec);
        mycapacity(vec);
        mysize(vec);
        cout << "========================" << endl;
    }

    return 0;
}
#+END_SRC

#+DOWNLOADED: file:E:/org/图片/Snipaste_2021-04-11_10-52-03.png @ 2021-04-11 10:54:14
[[file:STL容器底层数据结构总结/2021-04-11_10-54-14_Snipaste_2021-04-11_10-52-03.png]]

从输出结果中的三个红色箭头可以看出 vector 的扩容规则。

4、注意事项：
根据 vector 的插入和删除特性，以及扩容规则，我们在使用 vector 的时候要注意，在插入位置和删除位置之后的所有迭代器和指针引用都会失效，同理，扩容之后的所有迭代器指针和引用也都会失效。
** map & multimap & unordered_map & unordered_multimap
*** map 与 multimap 底层数据结构
map 与 multimap 是 STL 中的关联容器、提供一对一 key-value 的数据处理能力； map 与 multimap 的区别在于，multimap 允许关键字重复，而 map 不允许重复。

这两个关联容器的底层数据结构均为红黑树,根据红黑树的原理，map 与 multimap 可以实现 O(lgn)的查找，插入和删除。
*** unordered_map 与 unordered_multimap 底层数据结构
unordered_map 与 unordered_multimap 对比 map 与 multimap 两种 map 在于 map 与 multimap 中的两个容器实现了以 key 为序排列，也就是说 map 与 multimap 为有序的。

而 unordered_map 与 unordered_multimap 中 key 为无序排列，其底层实现为 hash table，因此其查找时间复杂度理论上达到了 O(n)，之所以说理论上是因为在理想无碰撞的情况下，而真实情况未必如此。
** set & multiset & unordered_set & unordered_multiset
以上四种容器也都是关联容器，set 系与 map 系的区别在于 map 中存储的是<key-value>，而 set 可以理解为关键字即值，即只保存关键字的容器。
*** set & multiset 底层数据结构
set 与 multiset 有序存储元素，这两种容器的底层实现与 map 一样都是红黑树，所以能实现 O(lgn)的查找，插入，删除操作。

set 与 multiset 的区别在于是否允许重复；
*** unordered_set & unordered_multiset
与 unordered_map & unordered_multimap 相同，其底层实现为 hash table；
** priority_queue
priority_queue
优先级队列相当于一个有权值的单向队列 queue，在这个队列中，所有元素是按照优先级排列的。

priority_queue 根据堆的处理规则来调整元素之间的位置，根据堆的特性，优先级队列实现了取出最大最小元素时间复杂度为 O(1),对于插入和删除，其最坏情况为 O(lgn)。
** list
list 的底层数据结构为双向链表，特点是支持快速的增删。 
* STL 容器迭代器失效情况分析、总结
[[https://ivanzz1001.github.io/records/post/cplusplus/2018/03/14/cpluscplus_stl_iterator#31-%25E4%25BD%25BF%25E7%2594%25A8%25E8%25BF%25AD%25E4%25BB%25A3%25E5%2599%25A8%25E9%2581%258D%25E5%258E%2586%25E4%25B8%258D%25E5%2590%258C%25E7%259A%2584%25E5%25AE%25B9%25E5%2599%25A8][参考文献]]
** 迭代器失效
当使用一个容器的 insert 或者 erase 函数通过迭代器插入或删除元素可能会导致迭代器失效，因此我们为了避免危险，应该获取 insert 或者 erase 返回的迭代器，以便用重新获取的新的有效的迭代器进行正确的操作：
#+BEGIN_SRC c++
iter = vec.insert(iter);

iter = vec.erase(iter);
#+END_SRC
迭代器失效类型：
- 由于插入元素，使得容器元素整体迁移导致存放原容器元素的空间不再有效，从而使得指向原空间的迭代器失效；
- 由于删除元素，使得某些元素次序发生变化导致原本指向某元素的迭代器不再指向期望指向的元素。

*** vector 迭代器失效
- 当插入(push_back)一个元素后，end 操作返回的迭代器肯定失效；
- 当插入(push_back)一个元素后，如果 vector 的 capacity 发生了改变，则需要重新加载整个容器，此时 first 和 end 操作返回的迭代器都会失效；
- 当进行删除操作(erase,pop_back)后，指向删除点的迭代器全部失效，指向删除点后面的元素的迭代器也将全部失效；

参看如下示例：
#+BEGIN_SRC c++
#include <iostream>
#include <vector>
using namespace std;


int main(int argc, char *argv[])
{
	vector<int> vec;
	
	vec.push_back(100);
	vec.push_back(300);
	vec.push_back(400);
	vec.push_back(500);
	
	vector<int>::iterator iter;
	
	for(iter = vec.begin(); iter != vec.end(); iter++)
	{
		if(*iter == 300){
			iter = vec.erase(iter);			//此时iter指向400
			cout<<"next iter: " << *iter << endl;
		}
	}
	
	for(iter = vec.begin(); iter != vec.end(); iter++)
		cout<<*iter << "  ";
	
	cout<<endl;	
	return 0x0;
}
#+END_SRC
编译运行：
#+BEGIN_EXAMPLE
# gcc -o vector_iterator vector_iterator.cpp -lstdc++
# ./vector_iterator 
next iter: 400
100  400  500 
#+END_EXAMPLE

*** list 迭代器失效
- 插入操作(insert)和接合操作(splice)不会造成原有的 list 迭代器失效，这在 vector 中是不成立的，因为 vector 的插入操作可能造成记忆体重新配置，导致所有的迭代器全部失效；
- list 的删除操作(erase)也只有指向被删元素的那个迭代器失效，其他迭代器不受影响。（list 目前只发现这一种失效情况）
*** deque 迭代器失效
- 在 deque 容器首部或者尾部插入元素，不会使得任何迭代器失效；
注： 通过 vs2012 测试，不管前端插入还是后端插入，都会使迭代器失效
- 在 deque 容器的首部或者尾部删除元素，只会使指向被删元素的迭代器失效；
- 在 deque 容器的任何其他位置进行插入或删除操作都将使指向该容器元素的所有迭代器失效；
*** set 和 map 迭代器失效
与 list 相同，当对其进行 insert 或者 erase 操作时，操作之前的所有迭代器，在操作完成之后都依然有效，但被删除元素的迭代器失效。
** C++标准模板库(STL)迭代器的原理及实现
迭代器(iterator)是一种抽象的设计理念，通过迭代器可以在不了解容器内部原理的情况下遍历容器。除此之外，STL 中迭代器一个最重要的作用就是作为容器(vector、list 等)与 STL 算法的粘结剂，只要容器提供迭代器的接口，同一套算法代码可以利用在完全不同的容器中，这是抽象思想的经典应用。
*** 使用迭代器遍历不同的容器
如下所示的代码演示了迭代器是如何将容器和算法结合在一起的，其中使用了 3 种不同的容器，.begin()和.end()方法返回一个指向容器第一个元素和一个指向容器最后一个元素后面一个位置的迭代器，也就是说 begin()和 end()返回的迭代器是一个前闭后开的，一般用[begin, end) 表示。对于不同的容器，我们都使用同一个 accumulate()函数，原因就在于 acccumulate()函数的实现无需考虑容器的种类，只需要容器传入的 begin()和 end()迭代器能够完成标准迭代器的要求即可。
#+BEGIN_SRC c++
std::vector<int> vec{1,2,3};
std::list<int> lst{4,5,6};
std::deque<int> deq{7,8,9};

std::cout<<std::accumulate(vec.begin(), vec.end(), 0) << std::endl;
std::cout<<std::accumulate(lst.begin(), lst.end(), 0) << std::endl;
std::cout<<std::accumulate(deq.begin(), deq.end(), 0) << std::endl;
#+END_SRC
*** 迭代器的实现
迭代器的作用就是提供一个遍历容器内部所有元素的接口，因此迭代器的内部必须保存一个与容器相关联的指针，然后重载各种运算操作来方便遍历，其中最重要的就是* 运算符和-> 运算符，以及++、--等可能需要的运算符重载。实际上这和 C++标准库的智能指针(smart pointer)很像，智能指针也是将一个指针封装，然后通过引用计数或是其他方法完成自动释放内存的功能，为了达到和原有指针一样的功能，也需要对*、->等运算符进行重载。下面参照智能指针实现一个简单 vector 迭代器，其中几个 typedef 暂时不用管，我们后面会提到。vecIter 主要作用就是包裹一个指针，不同容器内部数据结构不相同，因此迭代器操作符重载的实现也会不同。比如++操作符。对于线性分配内存的数组来说，直接对指针执行++操作即可； 但是如果容器是 List 就需要采用元素内部的方法，比如 ptr->next()之类的方法访问下一个元素。因此，STL 容器都实现了自己的专属迭代器。

下面我们给出一个普通数组的迭代器的实现(array_iterator.cpp)：
#+BEGIN_SRC c++
#include <iostream>
#include <numeric>

template<class Item>
class vecIter{
	Item *ptr;
	
public:
	typedef std::forward_iterator_tag iterator_category;
	typedef Item value_type;
	typedef Item *pointer;
	typedef Item &reference;
	typedef std::ptrdiff_t difference_type;
	
public:
	vecIter(Item *p = 0):ptr(p){}
	
	Item & operator*() const{
		return *ptr;
	}
	
	Item * operator->() const{
		return ptr;
	}
	
	//pre
	vecIter &operator++(){
		++ptr;
		
		return *this;
	}
	
	vecIter operator++(int){
		vecIter tmp = *this;
		++*this;
		
		return tmp;
	}
	
	bool operator==(const vecIter &iter){
		return ptr == iter.ptr;
	}
	
	bool operator!=(const vecIter &iter){
		return !(*this == iter);
	}
};

int main(int argc, char *argv[])
{
	int a[] = {1,2,3,4};
	
	std::cout<<std::accumulate(vecIter<int>(a), vecIter<int>(a+4), 0)<<std::endl;
	
	return 0x0;
}
#+END_SRC
#+BEGIN_EXAMPLE
编译运行：

# gcc -o array_iterator array_iterator.cpp -lstdc++
# ./array_iterator 
10
#+END_EXAMPLE
*** 迭代器的相应型别
我们都知道 type_traits 可以萃取出类型的型别，根据不同的型别可以执行不同的处理流程。那么对于迭代器来说，是否有针对不同特性迭代器的优化方法呢？ 答案是肯定的。拿一个 STL 算法库中的 distance()函数来说，distance 函数接受两个迭代器参数，然后计算两者之间的距离。显然，对于不同的迭代器计算效率差别很大。比如对于 vector 容器来说，由于内存是连续分配的，因此指针直接相减即可获得两者的距离；而 list 容器是链表结构，内存一般都不是连续分配，因此只能通过一级一级调用 next()或者其他函数，每调用一次再判断迭代器是否相等来计算距离。vector 迭代器计算 distance 的效率为 O(1)，而 list 则为 O(n)，n为距离的大小。

因此，根据迭代器不同的特性，将迭代器分为 5 类：
- Input Iterator: 这种迭代器所指的对象为只读的
- Output Iterator: 所指的对象只能进行写入操作
- Forward Iterator: 该类迭代器可以在一个正确的区间中进行读写操作，它拥有 Input Iterator 的所有特性，和 Output Iterator 的部分特性，以及单步向前迭代元素的能力
- Bidirectional Iterator: 该类迭代器是在 Forward Iterator 的基础上提供了单步向后迭代元素的能力，从而使得可以双向移动
- Random Access Iterator： 前 4 种迭代器只提供部分指针算术能力（前 3 种支持++运算符，后一种还支持--运算符)，而本迭代器则支持所有指针的算术运算，包括 p+n、p-n、p[n]、p1-p2、p1<p2

上述 5 种迭代器的继承关系如下图所示：
#+DOWNLOADED: file:E:/org/图片/Snipaste_2021-04-11_14-30-22.png @ 2021-04-11 14:30:26
[[file:STL容器迭代器失效情况分析、总结/2021-04-11_14-30-26_Snipaste_2021-04-11_14-30-22.png]]
了解了迭代器的类型，我们就能解释 vector 的迭代器和 list 迭代器的区别了。显然，vector 迭代器具有所有指针算术运算能力，而 list 由于是双向链表，因此只有双向读写不能随机访问元素。故 vector 的迭代器种类为 Random Access Iterator，而 list 的迭代器种类为 Bidirectional Iterator。我们只需要根据不同的迭代器种类，利用 traits 编程技巧萃取出迭代器型别，然后由 C++重载机制就能够对不同型别的迭代器采用不同的处理流程了。为此，对于每个迭代器都必须定义型别 iterator_category，也就是上文代码中的 typedef std:forward_iterator_tag iterator_category，实际上可以直接继承 STL 中定义的 iterator 模板，模板后三个参数都有默认值，因此继承时只需要指定前两个模板参数即可。如下所示，STL 定义了 5 个空类型作为迭代器的标签：
#+BEGIN_SRC c++
template<class Category,class T,class Distance = ptrdiff_t,class Pointer=T*,class Reference=T&>
class iterator{
    typedef Category iterator_category;
    typedef T        value_type;
    typedef Distance difference_type;
    typedef Pointer  pointer;
    typedef Reference reference;
};

struct input_iterator_tag{};
struct output_iterator_tag{};
struct forward_iterator_tag:public input_iterator_tag{};
struct bidirectional_iterator_tag:public forward_iterator_tag{};
struct random_access_iterator_tag:public bidirectional_iterator_tag{};
#+END_SRC
*** 利用迭代器种类更有效的实现 distance 函数
回到 distance 函数，有了前面的基础，我们可以根据不同迭代器种类实现 distance 函数（distance.cpp)：
#+BEGIN_SRC c++
#include <iostream>
#include <vector>
#include <list>

# if 0
template <class _InputIterator, class _Distance>
inline void __distance(_InputIterator __first, _InputIterator __last,
                       _Distance& __n, std::input_iterator_tag)
{
  while (__first != __last) { ++__first; ++__n; }
}

template <class _RandomAccessIterator, class _Distance>
inline void __distance(_RandomAccessIterator __first, 
                       _RandomAccessIterator __last, 
                       _Distance& __n, std::random_access_iterator_tag)
{
  __n += __last - __first;
}

template <class _InputIterator, class _Distance>
inline void distance(_InputIterator __first, 
                     _InputIterator __last, _Distance& __n)
{
 typedef typename std::iterator_traits<_InputIterator>::iterator_category _Category;
  __distance(__first, __last, __n, _Category());
}
#else
//注： 这里需要放在一个新的namespace中，否则可能会与STL中的相冲突	
namespace DT{
template<class InputIterator>
inline typename std::iterator_traits<InputIterator>::difference_type distance(InputIterator first, InputIterator last){
	typedef typename std::iterator_traits<InputIterator>::iterator_category _Category;
	return __distance(first, last, _Category());
}
template<class InputIterator>
inline typename std::iterator_traits<InputIterator>::difference_type __distance(InputIterator first, InputIterator last, std::input_iterator_tag){
	typename std::iterator_traits<InputIterator>::difference_type n = 0;
	while (first != last){
		++first; ++n;
	}
	return n;
}

template<class InputIterator>
inline typename std::iterator_traits<InputIterator>::difference_type \
__distance(InputIterator first, InputIterator last, std::random_access_iterator_tag){
	return last - first;
}
}	
#endif


int main(int argc, char *argv[])
{

	int a[] = {1,2,3,4};
	std::vector<int> vec;
	vec.push_back(1);
	vec.push_back(2);
	vec.push_back(3);
	vec.push_back(4);
	
	std::list<int> lst;
	lst.push_back(1);
	lst.push_back(2);
	lst.push_back(3);
	lst.push_back(4);
	

	# if 0
		int vec_distance = 0, lst_distance = 0, carr_distance = 0;
		distance(vec.begin(), vec.end(), vec_distance);
		distance(lst.begin(), lst.end(), lst_distance);
		distance(a, a + sizeof(a)/sizeof(*a), carr_distance);
		
		std::cout<<"vec distance:"<<vec_distance<<std::endl;
		std::cout<<"lst distance:"<<lst_distance<<std::endl;
		std::cout<<"c-array distance:"<<carr_distance<<std::endl;
	#else
		std::cout<<"vec distance:"<<DT::distance(vec.begin(), vec.end())<<std::endl;
		std::cout<<"lst distance:"<<DT::distance(lst.begin(), lst.end())<<std::endl;
		std::cout<<"c-array distance:"<<DT::distance(a, a + sizeof(a)/sizeof(*a))<<std::endl;
	#endif
	
}
#+END_SRC
编译运行：
#+BEGIN_EXAMPLE
# gcc -o distance distance.cpp -lstdc++
# ./distance 
vec distance:4
lst distance:4
c-array distance:4
#+END_EXAMPLE
上面通过 STL 定义的 iterator_traits 模板可以萃取不同种类的迭代器特性，iterator_traits 还对指针和常量指针有特化版本，因此也可以萃取原生指针的特性。具体实现如下：
#+BEGIN_SRC c++
template <class _Tp, class _Distance> struct input_iterator {
  typedef input_iterator_tag iterator_category;
  typedef _Tp                value_type;
  typedef _Distance          difference_type;
  typedef _Tp*               pointer;
  typedef _Tp&               reference;
};

struct output_iterator {
  typedef output_iterator_tag iterator_category;
  typedef void                value_type;
  typedef void                difference_type;
  typedef void                pointer;
  typedef void                reference;
};

template <class _Tp, class _Distance> struct forward_iterator {
  typedef forward_iterator_tag iterator_category;
  typedef _Tp                  value_type;
  typedef _Distance            difference_type;
  typedef _Tp*                 pointer;
  typedef _Tp&                 reference;
};


template <class _Tp, class _Distance> struct bidirectional_iterator {
  typedef bidirectional_iterator_tag iterator_category;
  typedef _Tp                        value_type;
  typedef _Distance                  difference_type;
  typedef _Tp*                       pointer;
  typedef _Tp&                       reference;
};

template <class _Tp, class _Distance> struct random_access_iterator {
  typedef random_access_iterator_tag iterator_category;
  typedef _Tp                        value_type;
  typedef _Distance                  difference_type;
  typedef _Tp*                       pointer;
  typedef _Tp&                       reference;
};

template <class _Iterator>
struct iterator_traits {
  typedef typename _Iterator::iterator_category iterator_category;
  typedef typename _Iterator::value_type        value_type;
  typedef typename _Iterator::difference_type   difference_type;
  typedef typename _Iterator::pointer           pointer;
  typedef typename _Iterator::reference         reference;
};

template <class _Tp>
struct iterator_traits<_Tp*> {
  typedef random_access_iterator_tag iterator_category;
  typedef _Tp                         value_type;
  typedef ptrdiff_t                   difference_type;
  typedef _Tp*                        pointer;
  typedef _Tp&                        reference;
};

template <class _Tp>
struct iterator_traits<const _Tp*> {
  typedef random_access_iterator_tag iterator_category;
  typedef _Tp                         value_type;
  typedef ptrdiff_t                   difference_type;
  typedef const _Tp*                  pointer;
  typedef const _Tp&                  reference;
};
#+END_SRC

*** 3.5 小结
STL 使用迭代器算法和容器结合，利用迭代器型别可以针对不同迭代器编写更加高效的算法，这一点很重要的思想就是： 利用 C++重载机制和参数推导机制将运行期决议问题提前到编译期决议，也就是说，我们不需要在运行时判断迭代器的类型，而是在编译期就已经决定。这很符合 C++模板编程的理念。在后续 STL 学习中，我们会实现自己的各种容器，也必须实现各种各样的迭代器，因此迭代器的学习还远没有停止。
** C++中模板使用时候 typename 和 class 的区别
在 C++ Template 中很多地方都用到了 typename 与 class 这两个关键字，而且好像可以替换，是不是这两个关键字完全一样呢？ 相信学习 C++的人对 class 这个关键字都非常明白，class 用于定义类，在 C++中引入模板后，最初定义模板的方法为：
#+BEGIN_EXAMPLE
template<class T>....
#+END_EXAMPLE
在这里 class 关键字表明 T 是一个类型，后来为了避免 class 在这两个地方的使用可能给人带来混淆，所以引入 typename 这个关键字，它的作用同 class 一样表明后面的符号为一个类型，这样在定义模板的时候就可以使用下面的方式了：
#+BEGIN_EXAMPLE
template<typename T>...
#+END_EXAMPLE
在模板定义语法中关键字 class 与 typename 的作用完全一样。

typename 难道仅仅在模板定义中起作用吗？ 其实不是这样，typename 另外一个作用为： 使用嵌套依赖类型(nested depended name), 如下所示
#+BEGIN_SRC c++
class MyArray{
public:
	typedef int LengthType;
	....
};

template<class T>
void MyMethod(T myarr){
	typedef typename T::LengthType LengthType;
	LengthType length = myarr.GetLength();
}
#+END_SRC
这个时候 typename 的作用就是告诉 C++编译器，typename 后面的字符串为一个类型名称，而不是成员函数或者成员变量。这个时候如果前面没有 typename，编译器没有任何办法知道 T::LengthType 是一个类型还是一个成员名称(静态数据成员或者静态函数），所以编译不能够通过。
* set 自定义去重和排序函数
** 方法一：使用 std::set 内置的 less 比较函数（直接定义内置类型的 set 对象）

这种方法适用于：1）比较 int、char 等内置类型。2）只能针对某一个内置类型去重和排序：如果想通过 id（int）去重，并通过 hot(int)排序，该种方法就束手无策了。代码如下：
#+BEGIN_SRC c++
#include <iostream>
#include <set>
using namespace std;
void main()
{
    std::set<int> mySet;    // 直接定义内置类型set集合
    mySet.insert(10);       // 默认比较函数为less
    mySet.insert(20);       // 从小到大排序
    for(auto it:mySet)
    {
        std::cout<<it<<std::endl;
    }
    std::cout<<"end"<<std::endl;

}
#+END_SRC
#+BEGIN_EXAMPLE
结果如下：
output：
            10
            20
            end
#+END_EXAMPLE

** 方法二：自定义类（结构体）比较函数

前文提到：直接定义内置类型的 set 对象，即使用 std::set 内置的默认的 less 比较函数，可能不能满足我们的实际需求。例如：现在有一批结构体对象，需要将其插入 set 集合，并按照 id 去重，按照热度 hot 进行排序。这个时候，就需要重新自定义比较函数了。有两种方法可以自定义比较函数：
*** 重载<操作符
甚么要重载<运算符呢？能不能重载"<="或者">="运算符？答案是不可以。几乎所有的方法或容器都需要排序来满足数学意义上的标准严格弱序化，否则这些方法或容器的行为将不可预知。假设 f(x,y)是一个比较函数。 如果该函数满足如下条件则它是严格弱序化的。
1. f(x,x) = false; 
2. if f(x,y) then !f(y,x)
3. if f(x,y) and f(y,z) then f(x,z)
4. if !f(x,y)&&!f(y,x) then x==y; if x==y and y==z then x==z;

看上去有点晕乎，不过不用担心，只要你的比较方法能够满足对相等元素永远返回 false（记住一个准则：永远让比较函数对相同元素返回 false），那你的方法就满足要求了。

其实，set 容器在判定已有元素 a 和新插入元素 b 是否相等时，是这么做的：
1. 将 a 作为左操作数，b作为有操作数，调用比较函数，并返回比较值  
2. 将 b 作为左操作数，a作为有操作数，再调用一次比较函数，并返回比较值。如果 1、2 两步的返回值都是 false，则认为 a、b 是相等的，则 b 不会被插入 set 容器中；

如果 1、2 两步的返回值都是 true，则可能发生未知行为，因此，记住一个准则：永远让比较函数对相同元素返回 false。
#+BEGIN_SRC c++
#include <iostream>
#include <set>
using namespace std;
struct song
{
    int m_id;
    int m_hot;
    song(int id,int hot)
    {

        this->m_id = id;
        this->m_hot = hot;
    }
    bool operator<(const struct song & right)const   //重载<运算符
    {
        if(this->m_id == right.m_id)     //根据id去重
            return false;
        else
        {
            if(this->m_hot != right.m_hot)
            {
                return this->m_hot > right.m_hot;      //降序
            }
            else
            {
                return this->m_id > right.m_id;     
            }
        }
    }
};
void main()
{
    std::set<song> mySet;
    song s1(10,100);
    song s2(20,200);
    song s3(20,300);
    song s4(30,200);
    mySet.insert(s1);    //插入s1
    mySet.insert(s2);    //插入s2
    mySet.insert(s3);    //s3和s2的id相同，不插入
    mySet.insert(s4);    //插入s4
    for(auto it:mySet)
    {
        std::cout<<"id:"<<it.m_id<<",hot:"<<it.m_hot<<std::endl;
    }
    std::cout<<"end"<<std::endl;
;}
#+END_SRC
#+BEGIN_EXAMPLE
结果如下：
id：30，hot ： 200
id：20，hot ： 200
id：10，hot ： 100
end
#+END_EXAMPLE
*** 重载（）运算符
具体代码如下：
#+BEGIN_SRC c++
#include <iostream>
#include <set>
using namespace std;
struct song
{
    int m_id;
    int m_hot;
    song(int id,int hot)
    {

        this->m_id = id;
        this->m_hot = hot;
    }
    /*
    bool operator<(const struct song & right)const   //重载<运算符
    {
        if(this->m_id == right.m_id)     //根据id去重
            return false;
        else
        {
            if(this->m_hot != right.m_hot)
            {
                return this->m_hot > right.m_hot;      //降序
            }
            else
            {
                return this->m_id > right.m_id;
            }
        }
    }
    */
};
struct comp
{
    bool operator()(struct song left,struct song  right)  //重载（）运算符
    {

        if(left.m_id == right.m_id)     //根据id去重
            return false;
        else
        {
            if(left.m_hot != right.m_hot)
            {
                return left.m_hot > right.m_hot;      //降序
            }
            else
            {
                return left.m_id > right.m_id;
            }

        }
    }

};
void main()
{
    std::set<song,comp> mySet;      //写法和2.1中的的区别
    song s1(10,100);
    song s2(20,200);
    song s3(20,300);
    song s4(30,200);
    mySet.insert(s1);    //插入s1
    mySet.insert(s2);    //插入s2
    mySet.insert(s3);    //s3和s2的id相同，不插入
    mySet.insert(s4);    //插入s4
    for(auto it:mySet)
    {
        std::cout<<"id:"<<it.m_id<<",hot:"<<it.m_hot<<std::endl;
    }
    std::cout<<"end"<<std::endl;
};
#+END_SRC
#+BEGIN_EXAMPLE
结果如下：
id：30，hot ： 200
id：20，hot ： 200
id：10，hot ： 100
end
#+END_EXAMPLE
* SFML
SFML 是多媒体库，它为 PC 的各个组件提供简单的界面，用来简化游戏和多媒体应用程序的开发。 主要由五个模块组成，分别是：系统，窗口，图形，音频和网络。

SFML 是跨平台的，通过 SFML，你的应用程序可以在最常见的操作系统上进行编译和运行：Windows，Linux，macOS 以及 Android 和 iOS。

SFML 支持多种语言，具体可以在官网查看支持的语言。
* std
** 介绍
std::是个名称空间标识符，C++标准库中的函数或者对象都是在命名空间 std 中定义的，所以我们要使用标准库中的函数或者对象都要用 std 来限定。

至于为什么将 cout 放到名字空间 std 中，是因为象 cout 这样的对象在实际操作中或许会有好多个，比如说你自己也可能会不小心定义一个对象叫 cout，那么这两个 cout 对象就会产生冲突。


一般来说，std 都是要调用 C++标准库时使用。比如：使用标准库文件 iostream 时，要写上 std;使用非标准库文件 iostream.h，不用写。如图引入非标准库 iostream.h 时，省去了 std::
#+BEGIN_SRC c++
#include <iostream.h>
#+END_SRC

当然使用标准库时，也是可以省略的，不过需要进行处理

1. 分别将 cout 和 endl 释放出来
#+BEGIN_SRC c++
#include <iostream>
using std::cout;
using std::endl;
#+END_SRC

2. 将命名空间释放出来

注：using namespace std 告诉编辑器我们将要使用名字空间 std 中的函数或者对象，所以 cout 和 endl 前面不用注明他们是 std 这个名字空间中的 cout 和 endl
#+BEGIN_SRC c++
#include <iostream>
using namespace std;
#+END_SRC

** accumulate
accumulate 定义在#include<numeric>中，作用有两个，一个是累加求和，另一个是自定义类型数据的处理

1. 累加求和
~int sum = accumulate(vec.begin() , vec.end() , 42);~

accumulate 带有三个形参：头两个形参指定要累加的元素范围，第三个形参则是累加的初值。

accumulate 函数将它的一个内部变量设置为指定的初始值，然后在此初值上累加输入范围内所有元素的值。accumulate 算法返回累加的结果，其返回类型就是其第三个实参的类型。

可以使用 accumulate 把 string 型的 vector 容器中的元素连接起来：

~string sum = accumulate(v.begin() , v.end() , string(" "));~

这个函数调用的效果是：从空字符串开始，把 vec 里的每个元素连接成一个字符串。

2. 自定义数据类型的处理

C++ STL 中有一个通用的数值类型计算函数— accumulate(),可以用来直接计算数组或者容器中 C++内置数据类型，例如：
#+BEGIN_SRC c++
#include <numeric>  
int arr[]={10,20,30,40,50};  
vector<int> va(&arr[0],&arr[5]);  
int sum=accumulate(va.begin(),va.end(),0);  //sum = 150  
#+END_SRC
但是对于自定义数据类型，我们就需要自己动手写一个回调函数来实现自定义数据的处理，然后让它作为 accumulate()的第四个参数，accumulate()的原型为
#+BEGIN_SRC c++
template<class _InIt, class _Ty,  class _Fn2> 
inline _Ty _Accumulate(_InIt _First, _InIt _Last, _Ty _Val, _Fn2 _Func)  
{   // return sum of _Val and all in [_First, _Last), using _Func  
    for (; _First != _Last; ++_First)  
        _Val = _Func(_Val, *_First);  
    return (_Val);  
}
#+END_SRC
下面是例子：
#+BEGIN_SRC c++

#include <vector>  
#include <string>  
using namespace std;  
  
struct Grade  
{  
    string name;  
    int grade;  
};  
  
int main()  
{  
    Grade subject[3] = {  
        { "English", 80 },  
        { "Biology", 70 },  
        { "History", 90 }  
    };  
  
    int sum = accumulate(subject, subject + 3, 0, [](int a, Grade b){return a + b.grade; });  
    cout << sum << endl;  
  
    system("pause");  
    return 0;  
} 
#+END_SRC
** all_of
all_of() 算法会返回 true，前提是序列中的所有元素都可以使谓词返回 true。

*** 实例
下面是一段代码，用来展示用 all_of() 检查 ages 容器中的元素： 
#+BEGIN_SRC c++
int good_age{100};
std::cout << (std::all_of(std::begin(ages), std::end(ages),[good_age] (int age) { return age < good_age; }) ? "None": "Some") << " of the people are centenarians." << std::endl;
#+END_SRC
这个 lambda 表达式会将 ages 中的元素和 good_age 的值作比较，good_age 的值为 100。所有的元素都小于 100，所以 all_of() 会返回 true，而且输出消息会正确报告没有记录的百岁老人。
** bind
std::bind 的头文件是 <functional>，它是一个函数适配器，接受一个可调用对象（callable object），生成一个新的可调用对象来“适应”原对象的参数列表。
*** 函数原型
std::bind 函数有两种函数原型，定义如下：
#+begin_src c++
template< class F, class... Args >
/*unspecified*/ bind( F&& f, Args&&... args );

template< class R, class F, class... Args >
/*unspecified*/ bind( F&& f, Args&&... args );
#+END_SRC
std::bind 返回一个基于 f 的函数对象，其参数被绑定到 args 上。
f 的参数要么被绑定到值，要么被绑定到 placeholders（占位符，如_1, _2, ..., _n）。

std::bind 将可调用对象与其参数一起进行绑定，绑定后的结果可以使用 std::function 保存。

std::bind 主要有以下两个作用：
- 将可调用对象和其参数绑定成一个仿函数；
- 只绑定部分参数，减少可调用对象传入的参数。
*** std::bind 绑定普通函数
#+begin_src c++
double callableFunc (double x, double y) {return x/y;}
auto NewCallable = std::bind (callableFunc, std::placeholders::_1,2);
std::cout << NewCallable (10) << '\n';
#+END_SRC
bind 的第一个参数是函数名，普通函数做实参时，会隐式转换成函数指针。因此 std::bind(callableFunc,_1,2)等价于 std::bind (&callableFunc,_1,2)；

_1 表示占位符，位于<functional>中，std::placeholders::_1；

第一个参数被占位符占用，表示这个参数以调用时传入的参数为准，在这里调用 NewCallable 时，给它传入了 10，其实就想到于调用 callableFunc(10,2);
*** std::bind 绑定一个成员函数
#+begin_src c++
class Base
{
public:
    void display_sum(int a1, int a2)
    {
        std::cout << a1 + a2 << '\n';
    }

    int m_data = 30;
};
int main()
{
    Base base;
    auto newiFunc = std::bind(&Base::display_sum, &base, 100, std::placeholders::_1);
    f(20); // should out put 120.
}

#+END_SRC
bind 绑定类成员函数时，第一个参数表示对象的成员函数的指针，第二个参数表示对象的地址。

必须显式地指定&Base::diplay_sum，因为编译器不会将对象的成员函数隐式转换成函数指针，所以必须在 Base::display_sum 前添加&；

使用对象成员函数的指针时，必须要知道该指针属于哪个对象，因此第二个参数为对象的地址 &base；
*** 绑定一个引用参数
默认情况下，bind 的那些不是占位符的参数被拷贝到 bind 返回的可调用对象中。但是，与 lambda 类似，有时对有些绑定的参数希望以引用的方式传递，或是要绑定参数的类型无法拷贝。
#+begin_src c++
#include <iostream>
#include <functional>
#include <vector>
#include <algorithm>
#include <sstream>
using namespace std::placeholders;
using namespace std;

ostream & printInfo(ostream &os, const string& s, char c)
{
    os << s << c;
    return os;
}

int main()
{
    vector<string> words{"welcome", "to", "C++11"};
    ostringstream os;
    char c = ' ';
    for_each(words.begin(), words.end(),
                   [&os, c](const string & s){os << s << c;} );
    cout << os.str() << endl;

    ostringstream os1;
    // ostream不能拷贝，若希望传递给bind一个对象，
    // 而不拷贝它，就必须使用标准库提供的ref函数
    for_each(words.begin(), words.end(),
                   bind(printInfo, ref(os1), _1, c));
    cout << os1.str() << endl;
}

#+END_SRC
** hex
Sets the basefield format flag for the str stream to hex.

When basefield is set to hex, integer values inserted into the stream are expressed in hexadecimal base (i.e., radix 16). For input streams, extracted values are also expected to be expressed in hexadecimal base when this flag is set.

The basefield format flag can take any of the following values (each with its own manipulator):

| flag value | effect when set                                          |
|------------+----------------------------------------------------------|
| dec        | read/write integer values using decimal base format.     |
| hex        | read/write integer values using hexadecimal base format. |
| oct        | read/write integer values using octal base format.       |

example:
#+BEGIN_SRC c++
// modify basefield
#include <iostream>     // std::cout, std::dec, std::hex, std::oct

int main () {
  int n = 70;
  std::cout << std::dec << n << '\n';
  std::cout << std::hex << n << '\n';
  std::cout << std::oct << n << '\n';
  return 0;
}
#+END_SRC
#+BEGIN_EXAMPLE
Output:
70
46
106

#+END_EXAMPLE
** transform
transform 函数的作用是：将某操作应用于指定范围的每个元素。transform 函数有两个重载版本：

transform(first,last,result,op);//first 是容器的首迭代器，last 为容器的末迭代器，result 为存放结果的容器，op 为要进行操作的一元函数对象或 sturct、class。

transform(first1,last1,first2,result,binary_op);//first1 是第一个容器的首迭代 器，last1 为第一个容器的末迭代器，first2 为第二个容器的首迭代器，result 为存放结果的容器，binary_op 为要进行操作的二元函数 对象或 sturct、class。

注意：第二个重载版本必须要保证两个容器的元素个数相等才行，否则会抛出异常
*** 例子
看一个例子：利用 transform 函数将一个给定的字符串中的小写字母改写成大写字母，并将结果保存在一个叫 second 的数组里，原字符串内容不变。
我们只需要使用 transform 的第一个重载函数，当然我们也可以使用 for_each 函数来完成再 copy 几次就行了，现在来看一下代码：
#+BEGIN_SRC c++
#include <iostream>
#include <algorithm>
using namespace std;
char op(char ch)
{

   if(ch>='A'&&ch<='Z')
        return ch+32;
    else
        return ch;
}
int main()
{
    string first,second;
    cin>>first;
    second.resize(first.size());
    transform(first.begin(),first.end(),second.begin(),op);
    cout<<second<<endl;
    return 0;
}
#+END_SRC

再看一个例子：给你两个 vector 向量（元素个数相等），请你利用 transform 函数将两个 vector 的每个元素相乘，并输出相乘的结果。
代码：
foreach 的用法
#+BEGIN_SRC c++
#include <iostream>
#include <algorithm>
#include <vector>
using namespace std;
void print(int &elem){cout<<elem<<" ";}
int op(int a,int b){return a*b;}
int main()
{
    vector <int> A,B,SUM;
    int n;
    cin>>n;
    for(int i=0;i<n;i++)
    {
        int t;
        cin>>t;
        A.push_back(t);
    }
    for(int i=0;i<n;i++)
    {
        int t;
        cin>>t;
        B.push_back(t);
    }
    SUM.resize(n);
    transform(A.begin(),A.end(),B.begin(),SUM.begin(),op);
    for_each(SUM.begin(),SUM.end(),print);
    return 0;
}
#+END_SRC
** to_string
* typedef
** 定义类型

* typeid
typeid 可以返回数据类型。

语法
#+begin_src cpp
#include <typeinfo>

typeid ( type );
typeid ( expression );
#+end_src

** 例子
#+begin_src cpp
  // C++ program to show the use of typeid operator

#include <iostream>
#include <typeinfo>
using namespace std;

int main()
{
    int i, j;
    char c;

    // Get the type info using typeid operator
    const type_info& ti1 = typeid(i);
    const type_info& ti2 = typeid(j);
    const type_info& ti3 = typeid(c);

    // Check if both types are same
    if (ti1 == ti2)
        cout << "i and j are of"
             << " similar type" << endl;
    else
        cout << "i and j are of"
             << " different type" << endl;

    // Check if both types are same
    if (ti2 == ti3)
        cout << "j and c are of"
             << " similar type" << endl;
    else
        cout << "j and c are of"
             << " different type" << endl;

    return 0;
}
#+end_src
Output
#+begin_example
i and j are of similar type
j and c are of different type
#+end_example
#+begin_src cpp
// C++ program to show the use of typeid operator

#include <iostream>
#include <typeinfo>
using namespace std;

int main()
{
    int i = 5;
    float j = 1.0;
    char c = 'a';

    // Get the type info using typeid operator
    const type_info& ti1 = typeid(i * j);
    const type_info& ti2 = typeid(i * c);
    const type_info& ti3 = typeid(c);

    // Print the types
    cout << "ti1 is of type "
         << ti1.name() << endl;

    cout << "ti2 is of type "
         << ti2.name() << endl;

    cout << "ti3 is of type "
         << ti3.name() << endl;

    return 0;
}
#+end_src
Output:
#+begin_example
ti1 is of type f
ti2 is of type i
ti3 is of type c
#+end_example

* vector
** 初始化
vector<int> ilist1;

默认初始化，vector 为空， size 为 0，表明容器中没有元素，而且 capacity 也返回 0，意味着还没有分配内存空间。这种初始化方式适用于元素个数未知，需要在程序中动态添加的情况。

vector<int> ilist2(ilist);

vector<int> ilist2  = ilist; 

两种方式等价 ，ilist2 初始化为 ilist 的拷贝，ilist 必须与 ilist2 类型相同，也就是同为 int 的 vector 类型，ilist2 将具有和 ilist 相同的容量和元素

vector<int> ilist = {1,2,3.0,4,5,6,7};

vector<int> ilist {1,2,3.0,4,5,6,7};

ilist 初始化为列表中元素的拷贝，列表中元素必须与 ilist 的元素类型相容，本例中必须是与整数类型相容的类型，整形会直接拷贝，其他类型会进行类型转换。

vector<int> ilist3(ilist.begin()+2,ilist.end()-1);

ilist3 初始化为两个迭代器指定范围中元素的拷贝，范围中的元素类型必须与 ilist3 的元素类型相容，在本例中 ilist3 被初始化为{3,4,5,6}。注意：由于只要求范围中的元素类型与待初始化的容器的元素类型相容，因此迭代器来自不同的容器是可能的，例如，用一个 double 的 list 的范围来初始化 ilist3 是可行的。另外由于构造函数只是读取范围中的元素进行拷贝，因此使用普通迭代器还是 const 迭代器来指出范围并没有区别。这种初始化方法特别适合于获取一个序列的子序列。

vector<int> ilist4(7);

默认值初始化，ilist4 中将包含 7 个元素，每个元素进行缺省的值初始化，对于 int，也就是被赋值为 0，因此 ilist4 被初始化为包含 7 个 0。当程序运行初期元素大致数量可预知，而元素的值需要动态获取的时候，可采用这种初始化方式。

vector<int> ilist5(7,3);

指定值初始化，ilist5 被初始化为包含 7 个值为 3 的 int
* volatile
** 为什么要用 volatile？
volatile 关键字是一种类型修饰符，用它声明的类型变量表示可以被某些编译器未知的因素更改。比如：操作系统、硬件或者其它线程等。遇到这个关键字声明的变量，编译器对访问该变量的代码就不再进行优化，从而可以提供对特殊地址的稳定访问。

声明时语法：volatile int vInt;

当要求使用 volatile 声明的变量的值的时候，系统总是重新从它所在的内存读取数据，即使它前面的指令刚刚从该处读取过数据。例如：
#+begin_src c++
volatile int i=10;
int a = i;
int b = i; 
#+END_SRC
volatile 指出 i 是随时可能发生变化的，每次使用它的时候必须从 i 的地址中读取，因而编译器生成的汇编代码会重新从 i 的地址读取数据放在 b 中。而优化做法是，由于编译器发现两次从 i 读数据的代码之间的代码没有对 i 进行过操作，它会自动把上次读的数据放在 b 中。而不是重新从 i 里面读。这样以来，如果 i 是一个寄存器变量或者表示一个端口数据就容易出错，所以说 volatile 可以保证对特殊地址的稳定访问。

下面通过插入汇编代码，测试有无 volatile 关键字，对程序最终代码的影响：
#+begin_src c++
#include <stdio.h>
void main()
{
    int i = 10;
    int a = i;

    printf("i = %d", a);

    // 下面汇编语句的作用就是改变内存中 i 的值
    // 但是又不让编译器知道
    __asm {
        mov dword ptr [ebp-4], 20h
    }

    int b = i;
    printf("i = %d", b);
}
#+END_SRC
然后，在 Debug 版本模式运行程序，输出结果如下：
#+BEGIN_EXAMPLE
i = 10
i = 32
#+END_EXAMPLE
然后，在 Release 版本模式运行程序，输出结果如下：
#+BEGIN_EXAMPLE
i = 10
i = 10
#+END_EXAMPLE

输出的结果明显表明，Release 模式下，编译器对代码进行了优化，第二次没有输出正确的 i 值。下面，我们把 i 的声明加上 volatile 关键字，看看有什么变化：
#+begin_src c++
#include <stdio.h>
void main()
{
    volatile int i = 10;
    int a = i;

    printf("i = %d", a);

    // 下面汇编语句的作用就是改变内存中 i 的值
    // 但是又不让编译器知道
    __asm {
        mov dword ptr [ebp-4], 20h
    }

    int b = i;
    printf("i = %d", b);
}
#+END_SRC
分别在 Debug 和 Release 版本运行程序，输出都是：
#+begin_src c++
i = 10
i = 32
#+END_SRC
这说明这个 volatile 关键字发挥了它的作用。其实不只是“内嵌汇编操纵栈”这种方式属于编译无法识别的变量改变，另外更多的可能是多线程并发访问共享变量时，一个线程改变了变量的值，怎样让改变后的值对其它线程 visible。一般说来，volatile 用在如下的几个地方：
1. 中断服务程序中修改的供其它程序检测的变量需要加 volatile；
2. 多任务环境下各任务间共享的标志应该加 volatile；
3. 存储器映射的硬件寄存器通常也要加 volatile 说明，因为每次对它的读写都可能由不同意义；

** 参考文章
[[https://zhuanlan.zhihu.com/p/62060524][C/C++ 中的 volatile-知乎]]

* 谓词
A predicate is an expression that can be called and that returns a value that can be used as a condition. The predicates used by library algorithms are either unary predicates (meaning they have a single parameter) or binary predicates (meaning they have two parameters).

The version of sort that takes a binary predicate uses the given predicate in place of < to compare elements.

#+BEGIN_SRC c++
// comparison function to be used to sort by word length
bool isShorter(const string &s1, const string &s2)
C++ Primer, Fifth Edition
{
return s1.size() < s2.size();
}
// sort on word length, shortest to longest
sort(words.begin(), words.end(), isShorter);
#+END_SRC
* workFlow
通过工厂类 WFTaskFactory 创建不同类型的 task.
在创建 task 时会将回调函数作为入参.
而回调函数自己的入参是 task 本身.

工厂方法只会创建两种类型的对象:ComplexHttpTask 和 ComplexHttpProxyTask.

* 友元
友元可以是一个函数，该函数被称为友元函数；友元也可以是一个类，该类被称为友元类，在这种情况下，整个类及其所有成员都是友元。

类的友元函数是定义在类外部，但有权访问类的所有私有（private）成员和保护（protected）成员。尽管友元函数的原型有在类的定义中出现过，但是友元函数并不是成员函数。

** 友元函数
将全局函数声明为友元的写法如下：
#+begin_src c++
friend  返回值类型  函数名(参数表);
#+END_SRC

将其他类的成员函数声明为友元的写法如下：
#+begin_src c++
friend  返回值类型  其他类的类名::成员函数名(参数表);
#+END_SRC

但是，不能把其他类的私有成员函数声明为友元。

#+begin_src c++
#include<iostream>
using namespace std;
class CCar;  //提前声明CCar类，以便后面的CDriver类使用
class CDriver
{
public:
    void ModifyCar(CCar* pCar);  //改装汽车
};
class CCar
{
private:
    int price;
    friend int MostExpensiveCar(CCar cars[], int total);  //声明友元
    friend void CDriver::ModifyCar(CCar* pCar);  //声明友元
};
void CDriver::ModifyCar(CCar* pCar)
{
    pCar->price += 1000;  //汽车改装后价值增加
}
int MostExpensiveCar(CCar cars[], int total)  //求最贵气车的价格
{
    int tmpMax = -1;
    for (int i = 0; i<total; ++i)
        if (cars[i].price > tmpMax)
            tmpMax = cars[i].price;
    return tmpMax;
}
int main()
{
    return 0;
}
#+END_SRC
这个程序只是为了展示友元的用法，所以 main 函数什么也不做。

第 3 行声明了 CCar 类，CCar 类的定义在后面。之所以要提前声明，是因为 CDriver 类的定义中用到了 CCar 类型（第 7 行），而此时 CCar 类还没有定义，编译会报错。

不要第 3 行，而把 CCar 类的定义写在 CDriver 类的前面，是解决不了这个问题的，因为 CCar 类中也用到了 CDriver 类型（第 14 行），
把 CCar 类的定义写在前面会导致第 14 行的 CDriver 因没有定义而报错。C++ 为此提供的解决办法是：可以简单地将一个类的名字提前声明，写法如下：

class  类名;

尽管可以提前声明，但是在一个类的定义出现之前，仍然不能有任何会导致该类对象被生成的语句。但使用该类的指针或引用是没有问题的。

第 13 行将全局函数 MostExpensiveCar 声明为 CCar 类的友元，因此在第 24 行可以访问 cars[i] 的私有成员 price。
同理，第 14 行将 CDriver 类的 ModifyCar 成员函数声明为友元，因此在第 18 行可以访问 pCar 指针所指向的对象的私有成员变量 price。
** 友元类
一个类 A 可以将另一个类 B 声明为自己的友元，类 B 的所有成员函数就都可以访问类 A 对象的私有成员。在类定义中声明友元类的写法如下：
#+begin_src c++
friend  class  类名;
#+END_SRC
来看如下例程：
#+begin_src c++
class CCar
{
private:
    int price;
    friend class CDriver;  //声明 CDriver 为友元类
};
class CDriver
{
public:
    CCar myCar;
    void ModifyCar()  //改装汽车
    {
        myCar.price += 1000;  //因CDriver是CCar的友元类，故此处可以访问其私有成员
    }
};
int main()
{
    return 0;
}

#+END_SRC
第 5 行将 CDriver 声明为 CCar 的友元类。这条语句本来就是在声明 CDriver 是一个类，所以 CCar 类定义前面就不用声明 CDriver 类了。
第 5 行使得 CDriver 类的所有成员函数都能访问 CCar 对象的私有成员。如果没有第 5 行，第 13 行对 myCar 私有成员 price 的访问就会导致编译错误。

一般来说，类 A 将类 B 声明为友元类，则类 B 最好从逻辑上和类 A 有比较接近的关系。
例如上面的例子，CDriver 代表司机，CCar 代表车，司机拥有车，所以 CDriver 类和 CCar 类从逻辑上来讲关系比较密切，把 CDriver 类声明为 CCar 类的友元比较合理。

友元关系在类之间不能传递，即类 A 是类 B 的友元，类 B 是类 C 的友元，并不能导出类 A 是类 C 的友元。
“咱俩是朋友，所以你的朋友就是我的朋友”这句话在 C++ 的友元关系上 不成立。
** 继承关系
*** 基类中的友元函数行为
C++中, 友元是不会继承的。如果基类有一个友元函数，则此函数不会成为子类的友元函数。

例如下面程序会编译失败，因为函数 show()是基类 A 的友元函数，但无法访问子类 B 的私有数据。
#+begin_src c++
#include <iostream>
using namespace std;
class A {
protected:
    int x;
public:
    A() { x = 222; }
    friend void show();
};
 
class B : public A {
public:
    B() : y(111) {}
private:
    int y;
};
 
void show() {
    B b;
    cout << "The default value of A::x = " << b.x;
 
    // 编译失败。无法访问类'B'中的私有数据
    cout << "The default value of B::y = " << b.y;
}
 
int main() {
    show();
    return 0;
}

#+END_SRC

编译失败。第 2 行 cout 中，无法打印 b.y。
编译提示(visual studio 2015)：
error C2248: “B::y”: 无法访问 private 成员(在“B”类中声明)

如果注释掉第 2 行 cout，则编译通过，运行结果为：
The default value of A::x = 222
*** 子类中的友元函数的行为
反之，如果在子类中定义了一个友元函数，则它可以访问基类中的 public 以及 protected 数据。
因为子类 B 是公有继承 A 的，A中的 public 以及 protected 数据可以被 B 的对象访问。

如下面例子所示：
#+begin_src c++
#include <iostream>
using namespace std;
 
class A {
protected:
    int x;
public:
    A() { x = 22; z = 33; }
    int z;
};
 
class B : public A {
public:
    B() : y(11) {}
    friend void show();
private:
    int y;
};
 
void show() {
    B b;
    cout << "The default value of A::x = " << b.x << std::endl;
    cout << "The default value of A::z = " << b.z << std::endl;
    cout << "The default value of B::y = " << b.y << std::endl;
}
 
int main() {
    show();
    return 0;
}
#+END_SRC
输出：
#+begin_src c++
The default value of A::x = 22
The default value of A::z = 33
The default value of B::y = 11
#+END_SRC

** 参考文章
[[http://c.biancheng.net/view/169.html][C++友元函数和友元类（C++ friend）解详]]
[[https://www.runoob.com/cplusplus/cpp-friend-functions.html][C++ 友元函数]]
* 引用
引用和指针赋值不会产生新对象.
** 子类引用
#+begin_src c++
#include <iostream>
using namespace std;
class Father
{
public:
	Father()
	{
		f = 1;
	}

	void print()
	{
		cout<<"f = "<<f<<endl;
	}
public:
	int f;
};
class Son : public Father
{
public:
	Son():Father()
	{
		s = 2;
	}

	void print()
	{
		cout<<"s = "<<s<<endl;
	}
public:
	int s;
};

void testPrint(Father &f)
{
	f.print();
}

int main()
{
	Son s;
	s.print();//输出s = 2
	Father& f = s;//这里如果直接用值，就是把“&”去掉，即使使用virtual也不会调用子类的方法，原因待解！
	f.print();//输出父类 f=1

	f = s;//父类引用指向子类对象

	f.print();//这里输出 f = 1;和java不一样，java里面则直接调用子类的方法，但是这里不是，这里调用的还是父类的，要让其自动调用子类的方法则需要将方法设置为虚函数，加关键字virtual
	((Son&)f).print();//强制转换，输出 s = 2

	testPrint(s);//输出父类 f=1

	return 0;
}
#+END_SRC
* 内存泄露
new 和 delete 是 C++ 用于管理堆内存的两个运算符，对应于 C 语言中的 malloc 和 free，但是 malloc 和 free 是函数，而 new 和 delete 是运算符。除此之外，new 在申请内存的同时，还会调用对象的构造函数，而 malloc 只会申请内存；同样，delete 在释放内存之前，会调用对象的析构函数，而 free 只会释放内存。

new 运算符申请内存：将调用相应的 operator new(size_t) 函数动态分配内存，在分配到的动态内存块上 初始化 相应类型的对象（构造函数）并返回其首地址。如果调用构造函数初始化对象时抛出异常，则自动调用 operator delete(void*, void*) 函数释放已经分配到的内存。

delete 运算符释放内存：调用相应类型的析构函数，处理类内部可能涉及的资源释放，调用相应的 operator delete(void *) 函数。
** 内存是如何泄露的
在 C++ 程序中，主要涉及到的内存就是“栈”和“堆”

#+DOWNLOADED: file:F:/org/图片/v2-f3189547daa4548bc4ab6fdd13eeea6d_720w.png @ 2020-06-13 19:16:48
[[file:内存泄露/2020-06-13_19-16-48_v2-f3189547daa4548bc4ab6fdd13eeea6d_720w.png]]

通常来说，一个线程的栈内存是有限的，通常来说是 8M 左右（取决于运行的环境）。栈上的内存通常是由编译器来自动管理的。当在栈上分配一个新的变量时，或进入一个函数时，栈的指针会下移，相当于在栈上分配了一块内存。我们把一个变量分配在栈上，也就是利用了栈上的内存空间。当这个变量的生命周期结束时，栈的指针会上移，相同于回收了内存。

由于栈上的内存的分配和回收都是由编译器控制的，所以在栈上是不会发生内存泄露的，只会发生栈溢出（Stack Overflow），也就是分配的空间超过了规定的栈大小。

而堆上的内存是由程序直接控制的，程序可以通过 malloc/free 或 new/delete 来分配和回收内存，如果程序中通过 malloc/new 分配了一块内存，但忘记使用 free/delete 来回收内存，就发生了内存泄露。

*** 经验 #1：尽量避免在堆上分配内存
既然只有堆上会发生内存泄露，那第一原则肯定是避免在堆上面进行内存分配，尽可能的使用栈上的内存，由编译器进行分配和回收，这样当然就不会有内存泄露了。

然而，只在栈上分配内存，在有 IO 的情况下是存在一定局限性的。

举个例子，为了完成一个请求，我们通常会为这个请求构造一个 Context 对象，用于描述和这个请求有关的一些上下文。例如下面一段代码：
#+BEGIN_SRC c++
void Foo(Reuqest* req) {
    RequestContext ctx(req);
    HandleRequest(&ctx);
}
#+END_SRC
如果 HandleRequest 是一个同步函数，当这个函数返回时，请求就可以被处理完成，那么显然 ctx 是可以被分配在栈上的。

但如果 HandleRequest 是一个异步函数，例如：
#+BEGIN_SRC c++
void HandleRequest(RequestContext* ctx, Callback cb);
#+END_SRC
那么显然，ctx 是不能被分配在栈上的，因为如果 ctx 被分配在栈上，那么当 Foo 函数推出后，ctx 对象的生命周期也就结束了。而 FooCB 中显然会使用到 ctx 对象。
#+BEGIN_SRC c++
void HandleRequest(RequestContext* ctx, Callback cb);

void Foo(Reuqest* req) {
    auto ctx = new RequestContext(req);
    HandleRequest(ctx, FooCB);
}

void FooCB(RequestContext* ctx) {
    FinishRequest(ctx);
    delete ctx;
}
#+END_SRC
在这种情况下，如果忘记在 FooCB 中调用 delete ctx，则就会触发内存泄露。尽管我们可以借助一些静态检查工具对代码进行检查，但往往异步程序的逻辑是极其复杂的，一个请求的生命周期中，也需要进行大量的内存分配操作，静态检查工具往往无法发现所有的内存泄露情况。

那么怎么才能避免这种情况的产生呢？引入智能指针显然是一种可行的方法，但引入 shared_ptr 往往引入了额外的性能开销，并不十分理想。

在 SmartX，我们通常采用两种方法来应对这种情况。

*** 经验 #2：使用 Arena
Arena 是一种统一化管理内存生命周期的方法。所有需要在堆上分配的内存，不通过 malloc/new，而是通过 Arena 的 CreateObject 接口。同时，不需要手动的执行 free/delete，而是在 Arena 被销毁的时候，统一释放所有通过 Arena 对象申请的内存。所以，只需要确保 Arena 对象一定被销毁就可以了，而不用再关心其他对象是否有漏掉的 free/delete。这样显然降低了内存管理的复杂度。

此外，我们还可以将 Arena 的生命周期与 Request 的生命周期绑定，一个 Request 生命周期内的所有内存分配都通过 Arena 完成。这样的好处是，我们可以在构造 Arena 的时候，大概预估出处理完成这个 Request 会消耗多少内存，并提前将会使用到的内存一次性的申请完成，从而减少了在处理一个请求的过程中，分配和回收内存的次数，从而优化了性能。

我们最早看到 Arena 的思想，是在 LevelDB 的代码中。这段代码相当简单，建议大家直接阅读。

*** 经验 #3：使用 Coroutine
Coroutine 相信大家并不陌生，那 Coroutine 的本质是什么？我认为 Coroutine 的本质，是使得一个线程中可以存在多个上下文，并可以由用户控制在多个上下文之间进行切换。而在上下文中，一个重要的组成部分，就是栈指针。使用 Coroutine，意味着我们在一个线程中，可以创造（或模拟）多个栈。

有了多个栈，意味着当我们要做一个异步处理时，不需要释放当前栈上的内存，而只需要切换到另一个栈上，就可以继续做其他的事情了，当异步处理完成时，可以再切换回到这个栈上，将这个请求处理完成。

还是以刚才的代码为示例:
#+BEGIN_SRC c++
void Foo(Reuqest* req) {
    RequestContext ctx(req);
    HandleRequest(&ctx);
}

void HandleRequest(RequestCtx* ctx) {
    SubmitAsync(ctx);
    Coroutine::Self()->Yield();
    CompleteRequest(ctx);
}
#+END_SRC
这里的精髓在于，尽管 Coroutine::Self()->Yield() 被调用时，程序可以跳出 HandleRequest 函数去执行其他代码逻辑，但当前的栈却被保存了下来，所以 ctx 对象是安全的，并没有被释放。

这样一来，我们就可以完全抛弃在堆上申请内存，只是用栈上的内存，就可以完成请求的处理，完全不用考虑内存泄露的问题。然而这种假设过于理想，由于在栈上申请内存存在一定的限制，例如栈大小的限制，以及需要在编译是知道分配内存的大小，所以在实际场景中，我们通常会结合使用 Arena 和 Coroutine 两种技术一起使用。

有人可能会提到，想要多个栈用多个线程不就可以了？然而用多线程实现多个栈的问题在于，线程的创建和销毁的开销极大，且线程间切块，也就是在栈之间进行切换的代销需要经过操作系统，这个开销也是极大的。所以想用线程模拟多个栈的想法在实际场景中是走不通的。

关于 Coroutine 有很多开源的实现方式，大家可以在 github 上找到很多，C++20 标准也会包含 Coroutine 的支持。在 SmartX 内部，我们很早就实现了 Coroutine，并对所有异步 IO 操作进行了封装，示例可参考我们之前的一篇文章 smartx：基于 Coroutine 的异步 RPC 框架示例（C++）

这里需要强调一下，Coroutine 确实会带来一定的性能开销，通常 Coroutine 切换的开销在 20ns 以内，然而我们依然在对性能要求很苛刻的场景使用 Coroutine，一方面是因为 20ns 的性能开销是相对很小的，另一方面是因为 Coroutine 极大的降低了异步编程的复杂度，降低了内存泄露的可能性，使得编写异步程序像编写同步程序一样简单，降低了程序员心智的开销。

*** 经验 #4：善用 RAII
尽管在有些场景使用了 Coroutine，但还是可能会有在堆上申请内存的需要，而此时有可能 Arena 也并不适用。在这种情况下，善用 RAII（Resource Acquisition Is Initialization）思想会帮助我们解决很多问题。

简单来说，RAII 可以帮助我们将管理堆上的内存，简化为管理栈上的内存，从而达到利用编译器自动解决内存回收问题的效果。此外，RAII 可以简化的还不仅仅是内存管理，还可以简化对资源的管理，例如 fd，锁，引用计数等等。

当我们需要在堆上分配内存时，我们可以同时在栈上面分配一个对象，让栈上面的对象对堆上面的对象进行封装，用时通过在栈对象的析构函数中释放堆内存的方式，将栈对象的生命周期和堆内存进行绑定。

unique_ptr 就是一种很典型的例子。然而 unique_ptr 管理的对象类型只能是指针，对于其他的资源，例如 fd，我们可以通过将 fd 封装成另外一个 FileHandle 对象的方式管理，也可以采用一些更通用的方式。例如，在我们内部的 C++ 基础库中实现了 Defer 类，想法类似于 Go 中 defer。
#+BEGIN_SRC c++
void Foo() {
    int fd = open();
    Defer d = [=]() { close(fd); }
    // do something with fd
}
#+END_SRC

*** 经验 #5：便于 Debug
在特定的情况下，我们难免还是要手动管理堆上的内存。然而当我们面临一个正在发生内存泄露线上程序时，我们应该怎么处理呢？

当然不是简单的『重启大法好』，毕竟重启后还是可能会产生泄露，而且最宝贵的现场也被破坏了。最佳的方式，还是利用现场进行 Debug，这就要求程序具有便于 Debug 的能力。

这里不得不提到一个经典而强大的工具 gperftools。gperftools 是 google 开源的一个工具集，包含了 tcmalloc，heap profiler，heap checker，cpu profiler 等等。gperftools 的作者之一，就是大名鼎鼎的 Sanjay Ghemawat，没错，就是与 Jeff Dean 齐名，并和他一起写 MapReduce 的那个 Sanjay。

gperftools 的一些经典用法，我们就不在这里进行介绍了，大家可以自行查看文档。而使用 gperftools 可以在不重启程序的情况下，进行内存泄露检查，这个恐怕是很少有人了解。

实际上我们 Release 版本的 C++ 程序可执行文件在编译时全部都链接了 gperftools。在 gperftools 的 heap profiler 中，提供了 HeapProfilerStart 和 HeapProfilerStop 的接口，使得我们可以在运行时启动和停止 heap profiler。同时，我们每个程序都暴露了 RPC 接口，用于接收控制命令和调试命令。在调试命令中，我们就增加了调用 HeapProfilerStart 和 HeapProfilerStop 的命令。由于链接了 tcmalloc，所以 tcmalloc 可以获取所有内存分配和回收的信息。当 heap profiler 启动后，就会定期的将程序内存分配和回收的行为 dump 到一个临时文件中。

当程序运行一段时间后，你将得到一组 heap profile 文件
#+BEGIN_SRC bash
  profile.0001.heap
  profile.0002.heap
  ...
  profile.0100.heap
#+END_SRC
每个 profile 文件中都包含了一段时间内，程序中内存分配和回收的记录。如果想要找到内存泄露的线索，可以通过使用
#+BEGIN_SRC bash
pprof --base=profile.0001.heap /usr/bin/xxx profile.0100.heap --text
#+END_SRC
来进行查看，也可以生成 pdf 文件，会更直观一些。
#+DOWNLOADED: file:F:/org/图片/v2-a8eedcc8f07691a31707f5f8921acfa8_720w.png @ 2020-06-13 19:27:10
[[file:内存泄露/2020-06-13_19-27-10_v2-a8eedcc8f07691a31707f5f8921acfa8_720w.png]]
* 命名空间
** 内联命名空间

C++11 中引入了内联命名空间（inline namespace），它的特点就是不需要使用 using 语句就可以直接在外层命名空间使用该命名空间内部的内容，而且无需使用命名空间前缀。先看代码：
#+begin_src c++
  inline namespacs inline_namespace1{
    class Inline1{
      public:
      int iv;
    };
  }

  namespace inline_namespace1{
    class Inline2{
      public:
      double dv;
    };
  }
#+END_SRC
内联命名空间的声明方法就是在原来的声明语法前面增加 inline 关键字。除此之外上面代码还有以下特点：
- 两处声明的命名空间同名，它们同属一个命名空间。这是 C++命名空间从来就有的特性。
- 第一次声明命名空间时使用了 inline 关键字，这叫显式内联；第二次没有使用 inline 关键字，但是由于第一次已经声明了 inline，这里声明的还是内联命名空间。这种情况成为隐式内联。

内联命名空间声明之后，就可以在外层命名空间不适用前缀而直接使用它们了。
#+begin_src c++
namespace inline_test{
	inline namespace inline_namespace1{
		class Inline1{
			public:
			int iv;
		};
	}
	
	namespace inline_namespace1{
		class Inline2{
			public:
			double dv;
		}
	}
	
	void test_inline_namespace(){
		Inline1 in1;
		in1.iv=5;
		
		Inline2 in2;
		in2.dv=2;
	}
}

void test_inline_namespace(){
	inline_test::Inline1 in1;
	in1.iv=5;
	
	inline_test::Inline2 in2;
	in2.dv=2;
}
#+END_SRC
上述代码中 test_inline_namespace 处在 linline_namespace1 的外层，所以可以直接使用 Inline1 和 Inline2。test_inline_namespace2 处在更外层，这时也只是需要使用外层命名空间 inline_test 前缀即可。

看起来 inline_namespace 就像不存在一样。
** 匿名命名空间
当定义一个命名空间时，可以忽略这个命名空间的名称：
#+begin_src c++
 namespce {
     char c;
     int i;
     double d;
 }
#+END_SRC

编译器在内部会为这个命名空间生成一个唯一的名字，而且还会为这个匿名的命名空间生成一条 using 指令。所以上面的代码在效果上等同于：
#+begin_src c++
namespace __UNIQUE_NAME_ {
    char c;
    int i;
    double d;
}
using namespace __UNIQUE_NAME_;
#+END_SRC
在匿名命名空间中声明的名称也将被编译器转换，与编译器为这个匿名命名空间生成的唯一内部名称(即这里的__UNIQUE_NAME_)绑定在一起。还有一点很重要，就是这些名称具有 internal 链接属性，这和声明为 static 的全局名称的链接属性是相同的，即名称的作用域被限制在当前文件中，无法通过在另外的文件中使用 extern 声明来进行链接。如果不提倡使用全局 static 声明一个名称拥有 internal 链接属性，则匿名命名空间可以作为一种更好的达到相同效果的方法。

注意:命名空间都是具有 external 连接属性的,只是匿名的命名空间产生的__UNIQUE_NAME__在别的文件中无法得到,这个唯一的名字是不可见的.

C++ 新的标准中提倡使用匿名命名空间,而不推荐使用 static,因为 static 用在不同的地方,涵义不同,容易造成混淆.另外,static 不能修饰 class。

注意:命名空间都是具有 external 连接属性的,只是匿名的命名空间产生的__UNIQUE_NAME__在别的文件中无法得到,这个唯一的名字是不可见的.

C++ 新的标准中提倡使用匿名命名空间,而不推荐使用 static,因为 static 用在不同的地方,涵义不同,容易造成混淆.另外,static 不能修饰 class。
** 参考文章
[[https://blog.csdn.net/craftsman1970/article/details/82872497][C++11新特性(79)-内联命名空间(inline namespace)]]
[[https://www.cnblogs.com/youxin/p/4308364.html][C++匿名命名空间]]
* 模板
** 模板类
*** 模板类的继承
在模板类的继承中，需要注意以下两点：
- 如果父类自定义了构造函数，记得子类要使用构造函数列表来初始化
- 继承的时候，如果子类不是模板类，则必须指明当前的父类的类型，因为要分配内存空间
- 继承的时候，如果子类是模板类，要么指定父类的类型，要么用子类的泛型来指定父类

#+begin_src cpp
template <typename T>
class Parent{
public:
    Parent(T p)
    {
        this->p = p;
    }

private:
    T p;
};

//如果子类不是模板类，需要指明父类的具体类型
class ChildOne:public Parent<int>{

public:
    ChildOne(int a,int b):Parent(b)
    {
        this->cone = a;
    }

private:
    int cone;
};


//如果子类是模板类，可以用子类的泛型来表示父类
template <typename T>
class ChildTwo:public Parent<T>{

public:
    ChildTwo(T a, T b):Parent<T>(b)
    {
        this->ctwo = a;
    }

private:
    T ctwo;
};
#+end_src
* 默认实参
一旦某个实参被赋予了默认值，它后面所有的形参都必须有默认值。
** 默认实参声明
多次声明同一个函数是合法的，但是在给定的作用域中一个形参只能被赋予一次默认参数。
#+begin_src c++
  string screen(sz,sz,char=' ');
  string screen(sz,sz,char='*');//错误，重复声明。不能修改一个已经存在的默认值
  string screen(sz=24,sz=80,char);//正确，可以重复声明添加默认实参
#+END_SRC
** 默认实参初始值

* 结构化绑定声明
结构化绑定声明，是指在一次声明中同时引入多个变量，同时绑定初始化表达式的各个子对象的语法形式。
结构化绑定声明使用 auto 来声明多个变量，所有变量都必须用中括号括起来。
#+begin_example
cv-auto+引用 [变量1, 变量2, ... 变量n ] = 初始化表达式;
cv-auto+引用 [变量1, 变量2, ... 变量n ] (初始化表达式);
cv-auto+引用 [变量1, 变量2, ... 变量n ] {初始化表达式};
// 这里 cv-auto+引用 包含 auto, auto const, auto &, auto&& 等等形式
#+end_example
结构化绑定所声明的变量有两种形式：
1. 非引用变量，此时初始化表达式对象需要拷贝一份，变量所绑定的是初始化表达式对象拷贝的各个子对象。
2. 引用变量，此时初始化表达式对象不需要拷贝，变量所绑定的是初始化表达式对象本身的各个子对象。

结构化绑定中的初始化表达式有三种类型：
1. 数组类型，此时变量所绑定的是数组的各个元素。
2. pair tuple 等支持 tuple_size<E> 的类型，此时变量所绑定的是 get<0>(e)，get<1>(e)，get<2>(e)…
这里 E 是指类型，e是指对象。
3. 带有 public 成员的结构类型，此时变量所绑定的是结构对象的各个 public 成员。

C++17 代码
#+begin_src c++ 
#include <iostream>
#include <utility>
#include <set>
#include <map>

using namespace std;

struct S {
    int a, b;
};

map<string, int> get_map()
{
    return {
        { "hello", 1 },
        { "world", 2 },
        { "it's",  3 },
        { "me",    4 },
    };
}

int main()
{
    auto [a, b] = pair(2, "3"s);
    cout << a << b << endl; // 23

    set<string> myset;
    if (auto [iter, success] = myset.insert("Hello"); success) 
       cout << *iter << endl; // Hello

    int arr[] = {1, 2};
    const auto& [m, n] = arr;
    cout << m << n << endl; //12

    S s = {4, 5};
    auto& [x, y] = s;
    x = 0, y = 1;
    cout << s.a << s.b << endl; // 01

    for (auto&& [k, v] : get_map())
        cout << "k=" << k << " v=" << v << endl;
    // k=hello v=1
    // k=it's v=3
    // k=me v=4
    // k=world v=2
}
#+end_src
代码说明
代码第 25 行采用结构化绑定声明了 int 类型的 a 和 string 类型的 b，分别绑定了初始化表达式中 pair 对象的 first 和 second。
代码第 29 行采用结构化绑定声明了迭代类型的 iter 和 bool 类型的 success，分别绑定了初始化表达式中 pair 对象的 first 和 second。
代码第 33 行采用结构化绑定声明了 const int& 类型的 m 和 n，分别绑定了初始化表达式中 arr 数组的两个元素。
代码第 37 行采用结构化绑定声明了 int& 类型的 x 和 y，分别绑定了初始化表达式中 s 对象的两个数据成员 a 和 b。
代码第 41 行采用结构化绑定声明了 string&& 类型的 k 和 int 类型的 v，分别绑定了初始化表达式中 pair 对象的 first 和 second。

C++14 等价代码
#+begin_src c++ 
#include <iostream>
#include <utility>
#include <set>
#include <map>

using namespace std;

struct S {
    int a, b;
};

map<string, int> get_map()
{
    return {
        { "hello", 1 },
        { "world", 2 },
        { "it's",  3 },
        { "me",    4 },
    };
}

int main()
{
    auto kv = make_pair(2, "3"s);
    auto& a = kv.first; auto& b = kv.second;

    set<string> myset;
    set<string>::iterator iter;
    bool success;
    tie(iter, success) = myset.insert("Hello");
    if (success) 
       cout << *iter << endl; // Hello

    int arr[] = {1, 2};
    const auto &m = arr[0], &n = arr[1];
    cout << m << n << endl; //12

    S s = {4, 5};
    auto &x = s.a, &y = s.b;
    x = 0, y = 1;
    cout << s.a << s.b << endl; // 01

    for (auto&& kv : get_map()) {
        auto&& k = forward<decltype(kv.first)>(kv.first);
        auto&& v = forward<decltype(kv.second)>(kv.second);
        cout << "k=" << k << " v=" << v << endl;
    }
    // k=hello v=1
    // k=it's v=3
    // k=me v=4
    // k=world v=2
}
#+end_src
** 参考文章
[[https://blog.csdn.net/zwvista/article/details/78111346][C++17尝鲜：结构化绑定声明（Structured Binding Declaration）]]
* 字符串
** 字符串数组
#+BEGIN_SRC c++
char a[] = "hello";   //字符串数组，存放的是字符,a表示字符h的地址
#+END_SRC
*** 初始化
#+BEGIN_SRC c++
char a[10] ="hello";//字符串以'\0'结尾，这种方式系统会自动在数组未填值的地方添加'\0'
char b[] = {'h', 'e' , 'l', 'l', '\0'};//类似于初始化整型数组，必须要手动在后面添加'\0'
#+END_SRC
** 字符串指针数组
#+BEGIN_SRC c++
char *b[] = {"hello", "world"};//字符串指针数组，数组b总共有两个4字节的元素,第一个元素存储字符串"hello"的地址,即指向字符h的指针,第二个元素存储字符串"world"的地址,即指向字符w的指针.
#+END_SRC
* 指针
** 字符指针
字符指针是指向字符或字符串的指针,例如 char*。
数组名存放的是首元素的地址，而指针同理存放的是首字符的地址。
但不同的是，字符型数组在初始化时会开辟新的内存块，用相同的常量字符串初始化不同数组也会开辟出不同的内存块。
而字符指针是指向一个地址，也就是说，不论是多少个字符指针，只要你指向的是同一个常量字符串，那么实际你指向的内存地址是不会发生变化的，因为作为常量的字符串有着它独一份不会改变的地址。

下面是一道非常经典的例题：
#+begin_src C
#include <stdio.h>
int main()
{
	char str1[] = "hello world.";
	char str2[] = "hello world.";
	char *str3  = "hello world.";
	char *str4  = "hello world.";

	if (str1 == str2)
	{
		printf("str1 and str2 are same\n");
	}
	else
	{
		printf("str1 and str2 are not same\n");
	}

	if (str3 == str4)
	{
		printf("str3 and str4 are same\n");
	}
	else
	{
		printf("str3 and str4 are not same\n");
	}
	return 0;
}
#+end_src
结果为:

#+DOWNLOADED: screenshot @ 2022-12-25 20:20:11
[[file:images/指针/2022-12-25_20-20-11_screenshot.png]]
由于 str1 和 str2 是数组名，表示数组首元素的地址，而他们在初始化时开辟的是不同的内存块，所以地址不同；而 str3 和 str4 是指针，指向的是首字符的地址，但作为字符串常量，它的地址是不变的，所以这两个字符指针所存放的地址是相同的。
** 指针数组和数组指针
指针数组是存放指针的数组。如 int *arr[3] ,其中 [3] 的优先级高，确定它为一个数组，数组名为 arr，类型为 int * 。

数组指针是指向数组的指针。如 int (*p)[3], (*p)的优先级最高，确定它为一个指针，而指针指向的 [3] 是一个数组，数组类型为 int。

刚开始我们可能不太好分清楚指针数组和数组指针，他们的名字很相似，不免会使人混乱。那么如何分清指针数组与数组指针呢？答案就是优先级。我们可以将其拆分开来，最先定义优先级高的，一般判断出最高的优先级时，我们就能初步判定出它到底是数组还是指针，由此便可得出它的类型。

&数组名和数组名的区分 int arr[10]

我们都知道数组名表示数组首元素的地址，这在前面的字符数组中也提到过。例如 arr 表示 arr[10] 这个数组的首元素地址，即 arr[1] 的地址。但当我们用 %p 去分别打印 arr 和 &arr 的地址时，会发现他们两个的地址是一样的。但他们的实际意义是相同的吗？我们可以通过下面一段代码来验证。
#+begin_src C
#include <stdio.h>
int main()
{
	int arr[10] = { 0 };
	printf("arr = %p\n", arr);
	printf("&arr = %p\n", &arr);
	printf("arr + 1 = %p\n", arr + 1);
	printf("&arr + 1 = %p\n", &arr + 1);
	return 0;
}
#+end_src
这段代码分别打印了 arr 、&arr 、arr+1 和 &arr+1 的地址。
结果为：

#+DOWNLOADED: screenshot @ 2022-12-25 20:21:17
[[file:images/指针/2022-12-25_20-21-17_screenshot.png]]
我们可以看到，当他们各自 +1 以后的结果不同，可知实际意义也有所不同。arr 与 arr+1 的差值为 4，是一个 int 类型的大小，也就是跳过了一个元素。&arr 则表示的是数组的地址。数组的地址 +1 ，跳了整个数组的大小，而该数组有 10 个元素，每个元素都是 int 类型，所以 &arr+1 相对于 &arr 的差值刚好为 40。由此可知，&arr 的类型为数组指针，他可以等同于 *int (p)[10] 。

** 函数指针
函数指针是能够指向函数的指针，例如 void (*Fun) ()。Fun 先和 * 结合，确定 Fun 为指针，而指针指向的是一个函数，指向的函数无参数，返回值类型为 void 。函数在调用时需要开辟栈帧，这时就会开辟出新的地址，而函数名就代表函数地址，函数指针则存储函数的地址。

在《c 陷阱与缺陷》中，有这样两个代码：
#+begin_src c
(*(void (*)())0)();
#+end_src
这个代码看上去确实给人一种很混乱的感觉，毕竟有这么多的括号在内，但只要找到它的优先级，还是很好理解的。我们可以看到，其中中间的(void (*)())作为一部分整体是在 0 的前面，也就是对 0 进行一个类型的转换，将 0 强转为一个地址，(*)的优先级最高，表明它是一个指针，而指针指向的是一个函数()，函数的返回值为 void。所以它转换后的地址的类型就是“指向返回值为 void 的函数的指针”。而整体就是调用 0 地址处的函数。

再来看另外一个代码：
#+begin_src c
void (*signal(int , void(*)(int)))(int);
#+end_src
同样是一段看上去比较复杂的代码,首先 signal 先与后面小括号结合，说明它是一个函数，它的参数是 signal 后面括号内的 int 和 void(*)(int)。而除了 signal 函数的其他部分表示的是函数的返回值，void(*) (int)，是一个函数指针。所以这个代码实际上就表示的是一个 signal 函数，函数的参数为 (int , void(*)(int)),函数的返回值是一个函数指针 void(*) (int)。当然这个函数有简化的方式：
#+begin_src c
typedef void(*pfun_t)(int);
pfun_t signal(int , pfun_t);
#+end_src
第一个语句通过 typedef 将 pfun_t 定义为函数指针的类型，而第二个语句就十分明了，signal 函数的参数为 int 和 pfun_t，返回值为 pfun_t。
** 函数指针数组
我们知道了函数指针是指向函数的指针，那函数指针数组也就是存放函数指针的数组。
例如 int (*parr[10])()。首先它必须是一个数组，所以要先和中括号结合，拆分开来就是 parr[10]，它的优先级最高确定它是一个数组。其次是 * ，表明指针，而指向的内容就是后面的函数 () ，数组类型为 int 。

函数指针数组最大的用途：转移表。
#+begin_src c
#define _CRT_SECURE_NO_WARNINGS 1
#include <stdio.h>
int Add(int x, int y)
{
	return x + y;
}
int Sub(int x, int y)
{
	return x - y;
}
int Mul(int x, int y)
{
	return x * y;
}
int Div(int x, int y)
{
	return x / y;
}
//以上为加减乘除四个函数
void menu()
{
	printf("1.Add\n2.Sub\n3.Mul\n4.Div\n");
}
int main()
{
	int input = 0;//input用来做不同计算函数的选项
	int a = 0;
	int b = 0;
	int(*Pfun[5])(int, int) = { 0, Add, Sub, Mul, Div };
	//第一个元素为0,使元素下标1234分别代表加减乘除函数
	do
	{
		menu();
		printf("请输入菜单选项: ");
		scanf("%d", &input);
		if (input >= 1 && input <= 4)
		{
			printf("请输入两个操作数：");
			scanf("%d %d", &a, &b);
			printf("%d\n", Pfun[input](a, b));
			//Pfun[input](a, b)直接调用下标为input的函数
		}
	} while (input);
	return 0;
}
#+end_src
由以上代码我们可以看到，使用转移表会很大程度上去节省我们调用函数的空间，只需要通过函数指针数组访问元素下标地址去调用，而不用一一去调用，能让代码避免更加冗余。
** 指向函数指针数组的指针
在理解了函数指针数组之后，那么指向函数指针数组的指针也不难掌握。首先它是一个指针，指针指向一个数组，数组中的元素是函数指针。其实只要将每一层由内到外逐层分析理解，就不难分辨。

例如上文的函数指针数组 int (*parr[10])(),那么 我们再增加一个指向该数组的指针，也就是
#+begin_src c
int (*(*parr)[10])()这是一个指向存放十个函数指针元素数组的指针。
#+end_src
** 二重指针
char**是二重指针，bai 也就是指向指针变量的指针。 而 char*是一维指针，即指向 zhi 字符变量的指针。

其区别在于，指向地址 dao 所存储的值不同。

对于 char **p1, *p1 的类型为 char*型，而**p1 的类型才是 char 型。

对于 char*类指针 p2，*p2 就是 char 型。
** .和->的区别
编译器会将 p->member 变成访问 p+offset_member 这个内存地址的变量

编译器会将 s.member 变成访问&s+offset_member 这个内存地址的变量
** 智能指针
智能指针用于自动释放内存.
*** shared_ptr 类
Defined in header <memory>
#+begin_src c++
template< class T > class shared_ptr;
(since C++11)
#+END_SRC
默认初始化的智能指针保存着一个空指针.

如果在一个条件判断中使用智能指针,效果就是检测它是否为空:
#+begin_src c++
// if p1 is not null, check whether it's the empty string
if (p1 && p1->empty())
*p1 = "hi"; // if so, dereference p1 to assign a new value to that string
#+END_SRC

*** 支持的操作

#+DOWNLOADED: screenshot @ 2023-07-31 21:46:20
[[file:images/c++/指针/2023-07-31_21-46-20_screenshot.png]]

#+DOWNLOADED: screenshot @ 2023-07-31 21:46:32
[[file:images/c++/指针/2023-07-31_21-46-32_screenshot.png]]

*** shared_ptr
shared_ptr 允许多个指针指向同一个对象
**** make_shared 函数
make_shared 在动态内存中分配一个对象并初始化它,返回指向此对象的 shared_ptr.
调用 make_chared<T>时传递的参数必须跟 T 的某个构造函数相匹配.
#+begin_src c++
// 指向一个值为42的int的shared_ptr
shared_ptr<int> p3 = make_shared<int>(42);
// p4指向一个值为"9999999999"的string
shared_ptr<string> p4 = make_shared<string>(10, '9');
// p5指向一个值初始化的int,即值为0
shared_ptr<int> p5 = make_shared<int>();
#+END_SRC
**** shared_ptr 的拷贝与赋值
每个 shared_ptr 都有一个引用计数,用来记录有多少个 shared_ptr 指向相同的对象.
shared_ptr 的析构函数会递减引用计数,一旦引用计数变为 0,就会自动释放管理的对象并释放内存.

拷贝一个 shared_ptr,引用计数都会增加:
- 用一个 shared_ptr 初始化另一个 shared_ptr
- 将 shared_ptr 作为参数传递给一个函数
- 作为函数的返回值

引用计数减少的情况:
- 给 shared_ptr 赋一个新值
- shared_ptr 被销毁(例如一个局部的 shared_ptr 离开其作用域)
*** unique_ptr
unique_ptr 独占所指向的对象.
*** week_ptr
week_ptr 是一种弱引用,指向 shared_ptr 指向的对象.

** 参考文章
[[https://blog.csdn.net/weixin_44058932/article/details/90767275][C语言中不同类型指针的区别]]
* 转换
** 算术转换
*** 整型提升
bool\char\signed char\unsigned char\short\unsigned short 等类型:
- 如果可以存在 int 里,则转换成 int(例如 bool 转成 0 或 1)
- 如果不能存在 int 里,则转换成 unsigned int

较大的 char 类型(wchar_t\char16_t\char32_t)提升成 int\unsigned int\long\unsigned long\long long\unsigned long long 中最小的一种类型,前提是要能容纳原类型所有可能的值.

**** 从汇编层面理解
从一个简单的例子开始：
#+begin_src c++
int main(void)
{
    unsigned char a = 0xff;
    char b = 0xff;
    int c = a + b;
    return 0;
}

#+END_SRC
反汇编结果是：
#+begin_src c++
movl    {% math_inline %}0, -4(%rbp)        # The return value of main is 0
movb    {% endmath_inline %}-1, -5(%rbp)       # unsigned char a = 0xff;
movb    {% math_inline %}-1, -6(%rbp)       # char b = 0xff;
movzbl  -5(%rbp), %eax
movsbl  -6(%rbp), %ecx
addl    %eax, %ecx          # int c = a + b
movl    %ecx, -12(%rbp)     # store c onto the stack
movl    -4(%rbp), %eax
popq    %rbp
ret                         # return value 0 from eax
#+END_SRC
如果你的 GAS 语法不熟悉，可以查看 X86 Assembly/GAS Syntax。
GAS 语法指令通常以“b”, “s”, “w”, “l”, “q” 和“t” 为后缀，以区分操作数在大小。
#+begin_src c++
b = byte (8 bit)
s = short (16 bit integer) or single (32-bit floating point)
w = word (16 bit)
l = long (32 bit integer or 64-bit floating point)
q = quad (64 bit)
t = 10 bytes (80-bit floating point)

#+END_SRC
GAS 语法中的 mov 是把参数从左边移到右边。例如： movl {% endmath_inline %}0, -4(%rbp)的意思是把 0x00000000 移到地址 -4(%rbp)处。

指令 movzbl 表示把一个 byte 变成 long 并将空位零填充 。movzbl -5(%rbp), %eax 把 0xff 移到寄存器 %eax 上，并把空位补 0。寄存器 %eax 的值变成了 0x000000ff。

指令 movsbl 表示把一个 byte 变成 long 并将空位符号填充。movsbl -6(%rbp), %ecx 把 0xff 移到寄存器 %eax ，然后把空位补成有符号的数值，这使得寄存器 %ecx 值变为 0xffffffff。最后， addl %eax, %ecx 执行加法操作， movl %ecx, -12(%rbp) 把结果存到栈上。

现在，你可以把整型提升理解为把 C 语言类型直接映射到机器指令的一种机制了。所有算术操作的操作数被转成有符号或无符号 int 后，都会被当作一个小的 int 的计算。你可以这么想：尽管 short 和 char 只占一两个字节，当它们在进行算术运算时，都是当作 int 的。这种转成 int 规则被称为整型提升。

总结:
通常情况下，在对 int 类型的数值作运算时，CPU 的运算速度是最快的。在 x86 上，32 位算术运算的速度比 16 位算术运算的速度快一倍。C语言是一个注重效率的语言，所以它会作整型提升，使得程序的运行速度尽可能地快。因此，你必须记住整型提升规则，以免发生一些整型溢出的问题。
**** 参考文章
[[https://windmissing.github.io/cpp_notes/grammar/2015-08-25-Integer-Promotion.html][c语言进阶：整型提升]]

*** 浮点类型提升
float 将会提升到 double 类型再进行运算

*** 无符号类型的运算对象
如果某个运算符左右两边的运算对象类型不一致,那么这些运算对象将转换成同一种类型.
1. 执行整型提升后,如果两边的运算对象的类型一样,则无须进一步的转换;
2. 如果一个是无符号,一个是有符号,并且无符号类型大于等于带符号类型,那么带符号类型转换成无符号类型;
3. 如果一个是无符号,一个是有符号,并且无符号类型小于带符号类型,此时转换的结果取决于机器.如果无符号类型所有值都可以存在带符号类型里,则无符号转成有符号,
*** 转换优先级
优先级逐步提升，同一级的类型优先级相同：
1. bool
2. char,signed char,unsigned char
3. short,unsigned short
4. int,unsigned int
5. long,unsigned long
6. long long,unsigned long long

** 显式转换
*** 命名的强制类型转换
格式:cast-name<type>(expression);
如果 type 是引用类型,则结果是左值.

cast-name 是 static_cast\dynamic_cast\const_cast 和 reinterpret_cast 中的一种.
**** const_cast
const_cast 用来移除变量的 const 或 volatile 限定符.
const_cast 只能改变运算对象的底层 const.

#+begin_src c++
  const char *pc;
  char *p=const_cast<char*>(pc);//正确,但是通过p写值是未定义的行为
#+END_SRC
如果对象本身不时一个常量,使用强制类型转换获得写权限是合法的行为.但是如果对象是一个常量,再使用 const_cast 执行写操作就会产生未定义的后果.
* gtest
** assertion
在 gtest 中，是通过断言（assertion）来判断代码实现的功能是否符合预期。断言的结果分为 success、non-fatal failture 和 fatal failture。

根据断言失败的种类，gtest 提供了两种断言函数：
- success：即断言成功，程序的行为符合预期，程序继续向下允许。
- non-fatal failure：即断言失败，但是程序没有直接 crash，而是继续向下运行。

gtest 提供了宏函数 EXPECT_XXX(expected, actual)：如果 condition(expected, actual)返回 false，则 EXPECT_XXX 产生的就是 non-fatal failure 错误，并显示相关错误。
- fatal failure：断言失败，程序直接 crash，后续的测试案例不会被运行。

gtest 提供了宏函数 ASSERT_XXX(expected, actual)。

在写单元测试时，更加倾向于使用 EXPECT_XXX，因为 ASSERT_XXX 是直接 crash 退出的，可能会导致一些内存、文件资源没有释放，因此可能会引入一些 bug。

具体的 EXPECT_XXX、ASSERT_XXX 函数及其判断条件，如下两个表。
#+DOWNLOADED: screenshot @ 2022-08-23 22:35:24
[[file:images/c++/gtest/2022-08-23_22-35-24_screenshot.png]]
** 参考文章
[[https://zhuanlan.zhihu.com/p/369466622][手把手教你使用gtest写单元测试]]
* leetcode 笔记
** 优先队列
 1046 题

 priority_queue<Type, Container, Functional>

 Type 就是数据类型，Container 就是容器类型（Container 必须是用数组实现的容器，比如 vector,deque 等等，但不能用 list。STL 里面默认用的是 vector），Functional 就是比较的方式。

当需要用自定义的数据类型时才需要传入这三个参数，使用基本数据类型时，只需要传入数据类型，默认是大顶堆
 #+BEGIN_SRC c++
 #include <queue>
 //升序队列
 priority_queue <int,vector<int>,greater<int> > q;
 //降序队列
 priority_queue <int,vector<int>,less<int> >q;

 //greater和less是std实现的两个仿函数（就是使一个类的使用看上去像一个函数。其实现就是类中实现一个operator()，这个类就有了类似函数的行为，就是一个仿函数类了）
 #+END_SRC
*** 自定义比较函数
***** 方式一：struct 重载运算符()
通过 struct 重载()操作符，定义了一个函数对象
#+DOWNLOADED: screenshot @ 2022-11-10 22:37:33
[[file:images/c++/leetcode笔记/2022-11-10_22-37-33_screenshot.png]]
这是属于传入 函数对象 的方式
***** 方式二：class 重载运算符()
通过 class 重载()操作符，定义了一个函数对象
注意要加 public

#+DOWNLOADED: screenshot @ 2022-11-10 22:37:46
[[file:images/c++/leetcode笔记/2022-11-10_22-37-46_screenshot.png]]
这是属于传入 函数对象 的方式
***** 方式三：定义函数
首先定义一个比较函数
#+DOWNLOADED: screenshot @ 2022-11-10 22:37:54
[[file:images/c++/leetcode笔记/2022-11-10_22-37-54_screenshot.png]]
decltype()是用于获得函数指针的 类型的。在模板中也要传入它们的类型。
decltype()要传入的是一个对象的地址，因此需要对 cmp 加取值符，&cmp 为对象的地址
在这里插入图片描述
因此可以由函数地址 cmp 转为函数指针 类型 decltype(&cmp)
#+DOWNLOADED: screenshot @ 2022-11-10 22:38:05
[[file:images/c++/leetcode笔记/2022-11-10_22-38-05_screenshot.png]]
写法一：
#+DOWNLOADED: screenshot @ 2022-11-10 22:38:15
[[file:images/c++/leetcode笔记/2022-11-10_22-38-15_screenshot.png]]
写法二：
如果作为类成员函数，一定要声明 static
#+DOWNLOADED: screenshot @ 2022-11-10 22:38:24
[[file:images/c++/leetcode笔记/2022-11-10_22-38-24_screenshot.png]]
这是属于传入 函数指针的方式。
***** 方式四：lambda 表达式
#+DOWNLOADED: screenshot @ 2022-11-10 22:38:32
[[file:images/c++/leetcode笔记/2022-11-10_22-38-32_screenshot.png]]
这是属于传入 函数指针的方式。
***** 方式五：function 包装 lambda 表达式
要加入头文件#include<functional>

由于 function 对 lambda 函数进行了包装 ,cmp 本身就是一个对象地址。（function 对象）
直接 decltype(cmp)获得函数指针 的类型。
#+DOWNLOADED: screenshot @ 2022-11-10 22:38:41
[[file:images/c++/leetcode笔记/2022-11-10_22-38-41_screenshot.png]]
这是属于传入 函数指针的方式。
*** 参考文章
[[https://blog.csdn.net/qq_21539375/article/details/122128445][c++优先队列priority_queue（自定义比较函数）]]
** 多维数组的定义
 #+BEGIN_SRC c++
 //二维
 vector<vector<int>> a;

 //三维
 vector< vector< vector<int> > > b;
 #+END_SRC
** 数组的初始化
 #+BEGIN_SRC c++
 //一维
 vector<int> a(5,1)  //定义了5维数组,其中的值都为1
 //二维
 vector<vector<int>> a(5，vector<int>(2,1)) //定义了二维数组，第一个维度为5，第二个维度里的每一个数组的维度都为2，值都为1
 //三维
 vector<vector<vector<int>>> dp(2, vector<vector<int>>(3, vector<int>(4, 5)));
 #+END_SRC
** multiset
 set 和 multiset 会根据特定的排序准则，自动将元素进行排序。不同的是后者允许元素重复而前者不允许。
 #+BEGIN_SRC c++
 #include <set>
 multiset<int> st;
 #+END_SRC
 和所有关联式容器类似，通常使用平衡二叉树完成。事实上，set 和 multiset 通常以红黑树实作而成。

 自动排序的优点是使得搜寻元素时具有良好的性能，具有对数时间复杂度。但是造成的一个缺点就是：
 - 不能直接改变元素值。因为这样会打乱原有的顺序。
 - 改变元素值的方法是：先删除旧元素，再插入新元素。
 - 存取元素只能通过迭代器，从迭代器的角度看，元素值是常数。

** 快速排序
 记得要从右边开始循环

 下面这种快速选择的算法也是可以参考的(第 215 题)：
 #+BEGIN_SRC c++
 int search(vector<int>& nums, int left, int right) {
         int x = rand() % (right - left + 1) + left; //随机化选择
         swap(nums[x], nums[left]);
         int p = nums[left];
         int j = left;
         for (int i = left+1; i<=right; i++)
         {
             if (nums[i] < p) {
                 j++;
                 swap(nums[j], nums[i]);
             }
         }
         swap(nums[j], nums[left]);
         return j;
     }
 #+END_SRC

** 随机化
 srand()是给随机数产生器一个种子，time(NULL)就是把当前的时间值作为种子。
 要取得[a,b)的随机整数，使用 ~(rand() % (b-a))+ a~;
 要取得[a,b]的随机整数，使用 ~(rand() % (b-a+1))+ a~;
 要取得(a,b]的随机整数，使用 ~(rand() % (b-a))+ a + 1~;
** c++类型转换
 #+BEGIN_SRC c++
 long long z = static_cast<long long>(nums[right]);
 #+END_SRC
** KMP 算法
 第 28 题
 #+BEGIN_SRC c++
 class Solution {
 public:
     void create(vector<int>& next, string needle) {
         next[0] = -1;
         int j = -1;
         for (int i = 1; i < needle.size(); i++)
         {
             while (j != -1 && needle[i] != needle[j + 1])j = next[j];
             if (needle[i] == needle[j + 1])j++;
             next[i] = j;
         }
     }
     int strStr(string haystack, string needle) {
         if (needle.size() == 0)return 0;
         if (haystack.size() == 0)return -1;
         int n = haystack.size(), m = needle.size();
         vector<int> next(m);
         create(next, needle);
         int j = -1;
         for (int i = 0; i < n; i++) {
             while (j != -1 && haystack[i] != needle[j + 1])j = next[j];
             if (haystack[i] == needle[j + 1])j++;
             if (j == m - 1)return i - m+1;
         }
         return -1;
     }
 };
 #+END_SRC

** reverse
 #+BEGIN_SRC c++
 //给定 matrix = 
 //[
 //  [1,4,7],
 //  [2,5,8],
 //  [3,6,9]
 //]
 //对其以中轴线进行翻转
 for (auto& row : matrix)
     reverse(row.begin(), row.end());
 //结果为：
 //[
 //  [7,4,1],
 //  [8,5,2],
 //  [9,6,3]
 //]
 #+END_SRC
** C++ vector 的 begin()、end()、front()、back() 区别
 一、begin 函数

 函数原型:

 iterator begin();

 const_iterator begin();

 功能：

 返回一个当前 vector 容器中起始元素的迭代器。

 

 二、end 函数

 函数原型：

 iterator end();

 const_iterator end();

 功能：

 返回一个当前 vector 容器中末尾元素的迭代器。

 

 三、front 函数

 函数原型：

 reference front();

 const_reference front();

 功能：

 返回当前 vector 容器中起始元素的引用。

 

 四、back 函数

 函数原型：

 reference back();

 const_reference back();

 功能：

 返回当前 vector 容器中末尾元素的引用。

 leetcode 第 56 题
 #+BEGIN_SRC c++
 class Solution {
 public:
     vector<vector<int>> merge(vector<vector<int>>& intervals) {
         if (intervals.size() == 0)return {};
         sort(intervals.begin(), intervals.end());
         vector<vector<int>> merged;
         for (int i = 0; i < intervals.size(); i++) {
             int l = intervals[i][0], r = intervals[i][1];
             if (!merged.size() || merged.back()[1] < l) {
                 merged.push_back({ l,r });
             }
             else {
                 merged.back()[1] = max(merged.back()[1], r);
             }
         }
         return merged;
     }
 };
 #+END_SRC
** 形参传值和传引用运行速度的差异
 C++在做递归回溯算法相关题目时，递归函数形参传值和传引用运行速度有很大的差异。

 这是我第 79 题 dfs 函数的声明，主要区别是 visited 和 word，一个是传值，一个是传引用。前者执行超时，后者在本题是 32ms.

 个人理解为传值时每次递归调用都要在内存中新建立一个 vector 来保存 visit 传入的值，但是传引用直接在 visited 原始位置操作，不需要进行新建变量与赋值，节省了代码运行的空间与时间开销。
 #+BEGIN_SRC c++
 void dfs(vector<vector<char>>& board,vector<vector<int>>visited,int x,int y,int n,string word,bool& flag)
 void dfs(vector<vector<char>>& board,vector<vector<int>>& visited,int x,int y,int n
 #+END_SRC

** map 的迭代器用法
 第 90 题
 #+BEGIN_SRC c++
 class Solution {
 public:
     vector<vector<int>> subsetsWithDup(vector<int>& nums) {
         map<int,int> num;
         for (int i = 0; i < nums.size(); i++)
         {
             num[nums[i]]++;
         }
         vector<vector<int>> ans = { {} };
         for (auto t : num) {
             int n = ans.size();
             for (int i = 0; i < n; i++) {
                 vector<int> temp = ans[i];
                 for (int j = 0; j < t.second; j++)
                 {
                     temp.push_back(t.first);
                     ans.push_back(temp);
                 }
             }
         }
         return ans;
     }
 };
 #+END_SRC
** 字符串
*** 字符串连接
  string res = ""
  可以用 res+="V" 表示字符串 "V"
*** 关于 insert 和 erase 的用法
 #+BEGIN_SRC c++
 class Solution {
 public:
     vector<string> ans;
     vector<string> restoreIpAddresses(string s) {
         string cur = s;
         int n = s.size();
         helper(0, -1, n, s, cur);
         return ans;
     }
     void helper(int point_count,int last_point,int n,string &s,string &cur) {
         if (point_count == 3) {
             if (check(last_point + 1, n - 1, s)) {
                 ans.push_back(cur);
             }
             return;
         }
         for (int i = last_point+1; i < n-1; i++)
         {
             if (check(last_point + 1, i, s)) {
                 //注意这里Insert加了cur.being(),而后面的erase()没加
                 cur.insert(cur.begin() + i + point_count + 1, '.');
                 helper(point_count + 1, i,n, s, cur);
                 cur.erase(i + point_count + 1, 1);
             }
         }
         return;
     }
     bool check(int left, int right, string& s) {
         int num = 0;
         for (int i = left; i <=right; i++)
         {
             if (s[left] == '0' && left != right)return false;
             num = num * 10 + s[i] - '0';
             if (num > 255)return false;
         }
         return true;
     }
 };
 #+END_SRC
** 用迭代实现二叉树中序遍历
 第 94 题

 核心思想:
 - 使用颜色标记节点的状态，新节点为白色，已访问的节点为灰色。
 - 如果遇到的节点为白色，则将其标记为灰色，然后将其右子节点、自身、左子节点依次入栈。
 - 如果遇到的节点为灰色，则将节点的值输出。

 python 版本:
 #+BEGIN_SRC python
 class Solution:
     def inorderTraversal(self, root: TreeNode) -> List[int]:
         WHITE, GRAY = 0, 1
         res = []
         stack = [(WHITE, root)]
         while stack:
             color, node = stack.pop()
             if node is None: continue
             if color == WHITE:
                 stack.append((WHITE, node.right))
                 stack.append((GRAY, node))
                 stack.append((WHITE, node.left))
             else:
                 res.append(node.val)
         return res
 #+END_SRC
 c++版本
 #+BEGIN_SRC c++
 class Solution {
	 vector<int>ans;
 public:
	 vector<int> inorderTraversal(TreeNode* root) {
		 int white = 0;
		 int gray = 1;
		 stack<pair<int, TreeNode*>>s;
		 s.push(make_pair(white,root));
		 while (!s.empty())
		 {
			 int color = s.top().first;
			 TreeNode* t = s.top().second;
			 s.pop();
			 if (t == NULL) continue;
			 if (color == white)
			 {
				 s.push(make_pair(white, t->right));
				 s.push(make_pair(gray, t));
				 s.push(make_pair(white, t->left));
			 }
			 else ans.push_back(t->val);
		 }
		 return ans;
	 }
 };
 #+END_SRC
** 函数返回指针
 第 116 题
 #+BEGIN_SRC c++
 class Solution {
 public:
     Node* connect(Node* root) {
         if (root == NULL)return NULL;
         auto left = root->left;
         auto right = root->right;
         while (left!=NULL)
         {
             left->next = right;
             left = left->right;
             right = right->left;
         }
         connect(root->left);  //注意这里不需要设置一个向量来存储函数范围的指针
         connect(root->right); //注意这里不需要设置一个向量来存储函数范围的指针
         return root;
     }
 };
 #+END_SRC
** 如何把一个整数转化为 string
*** string 转 int 的方式
 采用最原始的 string, 然后按照十进制的特点进行算术运算得到 int，但是这种方式太麻烦，这里不介绍了。

 采用标准库中 atoi 函数。

 string s = "12"; 
 int a = atoi(s.c_str()); 
 对于其他类型也都有相应的标准库函数，比如浮点型 atof(),long 型 atol()等等。

 采用 sstream 头文件中定义的字符串流对象来实现转换。

 istringstream is("12"); //构造输入字符串流，流的内容初始化为“12”的字符串 
 int i; 
 is >> i; //从 is 流中读入一个 int 整数存入 i 中

*** int 转 string 的方式
 采用标准库中的 to_string 函数。

 int i = 12; 
 cout << std::to_string(i) << endl; 
 不需要包含任何头文件，应该是在 utility 中，但无需包含，直接使用，还定义任何其他内置类型转为 string 的重载函数，很方便。

 采用 sstream 中定义的字符串流对象来实现。

 ostringstream os; //构造一个输出字符串流，流内容为空 
 int i = 12; 
 os << i; //向输出字符串流中输出 int 整数 i 的内容 
 cout << os.str() << endl; //利用字符串流的 str 函数获取流中的内容 
 字符串流对象的 str 函数对于 istringstream 和 ostringstream 都适用，都可以获取流中的内容。

** c++ 将一个 char 转化为 string
 #+BEGIN_SRC c++
 const char c = 'a';
 //1.使用 string 的构造函数
 string s(1,c);
 //2.声明string 后将char push_back
 string s1;
 s1.push_back(c);
 //3.使用stringstream
 stringstream ss;
 ss << c;
 string str2 = ss.str();

 //注意 使用to_string 方法会转化为char对应的ascii码
 //原因是 to_string 没有接受char型参数的函数原型，有一个参数类型
 //为int 的函数原型，所以传入char型字符 实际是先将char 转化
 //为int 型的ascii 码，然后再转变为string
 //以下输出结果为 97
 cout << to_string(c) << endl;
 #+END_SRC
** 除留余数法
 给定一个正整数，返回它在 Excel 表中相对应的列名称。

 例如，

     1 -> A
     2 -> B
     3 -> C
     ...
     26 -> Z
     27 -> AA
     28 -> AB 
     ...
 示例 1:

 输入: 1
 输出: "A"
 示例 2:

 输入: 28
 输出: "AB"
 示例 3:

 输入: 701
 输出: "ZY"
 #+BEGIN_SRC c++
 class Solution {
 public:
	 string convertToTitle(int n) {
		 string ans;
		 while (n != 0)
		 {
			 n--;
			 char c = n% 26 + 'A';
			 string temp(1, c);
			 ans = temp + ans;
			 n /= 26;
		 }
		 return ans;
	 }
 };  
 #+END_SRC
 下面是我的错误解法：
 #+BEGIN_SRC c++
 class Solution {
 public:
	 string convertToTitle(int n) {
		 string ans;
		 while (n != 0)
		 {
			 char c = (n-1)% 26 + 'A';
			 string temp(1, c);
			 ans = temp + ans;
			 n /= 26;
		 }
		 return ans;
	 }
 };  
 #+END_SRC
 这种解法在 n=701(zy)时输出的结果为 AZY，是错误的。
** 谓词、lambda 表达式

 第 179 题

 给定一组非负整数 nums，重新排列它们每位数字的顺序使之组成一个最大的整数。

 注意：输出结果可能非常大，所以你需要返回一个字符串而不是整数。

  

 示例 1：

 输入：nums = [10,2]
 输出："210"
 示例 2：

 输入：nums = [3,30,34,5,9]
 输出："9534330"
 示例 3：

 输入：nums = [1]
 输出："1"
 示例 4：

 输入：nums = [10]
 输出："10"
  

 提示：

 1 <= nums.length <= 100
 0 <= nums[i] <= 109

 来源：力扣（LeetCode）
 链接：https://leetcode-cn.com/problems/largest-number
 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

 #+BEGIN_SRC c++
 class Solution {
 public:
     string largestNumber(vector<int>& nums) {
         if (all_of(nums.begin(), nums.end(), [](int x) {return x == 0; })) {
             return string("0");
         }
         vector<string> strNums(nums.size());
         std::transform(nums.begin(), nums.end(), strNums.begin(), [](int x) {return std::to_string(x); });
         std::sort(strNums.begin(), strNums.end(), [](const string& x, const string& y) {   //这里string& x不加&也是可以通过的
             return x + y > y + x;
             });
         return std::accumulate(strNums.begin(), strNums.end(), string());
     }
 };
 #+END_SRC
** 桶排序
 第 220 题

 在整数数组 nums 中，是否存在两个下标 i 和 j，使得 nums [i] 和 nums [j] 的差的绝对值小于等于 t ，且满足 i 和 j 的差的绝对值也小于等于 ķ 。

 如果存在则返回 true，不存在返回 false。

 示例 1:

 输入: nums = [1,2,3,1], k = 3, t = 0
 输出: true
 示例 2:

 输入: nums = [1,0,1,1], k = 1, t = 2
 输出: true
 示例 3:

 输入: nums = [1,5,9,1,5,9], k = 2, t = 3
 输出: false

 #+BEGIN_EXAMPLE
 我们将数据分到 M 个桶 中。
 每个数字nums[i] 都被我们分配到一个桶中
 分配的依据就是 nums[i] // (t + 1)
 这样相邻桶内的数字最多相差2 * t + 1
 不相邻的桶一定不满足相差小于等于t
 同一个桶内的数字最多相差t
 因此如果命中同一个桶内，那么直接返回True
 如果命中相邻桶，我们再判断一下是否满足 相差 <= t
 否则返回False
 需要注意的是，由于题目有索引相差k的要求，因此要维护一个大小为k的窗口，定期清除桶中过期的数字。
 #+END_EXAMPLE

 #+BEGIN_SRC c++
 class Solution {
 public:
     bool containsNearbyAlmostDuplicate(vector<int>& nums, int k, int t) {
         if(t<0) return false;
         //t+1可能会溢出，所以要+ 1LL
         long long mod = t + 1LL;
         unordered_map<long long,long long> buck;
         for(int i=0;i<nums.size();i++)
         {
             long long nth = nums[i] / mod;
             //可能nums[i]为负数，比如-4 / 5 以及 -4 / 5都等于0，所以负数要向下移动一位
             if(nums[i] < 0) nth--;
             //这里要用find 不能直接[],因为可能本身存储的数字就为0
             if(buck.find(nth)!=buck.end()) 
                 return true;
             else if(buck.find(nth-1)!=buck.end() && abs(nums[i] - buck[nth-1]) <= t)
                 return true;
             else if(buck.find(nth+1)!=buck.end() && abs(nums[i] - buck[nth+1]) <= t)
                 return true;
             buck[nth] = nums[i];
             if(i >= k)
             {
                 buck.erase(nums[i - k] / mod);
             }
         }
         return false;
     }
 };
 #+END_SRC

** 由 vector 创建 set
 217. 存在重复元素

 #+BEGIN_EXAMPLE
 给定一个整数数组，判断是否存在重复元素。

 如果任意一值在数组中出现至少两次，函数返回 true 。如果数组中每个元素都不相同，则返回 false 。

  

 示例 1:

 输入: [1,2,3,1]
 输出: true
 示例 2:

 输入: [1,2,3,4]
 输出: false
 示例 3:

 输入: [1,1,1,3,3,4,3,2,4,2]
 输出: true

 #+END_EXAMPLE
 利用集合，与原数组比较大小
 #+BEGIN_SRC c++
 class Solution {
 public:
     bool containsDuplicate(vector<int>& nums) {

          return nums.size() > unordered_set<int>(nums.begin(), nums.end()).size(); 
          //如果原数组的大小>集合的大小，则说明存在重复元素
     }
 };
 #+END_SRC
** 取中点避免溢出的技巧
 二分查找中，计算 mid 时需要防止溢出，代码中 left + (right - left) / 2 就和 (left + right) / 2 的结果相同，但是有效防止了 left 和 right 太大直接相加导致溢出。
** 异或运算
 异或运算有以下三个性质。
 - 任何数和 0 做异或运算，结果仍然是原来的数
 - 任何数和其自身做异或运算，结果是 0 .
 - 异或运算满足交换律和结合律.

** stol 用法
 std::stol()：此函数将参数提供的字符串转换为 long long。它解析 str 并将其内容解释为指定基数的整数，并将其作为 long long 类型的值返回。

 Convert string to long long

 Parses str interpreting its content as an integral number of the specified base, which is returned as a value of type long long.

 If idx is not a null pointer, the function also sets the value of idx to the position of the first character in str after the number.

 The function uses strtoll (or wcstoll) to perform the conversion (see strtol for more details on the process).
 #+BEGIN_SRC c++
 long long stoll (const string&  str, size_t* idx = 0, int base = 10);
 long long stoll (const wstring& str, size_t* idx = 0, int base = 10);
 #+END_SRC
 参数：
 - str
 String object with the representation of an integral number.
 - idx
 Pointer to an object of type size_t, whose value is set by the function to position of the next character in str after the numerical value.
 This parameter can also be a null pointer, in which case it is not used.
 - base
 Numerical base (radix) that determines the valid characters and their interpretation.
 If this is 0, the base used is determined by the format in the sequence (see strtol for details). Notice that by default this argument is 10, not 0.

 #+BEGIN_SRC c++
 // stoll example
 #include <iostream>   // std::cout
 #include <string>     // std::string, std::stoll

 int main ()
 {
   std::string str = "8246821 0xffff 020";

   std::string::size_type sz = 0;   // alias of size_t

   while (!str.empty()) {
     long long ll = std::stoll (str,&sz,0);
     std::cout << str.substr(0,sz) << " interpreted as " << ll << '\n';
     str = str.substr(sz);
   }

   return 0;
 }
 #+END_SRC

 #+BEGIN_EXAMPLE
 8246821 interpreted as 8246821
  0xffff interpreted as 65535
  020 interpreted as 16
 #+END_EXAMPLE
** 一个包含所有 c++的头文件的头文件

 #include<bits/stdc++.h>包含了目前 c++所包含的所有头文件
** pair
 337 题 打家劫舍 III

 在上次打劫完一条街道之后和一圈房屋后，小偷又发现了一个新的可行窃的地区。这个地区只有一个入口，我们称之为“根”。 除了“根”之外，每栋房子有且只有一个“父“房子与之相连。一番侦察之后，聪明的小偷意识到“这个地方的所有房屋的排列类似于一棵二叉树”。 如果两个直接相连的房子在同一天晚上被打劫，房屋将自动报警。

 计算在不触动警报的情况下，小偷一晚能够盗取的最高金额。

 示例 1:

 输入: [3,2,3,null,3,null,1]

      3
     / \
    2   3
     \   \ 
      3   1

 输出: 7 
 解释: 小偷一晚能够盗取的最高金额 = 3 + 3 + 1 = 7.
 示例 2:

 输入: [3,4,5,1,3,null,1]

      3
     / \
    4   5
   / \   \ 
  1   3   1

 输出: 9
 解释: 小偷一晚能够盗取的最高金额 = 4 + 5 = 9.


 创建元组：
 #+BEGIN_EXAMPLE
 make_pair(0,0);
 pair<int, int> left = helper(root->left);
 #+END_EXAMPLE



 #+BEGIN_SRC c++
 #include <pair>
 class Solution {
 public:
     pair<int, int> helper(TreeNode* root) {
         if (root == NULL)return make_pair(0,0);
         pair<int, int> left = helper(root->left);
         pair<int, int> right = helper(root->right);

         return make_pair(root->val + left.second + right.second, max(left.first, left.second) + max(right.first, right.second));
     }
     int rob(TreeNode* root) {
         pair<int, int> ans = helper(root);
         return max(ans.first, ans.second);
     }
 };
 #+END_SRC

