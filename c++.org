* auto
** 静态类型，动态类型和类型推导
在编程语言分类中，C/C++C常常被认为是静态类型的语言。而有的编程语言则号称是“动态类型”的，比如python。通常情况下，“静”和“动”的区别是非常直观的。我们看看下面这段简单的python代码：   
#+BEGIN_SRC python 
name=‘world\n’
print 'hello, ' %name
#+END_SRC
这段代码中python中的一个hellowworld的实现。这就是编程语言中的“动态类型”,在运行时来进行类型检查，而C++中类型检查是在编译阶段。动态类型语言能做到在运行时决定类型，主要归功于一技术，这技术是类型推导。

事实上，类型推导也可以用于静态类型语言中。比如上面的python代码中，如果按照C/C++程序员的思考方式，world\n表达式应该可以返回一个临时的字符串，所以即使name没有进行声明，我们也能轻松低推导出name的类型应该是一个字符串类型。在C++11中，这个想法得到了实现。C++11中类型推导的实现之一就是重定义auto关键字，另一个实现是decltype。

我们可以使用C++11方式来书写刚才的python的代码
#+BEGIN_SRC c++
#include <iostream>
using namespace std;
int main()
{
  auto name=‘world\n’
  cout<<"hello   "<<name<<endl;
 
}
#+END_SRC

这里使用auto关键字来要求编译器对变量name的类型进行了自动推导。这里编译器根据它的初始化表达式的类型，推导出name的类型为char*。事实上，atuo关键字在早期的C/C++标准中有着完全不同的含义。声明时使用auto修饰的变量，按照早期C/C++标准的解释，是具有自动存储期的局部变量。不过那时情况是该关键字几乎无人使用，因为一般函数内没有声明为static的变量总是具有自动存储期的局部变量。auto声明变量的类型必须又编译器在编译时期推导而得。

通过以下例子来了解以下auto类型推导的基本用法
#+BEGIN_SRC c++
#include <iostream>
using namespace std;
int main()
{
     double foo();
	 auto x=1;
	 auto y=foo();
	 struct m
	 {
	     int i;
	 }str;
	 auto str1=str;
	 auto z;
	 z=x;
}
#+END_SRC
以上变量x被初始化为1，因为字面变量1的类型是const int，所以编译器推导出x的类型应该为int（这里const类型限制符被去掉了，后面会解释）。同理在变量y的定义中，auto类型的y被推导为double类型；而在auto str1的定义中，其类型被推导为struct m。这里的z，使用auto关键字来声明，但是不立即对其进行定义，此时编译器则会报错。这跟通过其他关键字（除去引用类型的关键字）先声明后定义的变量的使用规则是不同的。auto声明的变量必须被初始化，以使编译器能够从其初始化表达式中推导出其类型。这个意义上，auto并非一种类型声明，而是一个类型声明时的“占位符”，编译器在便已是亲会将suto替代为变量实际的类型。
** auto的优势
*** 简化代码
1.直观地，auto推导的一个最大的优势在于拥有初始化表达式的复杂类型变量声明时简化代码。由于C++的发展，变量类型变得越来越复杂。但是很多时候，名字空间、模板成为类型的一部分，导致了程序员在使用库的时候如履薄冰。
#+BEGIN_SRC c++
#include <string>
#include <vector>
void loopover(std::vector<std::string>&vs)
{
    std::vector<std::string>::iterator i=vs.begin();
	for(;i<vs.end();i++)
	{
	
	}
 
}
#+END_SRC
#+BEGIN_SRC c++
<pre name="code" class="cpp">#include <string>
#include <vector>
void loopover(std::vector<std::string>&vs)
{
	for(  auto i=vs.begin();;i<vs.end();i++)
	{
	
	}
 
}
#+END_SRC
使用std::vector<std::string>::iterator来定义i是C++常用的良好的习惯，但是这样长的声明带来了代码可读性的困难，因此引入auto，使代码可读性增加。并且使用STL将会变得更加容易
*** 避免声明类型错误
可以避免类型声明时的麻烦而且避免类型声明时的错误。事实上，在C/C++中，存在着很多隐式或者是用户自定义类型的转换规则（比如整型与字符型进行加法运算后，表达式返回整型，这是一条隐式规则）。这些规则并非容易记忆，尤其是在用户自定义很多操作符以后，这个时候auto就有用户之地了。看一下例子
#+BEGIN_SRC c++
class PI
{
   public :
          double operator*(float v)
		  {
		     return (double)val*v;
		  }
          const float val=3.1415927f;
}

int main()
{
          float radius=1.7e10;
	  PI pi;
	  auto circumference =2*(pi*radius);
}
#+END_SRC
上面定义了一个float类型的变量radius（半径）以及一个自定义类型PI的变量pi,在计算周长的时候，使用auto类型来定义变量circumference。这里PI在于float类型数据相乘时，其返回值为double。而PI得定义可能是在其他的地方（头文件里），main函数的程序可能就不知道PI的作者为了避免数据上溢或者是精度上的降低而返回了double类型的浮点数。因此main函数程序员如果使用float类型声明circumference，就可能会享受不了PI作者细心设计带来的好处。反之，将circumference声明为auto，则毫无问题，因为编译器已经做了最好的选择。

但是auto不能解决所有的精度问题。下面例子
#+BEGIN_SRC c++
#include <iostream>
using namespace std;
int main()
{
   unsigned int a=4294967295;//最大的unsigned int值
   unsigned int b=1；
   auto c=a+b;
   cout<<"a="<<a<<endl;
   cout<<"b="<<b<<endl;
   cout<<"c="<<c<<endl;
}
#+END_SRC
上面代码中，程序员希望通过声明变量c为auto就能解决a+b溢出的问题。而实际上由于a+b返回的依然是unsigned int的值，姑且c的类型依然被推导为unsigned int，auto并不能帮上忙。这个跟动态类型语言中数据自动进行拓展的特性还是不一样的。
*** 支持泛型编程
在C++中其“自适应”性能够在一定程度上支持泛型的编程。

 回到上面class PI的例子，这里假设PI的作者改动了PI的定义，比如讲operator*返回值变为long  double，此时，main函数并不需要修改，因为auto会“自适应”新的类型。同理，对于不同平台上的二代马维护，auto也会带来一些“泛型”的好处。这里我们一strlen函数为例，在32位编译环境下，strlen返回的为一个4字节的整型，在64位的编译环境下，strlen会返回一个8字节的整型。即使系统库中<cstring>为其提供了size_t类型来支持多平台间的代码共享支持，但是使用auto关键字我们同样可以达到代码跨平台的效果。

~auto var=strlen("hello world")~

由于size_t的适用性范围往往局限于<cstring>中定义的函数，auto的适用范围明显更为广泛。

当auto应用于模板的定义中，其"自适应"性会得到更加充分的体现。我们可以看看以下例子
#+BEGIN_SRC c++
template<typename T1,typename T2>
double Sum(T1&t1,T2&t2)
{
        auto a=t1+t2;
	return a;
}
int main()
{
        int a=3;
	long b=5;
	float c=1.0f;
	float d=2.3f;
	auto e=Sum<int,long>(a,b); //e的类型被推导为long
	auto f=Sum<float,float>(c,d);//s的类型被推导为float
}
#+END_SRC
上面中Sum模板函数接受两个参数。由于T1，T2要在模板实例化时才能确定，所以Sum中将变量s的类型声明为auto的。在函数main中我们将模板实例化时。Sum<int,long>中的s变量会被推导为long类型，而Sum<float,float>中的s变量则会被推导为float。可以看到，auto与模板一起使用时，其“自适应”特性能够加强C++中泛型的能力。
** auto的使用注意细节
1. 我们可以使用valatile，pointer（*），reference（&），rvalue reference（&&） 来修饰auto
#+BEGIN_SRC c++
auto k = 5;
auto* pK = new auto(k);
auto** ppK = new auto(&k);
const auto n = 6;
#+END_SRC
2. 用auto声明的变量必须初始化

~auto m; // m should be intialized~

3. auto不能与其他类型组合连用

~auto int p; // 这是旧auto的做法~

4. 函数和模板参数不能被声明为auto
#+BEGIN_SRC c++
void MyFunction(auto parameter){} // no auto as method argument
template<auto T> // utter nonsense - not allowed
void Fun(T t){}
#+END_SRC
5. 定义在堆上的变量，使用了auto的表达式必须被初始化
#+BEGIN_SRC c++
int* p = new auto(0); //fine
int* pp = new auto(); // should be initialized
auto x = new auto(); // Hmmm ... no intializer
auto* y = new auto(9); // Fine. Here y is a int*
auto z = new auto(9); //Fine. Here z is a int* (It is not just an int)
#+END_SRC
6. 以为auto是一个占位符，并不是一个他自己的类型，因此不能用于类型转换或其他一些操作，如sizeof和typeid
#+BEGIN_SRC c++
int value = 123;
auto x2 = (auto)value; // no casting using auto
auto x3 = static_cast<auto>(value); // same as above 
#+END_SRC
7. 定义在一个auto序列的变量必须始终推导成同一类型
#+BEGIN_SRC c++
auto x1 = 5, x2 = 5.0, x3='r';  // This is too much....we cannot combine like this
#+END_SRC
8. auto不能自动推导成CV-qualifiers（constant & volatile qualifiers），除非被声明为引用类型
#+BEGIN_SRC c++ 
const int i = 99;
auto j = i;       // j is int, rather than const int
j = 100           // Fine. As j is not constant
// Now let us try to have reference
auto& k = i;      // Now k is const int&
k = 100;          // Error. k is constant
// Similarly with volatile qualifer
#+END_SRC
9. auto会退化成指向数组的指针，除非被声明为引用
#+BEGIN_SRC c++
int a[9];
auto j = a;
cout<<typeid(j).name()<<endl; // This will print int*
auto& k = a;
cout<<typeid(k).name()<<endl; // This will print int [9]
#+END_SRC
符号 & 表明是一个引用变量，能让接下来的代码能够修改数组的内容，而第一种语法不能。
** 遍历
*** 遍历unordered_map
#+begin_src c++
unordered_map<char, int> mp;
for (auto& x : mp) {
    buckets[x.second].push_back(x.first);
}
#+END_SRC

* boolalpha
Sets the boolalpha format flag for the str stream.

When the boolalpha format flag is set, bool values are inserted/extracted by their textual representation: either true or false, instead of integral values.

example:
#+BEGIN_SRC c++
// modify boolalpha flag
#include <iostream>     // std::cout, std::boolalpha, std::noboolalpha

int main () {
  bool b = true;
  std::cout << std::boolalpha << b << '\n';
  std::cout << std::noboolalpha << b << '\n';
  return 0;
}
#+END_SRC
#+BEGIN_EXAMPLE
Output:
true
1
#+END_EXAMPLE
* C++四种类型转换运算符
隐式类型转换是安全的，显式类型转换是有风险的，C语言之所以增加强制类型转换的语法，就是为了强调风险，让程序员意识到自己在做什么。

但是，这种强调风险的方式还是比较粗放，粒度比较大，它并没有表明存在什么风险，风险程度如何。再者，C风格的强制类型转换统一使用( )，而( )在代码中随处可见，所以也不利于使用文本检索工具（例如 Windows 下的 Ctrl+F、Linux 下的 grep 命令、Mac 下的 Command+F）定位关键代码。

为了使潜在风险更加细化，使问题追溯更加方便，使书写格式更加规范，C++ 对类型转换进行了分类，并新增了四个关键字来予以支持，它们分别是：
| 关键字           | 说明                                                                                                                          |
|------------------+-------------------------------------------------------------------------------------------------------------------------------|
| static_cast      | 用于良性转换，一般不会导致意外发生，风险很低。                                                                                |
| const_cast       | 用于 const 与非 const、volatile 与非 volatile 之间的转换。                                                                    |
| reinterpret_cast | 高度危险的转换，这种转换仅仅是对二进制位的重新解释，不会借助已有的转换规则对数据进行调整，但是可以实现最灵活的 C++ 类型转换。 |
| dynamic_cast     | 借助 RTTI，用于类型安全的向下转型（Downcasting）。                                                                            |
这四个关键字的语法格式都是一样的，具体为：
#+BEGIN_SRC c++
xxx_cast<newType>(data)
#+END_SRC
newType 是要转换成的新类型，data 是被转换的数据。例如，老式的C风格的 double 转 int 的写法为：
#+BEGIN_SRC c
double scores = 95.5;
int n = (int)scores;
#+END_SRC
C++ 新风格的写法为：
#+BEGIN_SRC c++
double scores = 95.5;
int n = static_cast<int>(scores);
#+END_SRC

** static_cast
static_cast 只能用于良性转换，这样的转换风险较低，一般不会发生什么意外，例如：
原有的自动类型转换，例如 short 转 int、int 转 double、const 转非 const、向上转型等；
void 指针和具体类型指针之间的转换，例如 ~void *~ 转 ~int *~ 、 ~char *~ 转 ~void *~ 等；
有转换构造函数或者类型转换函数的类与其它类型之间的转换，例如 double 转 Complex（调用转换构造函数）、Complex 转 double（调用类型转换函数）。

需要注意的是，static_cast 不能用于无关类型之间的转换，因为这些转换都是有风险的，例如：
两个具体类型指针之间的转换，例如int *转double *、Student *转int *等。不同类型的数据存储格式不一样，长度也不一样，用 A 类型的指针指向 B 类型的数据后，会按照 A 类型的方式来处理数据：如果是读取操作，可能会得到一堆没有意义的值；如果是写入操作，可能会使 B 类型的数据遭到破坏，当再次以 B 类型的方式读取数据时会得到一堆没有意义的值。
int 和指针之间的转换。将一个具体的地址赋值给指针变量是非常危险的，因为该地址上的内存可能没有分配，也可能没有读写权限，恰好是可用内存反而是小概率事件。

static_cast 也不能用来去掉表达式的 const 修饰和 volatile 修饰。换句话说，不能将 const/volatile 类型转换为非 const/volatile 类型。

static_cast 是“静态转换”的意思，也就是在编译期间转换，转换失败的话会抛出一个编译错误。

下面的代码演示了 static_cast 的正确用法和错误用法：
#+BEGIN_SRC c++
#include <iostream>
#include <cstdlib>
using namespace std;

class Complex{
public:
    Complex(double real = 0.0, double imag = 0.0): m_real(real), m_imag(imag){ }
public:
    operator double() const { return m_real; }  //类型转换函数
private:
    double m_real;
    double m_imag;
};

int main(){
    //下面是正确的用法
    int m = 100;
    Complex c(12.5, 23.8);
    long n = static_cast<long>(m);  //宽转换，没有信息丢失
    char ch = static_cast<char>(m);  //窄转换，可能会丢失信息
    int *p1 = static_cast<int*>( malloc(10 * sizeof(int)) );  //将void指针转换为具体类型指针
    void *p2 = static_cast<void*>(p1);  //将具体类型指针，转换为void指针
    double real= static_cast<double>(c);  //调用类型转换函数
   
    //下面的用法是错误的
    float *p3 = static_cast<float*>(p1);  //不能在两个具体类型的指针之间进行转换
    p3 = static_cast<float*>(0X2DF9);  //不能将整数转换为指针类型

    return 0;
}
#+END_SRC

** const_cast 
const_cast 比较好理解，它用来去掉表达式的 const 修饰或 volatile 修饰。换句话说，const_cast 就是用来将 const/volatile 类型转换为非 const/volatile 类型。

下面我们以 const 为例来说明 const_cast 的用法：
#+BEGIN_SRC c++
#include <iostream>
using namespace std;

int main(){
    const int n = 100;
    int *p = const_cast<int*>(&n);
    *p = 234;
    cout<<"n = "<<n<<endl;
    cout<<"*p = "<<*p<<endl;

    return 0;
}
#+END_SRC
运行结果：
n = 100
*p = 234

~&n~ 用来获取 n 的地址，它的类型为 ~const int *~ ，必须使用 const_cast 转换为 ~int *~ 类型后才能赋值给 p。由于 p 指向了 n，并且 n 占用的是栈内存，有写入权限，所以可以通过 p 修改 n 的值。

有读者可能会问，为什么通过 n 和 *p 输出的值不一样呢？这是因为 C++ 对常量的处理更像是编译时期的 ~#define~ ，是一个值替换的过程，代码中所有使用 n 的地方在编译期间就被替换成了 100。换句话说，第 8 行代码被修改成了下面的形式：
#+BEGIN_SRC c++
cout<<"n = "<<100<<endl;
#+END_SRC
这样一来，即使程序在运行期间修改 n 的值，也不会影响 cout 语句了。

使用 const_cast 进行强制类型转换可以突破 C/C++ 的常数限制，修改常数的值，因此有一定的危险性；但是程序员如果这样做的话，基本上会意识到这个问题，因此也还有一定的安全性。

** reinterpret_cast
reinterpret 是“重新解释”的意思，顾名思义，reinterpret_cast 这种转换仅仅是对二进制位的重新解释，不会借助已有的转换规则对数据进行调整，非常简单粗暴，所以风险很高。

reinterpret_cast 可以认为是 static_cast 的一种补充，一些 static_cast 不能完成的转换，就可以用 reinterpret_cast 来完成，例如两个具体类型指针之间的转换、int 和指针之间的转换（有些编译器只允许 int 转指针，不允许反过来）。

下面的代码代码演示了 reinterpret_cast 的使用：
#+BEGIN_SRC c++
#include <iostream>
using namespace std;

class A{
public:
    A(int a = 0, int b = 0): m_a(a), m_b(b){}
private:
    int m_a;
    int m_b;
};

int main(){
    //将 char* 转换为 float*
    char str[]="http://c.biancheng.net";
    float *p1 = reinterpret_cast<float*>(str);
    cout<<*p1<<endl;
    //将 int 转换为 int*
    int *p = reinterpret_cast<int*>(100);
    //将 A* 转换为 int*
    p = reinterpret_cast<int*>(new A(25, 96));
    cout<<*p<<endl;
   
    return 0;
}
#+END_SRC
运行结果：
3.0262e+29
25

可以想象，用一个 float 指针来操作一个 char 数组是一件多么荒诞和危险的事情，这样的转换方式不到万不得已的时候不要使用。将 ~A*~ 转换为 ~int*~ ，使用指针直接访问 private 成员刺穿了一个类的封装性，更好的办法是让类提供 get/set 函数，间接地访问成员变量。

** dynamic_cast
这部分内容我省略没写。
* C++ STL vector添加元素（push_back()和emplace_back()）详解
emplace_back() 和 push_back() 的区别，就在于底层实现的机制不同。push_back() 向容器尾部添加元素时，首先会创建这个元素，然后再将这个元素拷贝或者移动到容器中（如果是拷贝的话，事后会自行销毁先前创建的这个元素）；而 emplace_back() 在实现时，则是直接在容器尾部创建这个元素，省去了拷贝或移动元素的过程。
* 重载
重载指的是同一作用域内的几个函数名字相同但形参（形参数量或者形参类型）不同。
** 返回值不影响判断
返回值的不同不能用于区分重载函数。不允许同时存在除了返回类型外其他所有要素都相同的两个函数。
** 参数默认值不影响判断
下面两个函数是互相覆盖的关系
#+begin_src c++
  int myfunc(int a,double b);

  int myfunc(int a,double b=0.5);
#+END_SRC
** 形参名字不影响判断
#+begin_src c++
Record lookup (const Account &acct);
Record lookup (const Account&);

typedef Phone Telno;
Record lookup(const Phone&);
Record lookup(const Telno&);
#+end_src

** const形参的判断方式
*** 顶层const不影响判断
#+begin_src c++
  Record lookup(const Phone);
  Record lookup(Phone);//重复声明

  Record lookup(Phone*);
  Record lookup(Phone* const);//重复声明
#+END_SRC
*** 底层const影响判断
#+begin_src c++
  Record lookup(Account&);//函数作用于Account的引用
  Record lookup(const Account&);//新函数,作用于常量引用

  Record lookup(Account*);//新函数,作用于指向Account的指针
  Record lookup(const Account*);//新函数,作用于指向常量的指针
#+END_SRC
由于非常量对象可以转换成const,所以上面4个函数都能作用于非常
量对象或者指向非常量对象的指针,此时编译器会优先选用非常量版本的函数.
** 隐式转换
*** 整型提升
将char、unsigned char、signed char、shot、unsigned short转换为int 或unsigned int。
*** 整型转换
可以在任意的两种整数类型中转换。
** 重载匹配顺序
精确匹配、类型提升、类型转换。

其中，一般的整型转换没有先后顺序。

** 重载与作用域
如果在内层作用域声明名字，将会隐藏外层作用域中声明的同名实体。在不同的作用域中无法重载函数名
#+begin_src c++
  string read();
  void print(const string &);
  void print(double);//重载print函数
  void fooBar(int ival)
  {
    bool read=false;//新作用域，隐藏了外层的read
    string s=read();//错误，read此时是一个布尔值
    void print(int);//新作用域，隐藏了之前的print
    print("Value:" );//错误
    print(ival);//正确
    print(3.14);//正确，此时调用的是print(int)
  }
#+END_SRC
如果把同名函数放在同一个函数中，则可以实现重载
#+begin_src c++
  void print(const string &);
  void print(double);//重载print函数
  void print(int);//新作用域，隐藏了之前的print
  void fooBar2(int ival)
  {
    print("Value:" );//调用print(const string &)
    print(ival);//调用print(int)
    print(3.14);//调用print(double)
  }

#+END_SRC
** 命名空间
下面两个函数是重载
#+begin_src c++
  namespacs IBM{
    int myfunc(int a);
  }
  namespacs SUN{
    using IBM::myfunc;
    int myfunc(double b);
  }
#+END_SRC
** 注意与继承覆盖区别开
子类如果有与父类相同名字（即使参数不同）的函数，将会覆盖掉父类方法。
#+begin_src c++
  class A{
    public:
    int myfunc(int a){
      return 0;
    }
  };
  class SubA : public A{
    public:
    int myfunc(int *p){
      return 0;
    }
  };
  SubA sa;
  sa.myfunc(1); //报错，不能将int转换为int*
#+END_SRC
** 操作符重载
对于内置数据类型的操作符，它预定义的意义不能被修改，也不能为内置数据类型定义其他操作符。
例如不能定义int operator+(int, int);也不能定义void operator+(int[],int[]).
** 实例
*** 实例1
#+begin_src c++
#include <iostream>
using namespace std;

void myfunc(char a){
	   cout << "111 World";
};
void myfunc(long b){
	   cout << "222 World";
};
int main()
{
short c=100;
myfunc(c); //编译器会报错

return 0;
}
#+END_SRC
c为short类型，先提升为int类型，由于int可以转换成char和long，又由于类型转换匹配优先级相同，所以编译器不知道要匹配哪一个
*** 实例2
#+begin_src c++
#include <iostream>
using namespace std;

void myfunc(char a){
   cout << "111 World";
};
void myfunc(int b){
   cout << "222 World";
};
int main()
{
   short c=100;
   myfunc(c);
   cout << "Hello World";
   return 0;
}
#+END_SRC
输出：
#+begin_example
222 WorldHello World
#+end_example
由于类型提升优先级高于类型转换，所以会匹配第二个函数。
* 多态
C++规定，当一个成员函数被声明为虚函数后，其派生类中的同名函数都自动成为虚函数。

多态的行为必须是在指针或者引用的情况下才能生效。
** 简单介绍
#+begin_src c++
#include "stdafx.h"
#include <iostream>
#include <stdlib.h>
using namespace std;

class Father
{
public:
    void Face()
    {
        cout << "Father's face" << endl;
    }

    void Say()
    {
        cout << "Father say hello" << endl;
    }
};


class Son:public Father
{
public:
    void Say()
    {
        cout << "Son say hello" << endl;
    }
};

void main()
{
    Son son;
    Father *pFather=&son; // 隐式类型转换
    pFather->Say();
}
#+end_src
输出的结果为:
#+DOWNLOADED: screenshot @ 2022-12-05 23:01:44
[[file:images/多态/2022-12-05_23-01-44_screenshot.png]]
c++编译器在编译的时候，要确定每个对象调用的函数（非虚函数）的地址，这称为早期绑定，
当我们将Son类的对象son的地址赋给pFather时，c++编译器进行了类型转换，此时c++编译器认为变量pFather保存的就是Father对象的地址，当在main函数中执行pFather->Say(),调用的当然就是Father对象的Say函数

要让编译器采用晚绑定，就要在基类中声明函数时使用virtual关键字，这样的函数我们就称之为虚函数，
一旦某个函数在基类中声明为virtual，那么在所有的派生类中该函数都是virtual，而不需要再显式地声明为virtual。

#+begin_src c++
#include "stdafx.h"
#include <iostream>
#include <stdlib.h>
using namespace std;

class Father
{
public:
    void Face()
    {
        cout << "Father's face" << endl;
    }

    virtual void Say()
    {
        cout << "Father say hello" << endl;
    }
};


class Son:public Father
{
public:
    void Say()
    {
        cout << "Son say hello" << endl;
    }
};

void main()
{
    Son son;
    Father *pFather=&son; // 隐式类型转换
    pFather->Say();
}
#+end_src

#+DOWNLOADED: screenshot @ 2022-12-05 23:03:29
[[file:images/多态/2022-12-05_23-03-29_screenshot.png]]
** 虚表
如果一个类中有虚函数，编译器会为每个包含虚函数的类创建一个虚表(即 vtable)，该表是一个一维数组，在这个数组中存放每个虚函数的地址。

编译器另外还为每个对象提供了一个虚表指针(即vptr)，这个指针指向了对象所属类的虚表。

在构造函数中进行虚表的创建和虚表指针的初始化，
在构造子类对象时，要先调用父类的构造函数，初始化父类对象的虚表指针，该虚表指针指向父类的虚表，
当执行子类的构造函数时，子类对象的虚表指针被初始化，指向自身的虚表。

虚表可以继承，如果子类没有重写虚函数，那么子类虚表中仍然会有该函数的地址，只不过这个地址指向的是基类的虚函数实现。
如果重写了相应的虚函数，那么虚表中的地址就会改变，指向自身的虚函数实现，如果派生类有自己的虚函数，那么虚表中就会添加该项。
** 虚表和虚表指针的运行方式
#+begin_src c++
#include<iostream.h>

class Base
 {
 public:
    virtual void function1() {cout<<"Base :: function1()\n";};
    virtual void function2() {cout<<"Base :: function2()\n";};
    virtual ~Base(){};
};

class D1: public Base
{
public:
   ~D1(){};
   virtual void function1() { cout<<"D1 :: function1()\n";};
};

class D2: public Base
{
public:
   ~D2(){};
   virtual void function2() { cout<< "D2 :: function2\n";};
};

int main()
{
  D1 *d = new D1;;
  Base *b = d;

  b->function1();
  b->function2();

  delete (b);

  return (0);
}

output:
D1 :: function1()
Base :: function2()
#+END_SRC
Here is a pictorial representation of Virtual Table and _vptr for the above code:
#+DOWNLOADED: screenshot @ 2022-12-26 22:59:51
[[file:images/多态/2022-12-26_22-59-51_screenshot.png]]
Here in function main b pointer gets assigned to D1's _vptr and now starts pointing to D1's vtable.
Then calling to a function1(), makes it's _vptr startightway calls D1's vtable function1() and so in turn calls D1's method
i.e. function1() as D1 has it's own function1() defined it's class.

Where as pointer b calling to a function2(), makes it's _vptr points to D1's vatble which in-turn pointing to Base class's vtable function2 () as shown in the diagram (as D1 class does not have it's own definition or function2()).

So, now calling delete on pointer b follows the _vptr - which is pointing to D1's vtable calls it's own class's destructor
i.e. D1 class's destructor and then calls the destrcutor of Base class - this as part of when dervied object gets deleted it turn deletes it's emebeded base object.
Thats why we must always make Base class's destrcutor as virtual if it has any virtual functions in it.
** 构造函数
C++标准规定了在构造函数中调用虚函数时，只会绑定到自己类的相应函数。虚函数在构造函数中不起作用。

*** 构造函数不能为虚函数
简言之：构造函数不能是虚函数，因为虚函数是基于对象的，构造函数是用来产生对象的，若构造函数是虚函数，则需要对象来调用，但是此时构造函数没有执行，就没有对象存在，产生矛盾，所以构造函数不能是虚函数。
**** 从存储空间角度来看
虚函数的调用需要虚函数表(vptr)指针，而该指针存放在对象的内存空间中，在构造函数中进行初始化工作，即初始化vptr，让它指向正确的虚函数表。
所以需要调用构造函数才可以创建或初始化它的值，否则即使开辟了空间，该指针也为随机值；若构造函数声明为虚函数，那么由于对象还未创建，还没有内存空间，更没有虚函数表地址用来调用虚函数——构造函数了。

**** 从多态角度来看
构造一个对象的时候，必须知道对象的实际类型；而虚函数主要是实现多态，在运行时才可以明确调用对象，根据传入的对象类型来调用函数，
例如通过父类的指针或者引用来调用它的时候可以变成调用子类的那个成员函数
。而构造函数是在创建对象时自己主动调用的，不可能通过父类的指针或者引用去调用。那使用虚函数也就没有了实际意义。
在调用构造函数时，由于对象还未构造成功。编译器无法知道对象的实际类型，是该类本身，还是该类的一个派生类，或是更深层次的派生类。
并且构造函数的作用是提供初始化，在对象生命期仅仅运行一次，不是对象的动态行为，没有必要成为虚函数。

** 析构函数
*** 析构函数为什么必须是虚函数
当基类的析构函数为非虚函数时，删除一个基类指针指向的派生类实例时，只清理了派生类从基类继承过来的资源，而派生类自己独有的资源却没有被清理，这显然不是我们希望的。

如果一个类会被其他类继承，那么我们有必要将被继承的类（基类）的析构函数定义成虚函数。这样，释放基类指针指向的派生类实例时，先调用派生类的析构函数，再调用基类的析构函数，清理工作才能全面进行，才不会发生内存泄漏。
*** delete子类指针
不管什么时候delete子类指针，都会调用父类析构函数（不管父类析构函数是不是虚函数）。

之所以要把父类析构函数定义为虚函数，是因为当父类指针指向子类对象时，delete父类指针可以调用到子类的析构函数（之后会调用父类的析构）。
** 参数传递
*** 引用和值传递
#+begin_src c++
  class Parent{
  public:
      virtual void print();
  }
  class Son{
  public:
      void print();
  }
  void A(Parent &son){//传引用
      son.print();
  }
  void B(Parent son){//传值
      son.print();
  }
  main(){
    Son *p=new Son();
    A(*p);//调用子类的print
    B(*p);//调用父类的print
  }
#+END_SRC
第一次传引用相当于父类指针指向派生类；
第二次传值，是用派生类对象赋值给基类对象，仅仅拷贝了派生类的基类部分，因此调用基类版本函数。

多态的行为必须是在指针或者引用的情况下才能生效，对值变量来说，一定是执行静态绑定。
*** 默认参数
虚函数是动态绑定，但默认值是在编译期决定的，所以派生类的

#+begin_src c++
#include <iostream>
using namespace std;
 
class Base {
public:
    virtual void fun(int x = 111) {
        cout << "Base::fun(), x = " << x << endl;
    }
};
 
class Derived : public Base {
public:
    virtual void fun(int x=222) {
        cout << "Derived::fun(), x = " << x << endl;
    }
};
 
int main() {
    Derived d1;
    Base* p1 = &d1;
	Derived* p2=&d1; 
    p1->fun();
    p2->fun();
    return 0;
}
#+END_SRC
输出：
#+begin_example
Derived::fun(), x = 111
Derived::fun(), x = 222
#+end_example
注意，上面第一行打印的是派生类函数名，但是使用的默认值是基类的111。
** 函数声明不同的虚函数是不同的
如下代码，基类的display方法加了const，这导致派生类实际上有两个不同的虚方法：一个带const，一个不带const。

当用基类指针调用子类对象方法时，由于基类的虚函数表只有带const的方法，所以会调用到子类的带const的display方法。
#+begin_src c++
#include <iostream>
using namespace std;
 
class Base {
public:
    virtual void display() const {
        cout << "Base::display()" << endl;
    }
};
 
class Derived : public Base {
public:
    virtual void display() {
        cout << "Derived::display()" << endl;
    }
};
 
int main() {
    Derived d1;
    Base* p1 = &d1;
	Derived* p2=&d1; 
    p1->display();
    p2->display();
    return 0;
}#+END_SRC
输出：
#+begin_example
Base::display()
Derived::display()
#+end_example

如果去掉const,则结果为：
#+begin_example
Derived::display()
Derived::display()
#+end_example
** 继承
#+begin_src c++
  class A
  ｛
  public :
  virtual void test();
  ｝;
  class B:public A{
    public:
    void test();
  }
  class C:public B{
    public:
    void test();
  }
#+END_SRC
则B的test函数以及C的test函数都是虚函数；即使C的test函数访问权限发生变化，也是虚函数。
#+begin_src c++
  class C:public B{
    private:
    void test();
  }
#+END_SRC

** 参考文章
[[https://www.go4expert.com/articles/virtual-table-vptr-t16544/][How Virtual Table and _vptr works]]
[[https://blog.csdn.net/qq_42247231/article/details/105109709][为什么析构函数必须是虚函数？为什么默认的析构函数不是虚函数？]]
* 定义抽象数据类型
#+BEGIN_SRC c++
struct ListNode {
    int val;
    ListNode *next;
    ListNode() : val(0), next(nullptr) {}
    ListNode(int x) : val(x), next(nullptr) {}
    ListNode(int x, ListNode *next) : val(x), next(next) {}
};
#+END_SRC

如果调用 ~ListNode(5)~ 那么 ~val=5~ ， ~next~ 指针为空指针
* hex
Sets the basefield format flag for the str stream to hex.

When basefield is set to hex, integer values inserted into the stream are expressed in hexadecimal base (i.e., radix 16). For input streams, extracted values are also expected to be expressed in hexadecimal base when this flag is set.

The basefield format flag can take any of the following values (each with its own manipulator):

| flag value | effect when set                                          |
|------------+----------------------------------------------------------|
| dec        | read/write integer values using decimal base format.     |
| hex        | read/write integer values using hexadecimal base format. |
| oct        | read/write integer values using octal base format.       |

example:
#+BEGIN_SRC c++
// modify basefield
#include <iostream>     // std::cout, std::dec, std::hex, std::oct

int main () {
  int n = 70;
  std::cout << std::dec << n << '\n';
  std::cout << std::hex << n << '\n';
  std::cout << std::oct << n << '\n';
  return 0;
}
#+END_SRC
#+BEGIN_EXAMPLE
Output:
70
46
106

#+END_EXAMPLE
* intptr_t、uintptr_t数据类型的解析
#+begin_src c++
typedef  intptr_t      ngx_int_t;
typedef  uintptr_t    ngx_uint_t;
#+END_SRC
intptr_t和uintptr_t是什么类型？以前没见过，于是查了一下。
这两个数据类型是ISO C99定义的，具体代码在linux平台的/usr/include/stdint.h头文件中。

该头文件中定义intptr_t和uintptr_t这两个数据类型的代码片段如下：
#+begin_src c++
/* Types for `void *' pointers.  */
#if __WORDSIZE == 64
# ifndef __intptr_t_defined
typedef long int		intptr_t;
#  define __intptr_t_defined
# endif
typedef unsigned long int	uintptr_t;
#else
# ifndef __intptr_t_defined
typedef int			intptr_t;
#  define __intptr_t_defined
# endif
typedef unsigned int		uintptr_t;
#endif
#+END_SRC
在64位的机器上，intptr_t和uintptr_t分别是long int、unsigned long int的别名；在32位的机器上，intptr_t和uintptr_t分别是int、unsigned int的别名。

那么为什么要用typedef定义新的别名呢？我想主要是为了提高程序的可移植性（在32位和64位的机器上）。很明显，上述代码会根据宿主机器的位数为intptr_t和uintptr_t适配相应的数据类型。
另外，如注释所言，定义这两个数据类型别名也是为了“void *”指针。

在C语言中，任何类型的指针都可以转换为void *类型，并且在将它转换回原来的类型时不会丢失信息。
** 参考文章
[[https://blog.csdn.net/cs_zhanyb/article/details/16973379][intptr_t、uintptr_t数据类型的解析]]
* 继承
** 多重继承
非虚拟继承，B和C的对象分别保留一份A对象的内存空间，n处于不同的内存空间，因此是独立的不会相互影响，n的赋值不会覆盖；
如果B和C虚拟继承A类的话，A的对象只有一份，B和C对象中只是保存指向A对象的指针，n的赋值会覆盖。
#+begin_src c++
#include <iostream>
using namespace std;

class A
{
	public:
	int n;
};
class B:public A{};
class C:public A{};
class D:public B,public C{};

int main()
{
	D d;
	d.B::n=10;
	d.C::n=20;
	cout<<d.B::n<<","<<d.C::n;
	return 0;
}
#+END_SRC
** 虚继承
*** 菱形继承的问题

#+DOWNLOADED: screenshot @ 2023-03-14 22:32:32
[[file:images/继承/2023-03-14_22-32-32_screenshot.png]]
类 A 派生出类 B 和类 C，类 D 继承自类 B 和类 C，这个时候类 A 中的成员变量和成员函数继承到类 D 中变成了两份，一份来自 A-->B-->D 这条路径，另一份来自 A-->C-->D 这条路径。

在一个派生类中保留间接基类的多份同名成员，虽然可以在不同的成员变量中分别存放不同的数据，但大多数情况下这是多余的：因为保留多份成员变量不仅占用较多的存储空间，还容易产生命名冲突。
假如类 A 有一个成员变量 a，那么在类 D 中直接访问 a 就会产生歧义，编译器不知道它究竟来自 A -->B-->D 这条路径，还是来自 A-->C-->D 这条路径。
下面是菱形继承的具体实现：
#+begin_src c++
//间接基类A
class A{
protected:
    int m_a;
};

//直接基类B
class B: public A{
protected:
    int m_b;
};

//直接基类C
class C: public A{
protected:
    int m_c;
};

//派生类D
class D: public B, public C{
public:
    void seta(int a){ m_a = a; }  //命名冲突
    void setb(int b){ m_b = b; }  //正确
    void setc(int c){ m_c = c; }  //正确
    void setd(int d){ m_d = d; }  //正确
private:
    int m_d;
};

int main(){
    D d;
    return 0;
}
#+END_SRC
这段代码实现了上图所示的菱形继承，第 25 行代码试图直接访问成员变量 m_a，结果发生了错误，因为类 B 和类 C 中都有成员变量 m_a（从 A 类继承而来），编译器不知道选用哪一个，所以产生了歧义。

为了消除歧义，我们可以在 m_a 的前面指明它具体来自哪个类：
#+begin_src c++
void seta(int a){ B::m_a = a; }
#+END_SRC
这样表示使用 B 类的 m_a。当然也可以使用 C 类的：
#+begin_src c++
void seta(int a){ C::m_a = a; }
#+END_SRC
*** 虚继承（Virtual Inheritance）
为了解决多继承时的命名冲突和冗余数据问题，C++ 提出了虚继承，使得在派生类中只保留一份间接基类的成员。

在继承方式前面加上 virtual 关键字就是虚继承，请看下面的例子：
#+begin_src c++
//间接基类A
class A{
protected:
    int m_a;
};
//直接基类B
class B: virtual public A{  //虚继承
protected:
    int m_b;
};
//直接基类C
class C: virtual public A{  //虚继承
protected:
    int m_c;
};
//派生类D
class D: public B, public C{
public:
    void seta(int a){ m_a = a; }  //正确
    void setb(int b){ m_b = b; }  //正确
    void setc(int c){ m_c = c; }  //正确
    void setd(int d){ m_d = d; }  //正确
private:
    int m_d;
};
int main(){
    D d;
    return 0;
}
#+END_SRC
这段代码使用虚继承重新实现了上图所示的菱形继承，这样在派生类 D 中就只保留了一份成员变量 m_a，直接访问就不会再有歧义了。

虚继承的目的是让某个类做出声明，承诺愿意共享它的基类。
其中，这个被共享的基类就称为虚基类（Virtual Base Class），本例中的 A 就是一个虚基类。
在这种机制下，不论虚基类在继承体系中出现了多少次，在派生类中都只包含一份虚基类的成员。

现在让我们重新梳理一下本例的继承关系，如下图所示：

#+DOWNLOADED: screenshot @ 2023-03-14 22:43:51
[[file:images/继承/2023-03-14_22-43-51_screenshot.png]]

观察这个新的继承体系，我们会发现虚继承的一个不太直观的特征：必须在虚派生的真实需求出现前就已经完成虚派生的操作。
在上图中，当定义 D 类时才出现了对虚派生的需求，但是如果 B 类和 C 类不是从 A 类虚派生得到的，那么 D 类还是会保留 A 类的两份成员。

换个角度讲，虚派生只影响从指定了虚基类的派生类中进一步派生出来的类，它不会影响派生类本身。

在实际开发中，位于中间层次的基类将其继承声明为虚继承一般不会带来什么问题。
通常情况下，使用虚继承的类层次是由一个人或者一个项目组一次性设计完成的。
对于一个独立开发的类来说，很少需要基类中的某一个类是虚基类，况且新类的开发者也无法改变已经存在的类体系。

C++标准库中的 iostream 类就是一个虚继承的实际应用案例。
iostream 从 istream 和 ostream 直接继承而来，而 istream 和 ostream 又都继承自一个共同的名为 base_ios 的类，是典型的菱形继承。
此时 istream 和 ostream 必须采用虚继承，否则将导致 iostream 类中保留两份 base_ios 类的成员。

#+DOWNLOADED: screenshot @ 2023-03-14 22:51:26
[[file:images/继承/2023-03-14_22-51-26_screenshot.png]]
*** 虚基类成员的可见性
因为在虚继承的最终派生类中只保留了一份虚基类的成员，所以该成员可以被直接访问，不会产生二义性。
此外，如果虚基类的成员只被一条派生路径覆盖，那么仍然可以直接访问这个被覆盖的成员。
但是如果该成员被两条或多条路径覆盖了，那就不能直接访问了，此时必须指明该成员属于哪个类。

以图2中的菱形继承为例，假设 A 定义了一个名为 x 的成员变量，当我们在 D 中直接访问 x 时，会有三种可能性：
- 如果 B 和 C 中都没有 x 的定义，那么 x 将被解析为 A 的成员，此时不存在二义性。
- 如果 B 或 C 其中的一个类定义了 x，也不会有二义性，派生类的 x 比虚基类的 x 优先级更高。
- 如果 B 和 C 中都定义了 x，那么直接访问 x 将产生二义性问题。

可以看到，使用多继承经常会出现二义性问题，必须十分小心。上面的例子是简单的，如果继承的层次再多一些，关系更复杂一些，程序员就很容易陷人迷魂阵，程序的编写、调试和维护工作都会变得更加困难，
因我不提倡在程序中使用多继承，只有在比较简单和不易出现二义性的情况或实在必要时才使用多继承，能用单一继承解决的问题就不要使用多继承
。也正是由于这个原因，C++ 之后的很多面向对象的编程语言，例如 Java、C#、PHP 等，都不支持多继承。
** 访问控制
public继承不改变父类中的成员的访问权限；
protected继承时，public和protected访问级别的成员变为protected，private还是private；
private继承时，父类所有成员变为private。
** 参考文章
[[http://c.biancheng.net/view/2280.html][C++虚继承和虚基类详解]]
* 拷贝、赋值、销毁
如果一个构造函数的第一个参数是自身类类型的引用，且任何额外参数都有默认值，则此构造函数是拷贝构造函数。
#+begin_src c++
  class Foo{
    public:
    Foo();//默认构造函数
    Foo(const Foo&);//拷贝构造函数，这里可以不带const
  }；
#+END_SRC

** 合成拷贝构造函数
不管有没有为一个类定义拷贝构造函数，编译器会都会为我们合成一个拷贝构造函数，这点与合成默认构造函数是不同的。

一般情况下，合成的拷贝构造函数会将其参数的成员（非static成员）逐个拷贝到正在创建的对象中。

每个成员的拷贝方式由数据类型决定：
- 类类型：使用其拷贝构造函数进行拷贝
- 内置类型：直接拷贝
- 数组：逐元素地拷贝，元素类型为类则用拷贝构造函数，元素类型为内置类型则直接拷贝
** 拷贝初始化
当使用直接初始化时，实际上是要求编译器使用普通的函数匹配来选择构造函数；
当使用拷贝初始化时，实际上是要求编译器将右侧运算对象拷贝到正在创建的对象中。
#+begin_src c++
  string dots(10,'.');            //直接初始化
  string s(dots);                 //直接初始化
  string s2=dots;                 //拷贝初始化
  string null_book="9-99";        //拷贝初始化
  string nines=string(100,'9');   //拷贝初始化
#+END_SRC
** 发生拷贝初始化的情况
1. 用=定义变量时
2. 将一个对象作为实参传递给一个非引用类型的形参
3. 从一个返回类型为非引用类型的函数返回一个对象
4. 用花括号列表初始化一个数组中元素或一个聚合类中成员
* 类
** 构造函数
*** 构造函数初始值列表
构造函数初始值是成员名字的一个列表，每个名字后面紧跟括号括起来的（或者在花括号内的）成员初始值。
不同成员的初始化通过逗号分隔开来。
#+begin_src c++
Data(const std::string &s,int n,double p) : bookNo(s),sold(n),revenue(p*n){}
#+END_SRC
没有出现在构造函数初始值列表中的成员将通过相应的类内初始值（如果存在的话）初始化，或者执行默认初始化。
**** 构造函数初始值列表与类内初始化值的区别
由于外部无法看到类内的私有变量，所以外部是无法感知类内的私有变量的初始值的；
但是构造函数是公开的，外部可以通过构造函数对私有变量的初始值进行设置。
** 定义类型成员
类可以自定义某种类型在类中的别名
#+begin_src c++
  class Screen{
    public:
    typedef std::string::size_type pos; //自定义类型别名
    private:
    pos cursor = 0;
    pos height = 0, width = 0;
    std::string contents;
  }
#+END_SRC
* lambda表达式
The predicates we pass to an algorithm must have exactly one or two parameters,depending on whether the algorithm takes a unary or binary predicate, respectively.However, sometimes we want to do processing that requires more arguments than the algorithm’s predicate allows.

A lambda expression represents a callable unit of code. It can be thought of as an unnamed, inline function. Like any function, a lambda has a return type, a parameter list, and a function body. Unlike a function, lambdas may be defined inside a function.A lamba expression has the form 
~[capture list] (parameter list) -> return type { function body }~

where capture list is an (often empty) list of local variables defined in the enclosing function; return type, parameter list, and function body are the same as in any ordinary function. However, unlike ordinary functions, a lambda must use a trailing return to specify its return type.

We can omit either or both of the parameter list and return type but must always include the capture list and function body:
#+BEGIN_SRC c++
auto f = [] { return 42; };
cout << f() << endl; // prints 42
#+END_SRC
Here, we’ve defined f as a callable object that takes no arguments and returns 42.
* likely和unlikely
* new创建类对象与不new区别
#+BEGIN_SRC c++
A a;

A * a = new a();
#+END_SRC
以上两种方式皆可实现类的实例化,区别在于：
1. 前者在堆栈中分配内存，后者为动态内存分配，在一般应用中是没有什么区别的，但动态内存分配会使对象的可控性增强。
2. 前者在栈中分配内存，后者在堆中分配内存
3. 大程序用new，小程序直接申请
4. new必须delete删除;不用new的方式，系统会自动回收内存

* new和delete
new 和 delete 不是函数，它们都是 C++ 定义的关键字，通过特定的语法可以组成表达式。
** operator new 和 operator delete
这两个其实是 C++ 语言标准库的库函数，原型分别如下：
#+begin_src c++
void *operator new(size_t);     //allocate an object
void *operator delete(void *);    //free an object

void *operator new[](size_t);     //allocate an array
void *operator delete[](void *);    //free an array
#+END_SRC
C++ Primer 一书上说这不是重载 new 和 delete 表达式（如 operator= 就是重载 = 操作符），因为 new 和 delete 是不允许重载的。只是用 operator new 和 operator delete 来命名。

** new 和 delete 背后机制
定义一个类 A：
#+begin_src c++
class A
{
public:
    A(int v) : var(v)
    {
        fopen_s(&file, "test", "r");
    }
    ~A()
    {
        fclose(file);
    }

private:
    int var;
    FILE *file;
};
#+END_SRC
类 A 中有两个私有成员，有一个构造函数和一个析构函数，构造函数中初始化私有变量 var 以及打开一个文件，析构函数关闭打开的文件。
*** new
我们使用
#+begin_src c++
class A *pA = new A(10);
#+END_SRC
来创建一个类的对象，返回其指针 pA。如下图所示 new 背后完成的工作：

#+DOWNLOADED: screenshot @ 2022-12-26 21:54:30
[[file:images/new和delete/2022-12-26_21-54-30_screenshot.png]]
简单总结一下：
1. 首先需要调用上面提到的 operator new 标准库函数，传入的参数为 class A 的大小，这里为 8 个字节，至于为什么是 8 个字节，你可以看看《深入 C++ 对象模型》一书，这里不做多解释。这样函数返回的是分配内存的起始地址，这里假设是 0x007da290。
2. 上面分配的内存是未初始化的，也是未类型化的，第二步就在这一块原始的内存上对类对象进行初始化，调用的是相应的构造函数，这里是调用 A:A(10); 这个函数，从图中也可以看到对这块申请的内存进行了初始化，var=10, file 指向打开的文件。
3. 最后一步就是返回新分配并构造好的对象的指针，这里 pA 就指向 0x007da290 这块内存，pA 的类型为类 A 对象的指针。
所有这三步，你都可以通过反汇编找到相应的汇编代码。
*** delete
如果这时想释放掉申请的类的对象怎么办？当然我们可以使用下面的语句来完成：
#+begin_src c++
delete pA;
#+END_SRC
delete 所做的事情如下图所示：

#+DOWNLOADED: screenshot @ 2022-12-26 21:57:23
[[file:images/new和delete/2022-12-26_21-57-23_screenshot.png]]
delete 就做了两件事情：
1. 调用 pA 指向对象的析构函数，对打开的文件进行关闭。
2. 通过上面提到的标准库函数 operator delete 来释放该对象的内存，传入函数的参数为 pA 的值，也就是 0x007d290。
** 如何申请和释放一个数组？
我们经常要用到动态分配一个数组，也许是这样的：
#+begin_src c++
string *psa = new string[10];      //array of 10 empty strings
int *pia = new int[10];           //array of 10 uninitialized ints
#+END_SRC
上面在申请一个数组时都用到了 new [] 这个表达式来完成，
按照我们上面讲到的 new 和 delete 知识，第一个数组是 string 类型，分配了保存对象的内存空间之后，将调用 string 类型的默认构造函数依次初始化数组中每个元素；
第二个是申请具有内置类型的数组，分配了存储 10 个 int 对象的内存空间，但并没有初始化。

如果我们想释放空间了，可以用下面两条语句：
#+begin_src c++
delete [] psa;
delete [] pia;
#+END_SRC
都用到 delete [] 表达式，注意这地方的 [] 一般情况下不能漏掉！
我们也可以想象这两个语句分别干了什么：第一个对 10 个 string 对象分别调用析构函数，然后再释放掉为对象分配的所有内存空间；
第二个因为是内置类型不存在析构函数，直接释放为 10 个 int 型分配的所有内存空间。

这里对于第一种情况就有一个问题了：我们如何知道 psa 指向对象的数组的大小？怎么知道调用几次析构函数？

这个问题直接导致我们需要在 new [] 一个对象数组时，需要保存数组的维度，C++ 的做法是在分配数组空间时多分配了 4 个字节的大小，专门保存数组的大小，在 delete [] 时就可以取出这个保存的数，就知道了需要调用析构函数多少次了。

还是用图来说明比较清楚，我们定义了一个类 A，但不具体描述类的内容，这个类中有显示的构造函数、析构函数等。那么 当我们调用
#+begin_src c++
class A *pAa = new A[3];
#+END_SRC
时需要做的事情如下：

#+DOWNLOADED: screenshot @ 2022-12-26 22:01:35
[[file:images/new和delete/2022-12-26_22-01-35_screenshot.png]]
从这个图中我们可以看到申请时在数组对象的上面还多分配了 4 个字节用来保存数组的大小，但是最终返回的是对象数组的指针，而不是所有分配空间的起始地址。

这样的话，释放就很简单了：
#+begin_src c++
delete []pAa;
#+END_SRC

#+DOWNLOADED: screenshot @ 2022-12-26 22:02:26
[[file:images/new和delete/2022-12-26_22-02-26_screenshot.png]]
里要注意的两点是：
1. 调用析构函数的次数是从数组对象指针前面的 4 个字节中取出；
2. 传入 operator delete[] 函数的参数不是数组对象的指针 pAa，而是 pAa 的值减 4。
** new/delete 、new []/delete[] 要配对使用
因为new/delete、new[]/delete[] 的工作原理有差别，所以需要配对使用。

如果将new[]与delete混用，有可能会出现内存泄漏，下面举个例子进行说明
#+begin_src c++
int *pia = new int[10];
delete pia;
#+END_SRC
如果是内置类型或者是无自定义的析构函数的类类，那么由于没有析构函数，这样写不会有问题。

如果是带有自定义析构函数的类类型，用 new [] 来创建类对象数组，而用 delete 来释放就会发生内存泄漏：
#+begin_src c++
class A *pAa = new class A[3];
delete pAa;
#+END_SRC
那么 delete pAa; 做了两件事：
1. 调用一次 pAa 指向的对象的析构函数；
2. 调用 operator delete(pAa); 释放内存。

显然，这里只对数组的第一个类对象调用了析构函数，后面的两个对象均没调用析构函数，
如果类对象中申请了大量的内存需要在析构函数中释放，而你却在销毁数组对象时少调用了析构函数，这会造成内存泄漏。

第二点就是致命的了！直接释放 pAa 指向的内存空间，这个总是会造成严重的段错误，程序必然会奔溃！
因为分配的空间的起始地址是 pAa 指向的地方减去 4 个字节的地方。
你应该传入参数设为那个地址！
** 参考文章
[[https://www.cnblogs.com/hazir/p/new_and_delete.htlm][浅谈 C++ 中的 new/delete 和 new[]/delete[]​]]
* map
** map的排序
*** 按key排序
實際上map內部所有的資料本來就是按key排序的。分析map結構定義，發現map的按key排序是通過第3個引數（比較函式的函式物件）實現的。

其中，less為其預設的函式物件，所以如果我們不指定引數3，map鍵值對就會按照預設方法進行儲存。當我們希望它能以不同的方式進行排序，就需要重新指定引數3。

如果只是呼叫C++標準庫自帶的方法，我們只需如下所示，在宣告map物件時指定第3引數即可。
*** 按value排序
由于sort只能对序列容器（如vector、list、deque）进行排序，而map虽然也是一个集合容器，但却不是线性存储的（比如红黑树）。
因此并不能直接用sort对map进行按value排序。

* optional

** 例子 
场景：如果有这样一个函数，通过返回值来判断计算结果是否有效，如果结果有效，才能使用结果 。

例如：计算a、b相除。b有可能为0，所以需要考虑相除结果是否有效。
#+BEGIN_SRC c++
bool div_int(int a, int b, int &result) {
    if (b == 0) {
        return false;
    }
    result = a / b;
    return true;
}

TEST_F(before_optional) {
    int result = 0; // 接收结果
    auto ret = div_int(2, 1, result);
    ASSERT(ret);
    ASSERT_EQ(2, result); // 如果返回值为true, 结果才有效

    auto b = div_int(2, 0, result);
    ASSERT(!b);
}
#+END_SRC
这样的使用方式很不方便，需要两个变量来描述结果。这种场景下应该使用c++17中的std::optional。我们用std::optional改写上面这个例子：
#+BEGIN_SRC c++
//div_int可以通过optional优化：optional中，结果是否有效和结果都保存在其中
std::optional<int> div_int(int a, int b) {
    if (b != 0) {
        return std::make_optional<int>(a / b);
    }
    return {};
}

TEST_F(optional) {
    auto ret = div_int(2, 1);
    ASSERT(ret);
    ASSERT_EQ(2, ret.value()); // 如果ret为true, 直接从ret中获取结果

    auto ret2 = div_int(2, 0);
    ASSERT(!ret2); // 结果无效

    // 如果ret2为false，获取访问value将会 抛出异常
    try {
        ret2.value();
    } catch (std::exception e) {
        std::cout << e.what() << std::endl;
    }
}
#+END_SRC
如果开发项目中没有支持到c++17可以用boost库中的optional。
* printf("%5s”,“abcdefg ”)
执行printf( “ %5s ” , “abcdefg ” ) 后，则输出结果为:abcdefg
- "%5s",表示输出至少5个字符，不够的话，左侧用空格补。
- %.5s，最多输出5个字符

* string
** 初始化
string test1;    //空串

string test2 = "内容"; //使用=

string test3("内容");   //使用引用字符数组作为参数传给构造函数

string test4(test2); //用一个string初始化另一而string

string test5(test2,pos,num); //从test2中的第pos个位置开始，拷贝个数为num个字符

string test6 = test2 + "内容" + test3 //混合初始化

string test7 = test2.substr(pos,num); //从test2中的第pos个位置开始，拷贝个数为num个字符

string test8 = test2.substr(); //参数列表为空则会拷贝test2的整个对象（复制test2的简便方法）

string test9(num,ch); //拷贝num个字符型ch到test9

* string_view使用介绍
C++中与字符串有两种风格，分别是C风格的字符串、std::string字符串。C风格的字符串性能更高，但是也不方便操作使用。如下示例：
#+BEGIN_SRC c++
#include <iostream>
#include <string>
 
int main()
{
    //C风格字符串总是以null结尾
    char cstr1[] = { 'y', 'a', 'n', 'g', NULL};
    char cstr2[5];
    strcpy(cstr1, cstr2);
    std::cout << cstr2 << std::endl;
 
    //C++风格的字符串操作更方便，但是性能不如C风格字符串
    std::string str = "yang";
    std::string str2 = str;
}
#+END_SRC

C++17中我们可以使用std::string_view来获取一个字符串的视图，字符串视图并不真正的创建或者拷贝字符串，而只是拥有一个字符串的查看功能。std::string_view比std::string的性能要高很多，因为每个std::string都独自拥有一份字符串的拷贝，而std::string_view只是记录了自己对应的字符串的指针和偏移位置。当我们在只是查看字符串的函数中可以直接使用std::string_view来代替std::string。
#+BEGIN_SRC c++
#include <iostream>
#include <string>
#include <string_view>
 
int main()
{
 
    const char* cstr = "yangxunwu";
    std::string_view stringView1(cstr);
    std::string_view stringView2(cstr, 4);
    std::cout << "stringView1: " << stringView1 << ", stringView2: " << stringView2 << std::endl;
 
    std::string str = "yangxunwu";
    std::string_view stringView3(str.c_str());
    std::string_view stringView4(str.c_str(), 4);
    std::cout << "stringView3: " << stringView1 << ", stringView4: " << stringView2 << std::endl;
}
#+END_SRC
输出
* sort
C++ STL 标准库中的 sort() 函数，本质就是一个模板函数。该函数专门用来对容器或普通数组中指定范围内的元素进行排序，排序规则默认以元素值的大小做升序排序，除此之外我们也可以选择标准库提供的其它排序规则（比如std::greater降序排序规则），甚至还可以自定义排序规则。

值得一提的是，sort() 函数位于头文件中，因此在使用该函数前，程序中应包含如下语句：
#+BEGIN_SRC c++
#include <algorithm>
#+END_SRC
sort() 函数有 2 种用法，其语法格式分别为：
#+BEGIN_SRC c++
//对 [first, last) 区域内的元素做默认的升序排序
void sort (RandomAccessIterator first, RandomAccessIterator last);
//按照指定的 comp 排序规则，对 [first, last) 区域内的元素进行排序
void sort (RandomAccessIterator first, RandomAccessIterator last, Compare comp);
#+END_SRC
其中，first 和 last 都为随机访问迭代器，它们的组合 [first, last) 用来指定要排序的目标区域；另外在第 2 种格式中，comp 可以是 C++ STL 标准库提供的排序规则（比如 std::greater），也可以是自定义的排序规则。

数组排序样例：
#+BEGIN_SRC c++
#include <algorithm>
#include <algorithm>

using namespace std;

int main(){
    int arr[] = {2,6,3,5,4,8,1,0,9,10};
    sort(arr, arr+10);
    for(int i = 0;i < 10;i++)
        cout << arr[i] << " ";
}
// out
/*
0 1 2 3 4 5 6 8 9 10
*/
#+END_SRC
** 使用 STL 标准库提供的排序规则
#+BEGIN_SRC c++
int main(){
    int arr[] = {2,6,3,5,4,8,1,0,9,10};
    sort(arr, arr+10, std::greater<int>());
    for(int i = 0;i < 10;i++)
        cout << arr[i] << " ";
    cout << endl;
    sort(arr, arr+10, std::less<int>());
    for(int i = 0;i < 10;i++)
        cout << arr[i] << " ";
}
// out
/*
10 9 8 6 5 4 3 2 1 0
0 1 2 3 4 5 6 8 9 10
*/
#+END_SRC
** 使用自定义比较器
#+BEGIN_SRC c++
bool cmp(const int a, const int b){
    return a < b;
}
int main(){
    int arr[] = {2,6,3,5,4,8,1,0,9,10};
    sort(arr, arr+10, cmp);
    for(int i = 0;i < 10;i++)
        cout << arr[i] << " ";
}
// out
/*
0 1 2 3 4 5 6 8 9 10
*/
#+END_SRC
** 使用 lambda 表达式自定义比较器
#+BEGIN_SRC c++
int main(){
    int arr[] = {2,6,3,5,4,8,1,0,9,10};
    sort(arr, arr+10, [](const int a, const int b){
         return a < b;
         });
    for(int i = 0;i < 10;i++)
        cout << arr[i] << " ";
}
// out
/*
0 1 2 3 4 5 6 8 9 10
*/
#+END_SRC
** 对map进行排序
C++ STL中的map默认以key排序的。

如果想对value进行排序，可以将map的key和value以pair的形式装到vector中，对vector进行排序。
#+begin_src c++
int main()
{
    unordered_map<int, int> iMap;
    iMap[1] = 20;
    iMap[2] = 10;
    iMap[5] = 30;
    iMap[4] = 0;

    vector<pair<int, int>> vtMap;
    for (auto it = iMap.begin(); it != iMap.end(); it++)
        vtMap.push_back(make_pair(it->first, it->second));

    sort(vtMap.begin(), vtMap.end(), 
        [](const pair<int, int> &x, const pair<int, int> &y) -> int {
        return x.second < y.second;
    });

    for (auto it = vtMap.begin(); it != vtMap.end(); it++)
        cout << it->first << ':' << it->second << '\n';
    return 0;
}
#+END_SRC
运行结果： 
#+DOWNLOADED: screenshot @ 2022-08-21 11:11:46
[[file:images/c++/sort/2022-08-21_11-11-46_screenshot.png]]

** 二维vector排序
*** 自定义排序函数
#+begin_src c++
static bool cmp(const vector<int>& a,const vector<int>& b){
   return a.back()<b.back();
}
sort(points.begin(),points.end(),cmp);
#+END_SRC
*** Lambda 函数
#+begin_src c++
sort(points.begin(),points.end(),[](vector<int>a, vector<int>b){return a[1]<b[1];}//速度比方法1稍慢
#+END_SRC
** 参考文章
[[https://www.cnblogs.com/zhhfan/p/14789325.html][C++中使用sort对常见容器排序]]
[[https://blog.csdn.net/liguojie12/article/details/113800426][C++ 二维vector排序(sort用法)]]
* std::tuple 和 std::tie 的用法简介
tuple即元组，可以理解为pair的扩展，可以用来将不同类型的元素存放在一起，常用于函数的多返回值。

** 定义与初始化
tuple可以使用初始化列表进行赋值。

tuple<int,double,string> t3 = {1, 2.0, "3"};

** 访问
可以使用get<常量表达式>(tuple_name)来访问或修改tuple的元素（返回引用）
#+begin_src c++
get<0>(t3) = 4;
cout << get<1>(t3) << endl;
#+end_src
会输出2

** 批量赋值
std::tie会将变量的引用整合成一个tuple，从而实现批量赋值。
#+begin_src c++
int i; double d; string s;
tie(i, d, s) = t3;

cout << i << " " << d << " " << s << endl;
#+end_src
会输出4 2 3

还可以使用std::ignore忽略某些tuple中的某些返回值，如

tie(i, ignore, s) = t3;

** 其它
需要注意的是，tie无法直接从初始化列表获得值，比如下面第5行会编译错误。
#+begin_src c++
int i; double d; string s;
tuple<int,double,string> t3 = {1, 2.0, "3"};
tie(i, d, s) = t3;
t3 = {1, 2.0, "3"};
tie(i, d, s) = {1, 2.0, "3"};
#+end_src

** 参考文章
[[https://blog.csdn.net/m0_37809890/article/details/89367406][std::tuple 和 std::tie 的用法简介]]
* std::forward
std::forward通常是用于完美转发的，它会将输入的参数原封不动地传递到下一个函数中，
这个“原封不动”指的是，如果输入的参数是左值，那么传递给下一个函数的参数的也是左值；
如果输入的参数是右值，那么传递给下一个函数的参数的也是右值。

** 参考文章
[[https://zhuanlan.zhihu.com/p/92486775][浅谈std::forward]]
* std::optional
在需要多个返回值的时候，可以下面用的pair形式，将返回值定义成结构体：
#+begin_src C++
#include <iostream>

using namespace std;

struct Out {
    string out1 { "" };
    string out2 { "" };
};

pair<bool, Out> func(const string& in) {
    Out o;
    if (in.size() == 0)
        return { false, o };
    o.out1 = "hello";
    o.out2 = "world";
    return { true, o };
}

int main() {
    if (auto [status, o] = func("hi"); status) {
        cout << o.out1 << endl;
        cout << o.out2 << endl;
    }
    return 0;
}
#+end_src

From cppreference -std::optional
#+begin_example
The class template std::optional manages an optional contained value, i.e. a value that may or may not be present.
A common use case for optional is the return value of a function that may fail. As opposed to other approaches, such as std::pair<T,bool>, optional handles expensive-to-construct objects well and is more readable, as the intent is expressed explicitly.
类模板 std::optional 管理一个可选的容纳值，即可以存在也可以不存在的值。
一种常见的 optional 使用情况是一个可能失败的函数的返回值。与其他手段，如 std::pair<T,bool> 相比， optional 良好地处理构造开销高昂的对象，并更加可读，因为它显式表达意图。
#+end_example
std::optional 是在 C++ 17 中引入到标准库中的，C++ 17 之前的版本可以通过 boost::optional 实现几乎相同的功能。

我们来看一下使用 std::optional 来实现上面那段代码的样子
#+begin_src c++
#include <iostream>
#include <optional>

using namespace std;

struct Out {
    string out1 { "" };
    string out2 { "" };
};

optional<Out> func(const string& in) {
    Out o;
    if (in.size() == 0)
        return nullopt;
    o.out1 = "hello";
    o.out2 = "world";
    return { o };
}

int main() {
    if (auto ret = func("hi"); ret.has_value()) {
        cout << ret->out1 << endl;
        cout << ret->out2 << endl;
    }
    return 0;
}
#+end_src
这段代码中我们看到了部分 std::optional 的用法，std::nullopt 是 C++ 17 中提供的没有值的 optional 的表达形式，等同于 { } 。

创建一个 optional 的方法：
#+begin_src c++
// 空 optiolal
optional<int> oEmpty;
optional<float> oFloat = nullopt;

optional<int> oInt(10);
optional oIntDeduced(10);  // type deduction

// make_optional
auto oDouble = std::make_optional(3.0);
auto oComplex = make_optional<complex<double>>(3.0, 4.0);

// in_place
optional<complex<double>> o7{in_place, 3.0, 4.0};

// initializer list
optional<vector<int>> oVec(in_place, {1, 2, 3});

// 拷贝赋值
auto oIntCopy = oInt;
访问 optional 对象中数据的方法：

// 跟迭代器的使用类似，访问没有 value 的 optional 的行为是未定义的
cout << (*ret).out1 << endl; 
cout << ret->out1 << endl;

// 当没有 value 时调用该方法将 throws std::bad_optional_access 异常
cout << ret.value().out1 << endl;

// 当没有 value 调用该方法时将使用传入的默认值
Out defaultVal;
cout << ret.value_or(defaultVal).out1 << endl;
#+end_src
使用 std::optional 带来的好处：
- 省去了运行状态的 bool 值的声明，让代码更简洁，更注重返回值本身的语意
- 不用担心额外的动态内存分配
* struct和class的区别
struct的默认访问级别为public，而class的默认访问级别是private。
* STL容器底层数据结构总结
** vector
vector是我们用到最多的数据结构，其底层数据结构是数组，由于数组的特点，vector也具有以下特性：
1、O(1)时间的快速访问；
2、顺序存储，所以插入到非尾结点位置所需时间复杂度为O(n)，删除也一样；
3、扩容规则：
当我们新建一个vector的时候，会首先分配给他一片连续的内存空间，如std::vector<int> vec，当通过push_back向其中增加元素时，如果初始分配空间已满，就会引起vector扩容，其扩容规则在gcc下以2倍方式完成：
首先重新申请一个2倍大的内存空间；
然后将原空间的内容拷贝过来；
最后将原空间内容进行释放，将内存交还给操作系统；

测试代码如下：
#+BEGIN_SRC c++
#include<iostream>
#include<vector>
using namespace std;

void mycapacity(const vector<int>& vec)
{
    cout << "分配总空间大小为：" << vec.capacity() << endl;
}

void mysize(const vector<int>& vec)
{
    cout << "已用空间大小为：" << vec.size() << endl;
}

void myprint(const vector<int>& vec)
{
    for (int i = 0; i < vec.size(); ++i)
        cout << vec[i] << ",";
    cout << endl;
}


int main()
{
    vector<int> vec;
    cout << "起始状态：" << endl;
    mycapacity(vec);
    mysize(vec);
    cout << "========================" << endl;

    for (int i = 0; i < 10; ++i) {
        vec.push_back(i);
        cout << "压入第" << i+1 << "个元素之后：" << endl;
        myprint(vec);
        mycapacity(vec);
        mysize(vec);
        cout << "========================" << endl;
    }

    return 0;
}
#+END_SRC

#+DOWNLOADED: file:E%3A/org/%E5%9B%BE%E7%89%87/Snipaste_2021-04-11_10-52-03.png @ 2021-04-11 10:54:14
[[file:STL%E5%AE%B9%E5%99%A8%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/2021-04-11_10-54-14_Snipaste_2021-04-11_10-52-03.png]]

从输出结果中的三个红色箭头可以看出vector的扩容规则。

4、注意事项：
根据vector的插入和删除特性，以及扩容规则，我们在使用vector的时候要注意，在插入位置和删除位置之后的所有迭代器和指针引用都会失效，同理，扩容之后的所有迭代器指针和引用也都会失效。
** map & multimap & unordered_map & unordered_multimap
*** map与multimap底层数据结构
map与multimap是STL中的关联容器、提供一对一key-value的数据处理能力； map与multimap的区别在于，multimap允许关键字重复，而map不允许重复。

这两个关联容器的底层数据结构均为红黑树,根据红黑树的原理，map与multimap可以实现O(lgn)的查找，插入和删除。
*** unordered_map 与unordered_multimap底层数据结构
unordered_map与unordered_multimap 对比map与multimap两种map在于map与multimap中的两个容器实现了以key为序排列，也就是说map与multimap为有序的。

而unordered_map与unordered_multimap中key为无序排列，其底层实现为hash table，因此其查找时间复杂度理论上达到了O(n)，之所以说理论上是因为在理想无碰撞的情况下，而真实情况未必如此。
** set & multiset & unordered_set & unordered_multiset
以上四种容器也都是关联容器，set系与map系的区别在于map中存储的是<key-value>，而set可以理解为关键字即值，即只保存关键字的容器。
*** set & multiset底层数据结构
set与multiset有序存储元素，这两种容器的底层实现与map一样都是红黑树，所以能实现O(lgn)的查找，插入，删除操作。

set与multiset的区别在于是否允许重复；
*** unordered_set & unordered_multiset
与unordered_map & unordered_multimap相同，其底层实现为hash table；
** priority_queue
priority_queue
优先级队列相当于一个有权值的单向队列queue，在这个队列中，所有元素是按照优先级排列的。

priority_queue根据堆的处理规则来调整元素之间的位置，根据堆的特性，优先级队列实现了取出最大最小元素时间复杂度为O(1),对于插入和删除，其最坏情况为O(lgn)。
** list
list的底层数据结构为双向链表，特点是支持快速的增删。
* STL容器迭代器失效情况分析、总结
[[https://ivanzz1001.github.io/records/post/cplusplus/2018/03/14/cpluscplus_stl_iterator#31-%25E4%25BD%25BF%25E7%2594%25A8%25E8%25BF%25AD%25E4%25BB%25A3%25E5%2599%25A8%25E9%2581%258D%25E5%258E%2586%25E4%25B8%258D%25E5%2590%258C%25E7%259A%2584%25E5%25AE%25B9%25E5%2599%25A8][参考文献]]
** 迭代器失效
当使用一个容器的insert或者erase函数通过迭代器插入或删除元素可能会导致迭代器失效，因此我们为了避免危险，应该获取insert或者erase返回的迭代器，以便用重新获取的新的有效的迭代器进行正确的操作：
#+BEGIN_SRC c++
iter = vec.insert(iter);

iter = vec.erase(iter);
#+END_SRC
迭代器失效类型：
- 由于插入元素，使得容器元素整体迁移导致存放原容器元素的空间不再有效，从而使得指向原空间的迭代器失效；
- 由于删除元素，使得某些元素次序发生变化导致原本指向某元素的迭代器不再指向期望指向的元素。

*** vector迭代器失效
- 当插入(push_back)一个元素后，end操作返回的迭代器肯定失效；
- 当插入(push_back)一个元素后，如果vector的capacity发生了改变，则需要重新加载整个容器，此时first和end操作返回的迭代器都会失效；
- 当进行删除操作(erase,pop_back)后，指向删除点的迭代器全部失效，指向删除点后面的元素的迭代器也将全部失效；

参看如下示例：
#+BEGIN_SRC c++
#include <iostream>
#include <vector>
using namespace std;


int main(int argc, char *argv[])
{
	vector<int> vec;
	
	vec.push_back(100);
	vec.push_back(300);
	vec.push_back(400);
	vec.push_back(500);
	
	vector<int>::iterator iter;
	
	for(iter = vec.begin(); iter != vec.end(); iter++)
	{
		if(*iter == 300){
			iter = vec.erase(iter);			//此时iter指向400
			cout<<"next iter: " << *iter << endl;
		}
	}
	
	for(iter = vec.begin(); iter != vec.end(); iter++)
		cout<<*iter << "  ";
	
	cout<<endl;	
	return 0x0;
}
#+END_SRC
编译运行：
#+BEGIN_EXAMPLE
# gcc -o vector_iterator vector_iterator.cpp -lstdc++
# ./vector_iterator 
next iter: 400
100  400  500 
#+END_EXAMPLE

*** list迭代器失效
- 插入操作(insert)和接合操作(splice)不会造成原有的list迭代器失效，这在vector中是不成立的，因为vector的插入操作可能造成记忆体重新配置，导致所有的迭代器全部失效；
- list的删除操作(erase)也只有指向被删元素的那个迭代器失效，其他迭代器不受影响。（list目前只发现这一种失效情况）
*** deque迭代器失效
- 在deque容器首部或者尾部插入元素，不会使得任何迭代器失效；
注： 通过vs2012测试，不管前端插入还是后端插入，都会使迭代器失效
- 在deque容器的首部或者尾部删除元素，只会使指向被删元素的迭代器失效；
- 在deque容器的任何其他位置进行插入或删除操作都将使指向该容器元素的所有迭代器失效；
*** set和map迭代器失效
与list相同，当对其进行insert或者erase操作时，操作之前的所有迭代器，在操作完成之后都依然有效，但被删除元素的迭代器失效。
** C++标准模板库(STL)迭代器的原理及实现
迭代器(iterator)是一种抽象的设计理念，通过迭代器可以在不了解容器内部原理的情况下遍历容器。除此之外，STL中迭代器一个最重要的作用就是作为容器(vector、list等)与STL算法的粘结剂，只要容器提供迭代器的接口，同一套算法代码可以利用在完全不同的容器中，这是抽象思想的经典应用。
*** 使用迭代器遍历不同的容器
如下所示的代码演示了迭代器是如何将容器和算法结合在一起的，其中使用了3种不同的容器，.begin()和.end()方法返回一个指向容器第一个元素和一个指向容器最后一个元素后面一个位置的迭代器，也就是说begin()和end()返回的迭代器是一个前闭后开的，一般用[begin, end) 表示。对于不同的容器，我们都使用同一个accumulate()函数，原因就在于acccumulate()函数的实现无需考虑容器的种类，只需要容器传入的begin()和end()迭代器能够完成标准迭代器的要求即可。
#+BEGIN_SRC c++
std::vector<int> vec{1,2,3};
std::list<int> lst{4,5,6};
std::deque<int> deq{7,8,9};

std::cout<<std::accumulate(vec.begin(), vec.end(), 0) << std::endl;
std::cout<<std::accumulate(lst.begin(), lst.end(), 0) << std::endl;
std::cout<<std::accumulate(deq.begin(), deq.end(), 0) << std::endl;
#+END_SRC
*** 迭代器的实现
迭代器的作用就是提供一个遍历容器内部所有元素的接口，因此迭代器的内部必须保存一个与容器相关联的指针，然后重载各种运算操作来方便遍历，其中最重要的就是* 运算符和-> 运算符，以及++、--等可能需要的运算符重载。实际上这和C++标准库的智能指针(smart pointer)很像，智能指针也是将一个指针封装，然后通过引用计数或是其他方法完成自动释放内存的功能，为了达到和原有指针一样的功能，也需要对*、->等运算符进行重载。下面参照智能指针实现一个简单vector迭代器，其中几个typedef暂时不用管，我们后面会提到。vecIter主要作用就是包裹一个指针，不同容器内部数据结构不相同，因此迭代器操作符重载的实现也会不同。比如++操作符。对于线性分配内存的数组来说，直接对指针执行++操作即可； 但是如果容器是List就需要采用元素内部的方法，比如ptr->next()之类的方法访问下一个元素。因此，STL容器都实现了自己的专属迭代器。

下面我们给出一个普通数组的迭代器的实现(array_iterator.cpp)：
#+BEGIN_SRC c++
#include <iostream>
#include <numeric>

template<class Item>
class vecIter{
	Item *ptr;
	
public:
	typedef std::forward_iterator_tag iterator_category;
	typedef Item value_type;
	typedef Item *pointer;
	typedef Item &reference;
	typedef std::ptrdiff_t difference_type;
	
public:
	vecIter(Item *p = 0):ptr(p){}
	
	Item & operator*() const{
		return *ptr;
	}
	
	Item * operator->() const{
		return ptr;
	}
	
	//pre
	vecIter &operator++(){
		++ptr;
		
		return *this;
	}
	
	vecIter operator++(int){
		vecIter tmp = *this;
		++*this;
		
		return tmp;
	}
	
	bool operator==(const vecIter &iter){
		return ptr == iter.ptr;
	}
	
	bool operator!=(const vecIter &iter){
		return !(*this == iter);
	}
};

int main(int argc, char *argv[])
{
	int a[] = {1,2,3,4};
	
	std::cout<<std::accumulate(vecIter<int>(a), vecIter<int>(a+4), 0)<<std::endl;
	
	return 0x0;
}
#+END_SRC
#+BEGIN_EXAMPLE
编译运行：

# gcc -o array_iterator array_iterator.cpp -lstdc++
# ./array_iterator 
10
#+END_EXAMPLE
*** 迭代器的相应型别
我们都知道type_traits可以萃取出类型的型别，根据不同的型别可以执行不同的处理流程。那么对于迭代器来说，是否有针对不同特性迭代器的优化方法呢？ 答案是肯定的。拿一个STL算法库中的distance()函数来说，distance函数接受两个迭代器参数，然后计算两者之间的距离。显然，对于不同的迭代器计算效率差别很大。比如对于vector容器来说，由于内存是连续分配的，因此指针直接相减即可获得两者的距离；而list容器是链表结构，内存一般都不是连续分配，因此只能通过一级一级调用next()或者其他函数，每调用一次再判断迭代器是否相等来计算距离。vector迭代器计算distance的效率为O(1)，而list则为O(n)，n为距离的大小。

因此，根据迭代器不同的特性，将迭代器分为5类：
- Input Iterator: 这种迭代器所指的对象为只读的
- Output Iterator: 所指的对象只能进行写入操作
- Forward Iterator: 该类迭代器可以在一个正确的区间中进行读写操作，它拥有Input Iterator的所有特性，和Output Iterator的部分特性，以及单步向前迭代元素的能力
- Bidirectional Iterator: 该类迭代器是在Forward Iterator的基础上提供了单步向后迭代元素的能力，从而使得可以双向移动
- Random Access Iterator： 前4种迭代器只提供部分指针算术能力（前3种支持++运算符，后一种还支持--运算符)，而本迭代器则支持所有指针的算术运算，包括p+n、p-n、p[n]、p1-p2、p1<p2

上述5种迭代器的继承关系如下图所示：
#+DOWNLOADED: file:E%3A/org/%E5%9B%BE%E7%89%87/Snipaste_2021-04-11_14-30-22.png @ 2021-04-11 14:30:26
[[file:STL%E5%AE%B9%E5%99%A8%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%A4%B1%E6%95%88%E6%83%85%E5%86%B5%E5%88%86%E6%9E%90%E3%80%81%E6%80%BB%E7%BB%93/2021-04-11_14-30-26_Snipaste_2021-04-11_14-30-22.png]]
了解了迭代器的类型，我们就能解释vector的迭代器和list迭代器的区别了。显然，vector迭代器具有所有指针算术运算能力，而list由于是双向链表，因此只有双向读写不能随机访问元素。故vector的迭代器种类为Random Access Iterator，而list的迭代器种类为Bidirectional Iterator。我们只需要根据不同的迭代器种类，利用traits编程技巧萃取出迭代器型别，然后由C++重载机制就能够对不同型别的迭代器采用不同的处理流程了。为此，对于每个迭代器都必须定义型别iterator_category，也就是上文代码中的typedef std:forward_iterator_tag iterator_category，实际上可以直接继承STL中定义的iterator模板，模板后三个参数都有默认值，因此继承时只需要指定前两个模板参数即可。如下所示，STL定义了5个空类型作为迭代器的标签：
#+BEGIN_SRC c++
template<class Category,class T,class Distance = ptrdiff_t,class Pointer=T*,class Reference=T&>
class iterator{
    typedef Category iterator_category;
    typedef T        value_type;
    typedef Distance difference_type;
    typedef Pointer  pointer;
    typedef Reference reference;
};

struct input_iterator_tag{};
struct output_iterator_tag{};
struct forward_iterator_tag:public input_iterator_tag{};
struct bidirectional_iterator_tag:public forward_iterator_tag{};
struct random_access_iterator_tag:public bidirectional_iterator_tag{};
#+END_SRC
*** 利用迭代器种类更有效的实现distance函数
回到distance函数，有了前面的基础，我们可以根据不同迭代器种类实现distance函数（distance.cpp)：
#+BEGIN_SRC c++
#include <iostream>
#include <vector>
#include <list>

# if 0
template <class _InputIterator, class _Distance>
inline void __distance(_InputIterator __first, _InputIterator __last,
                       _Distance& __n, std::input_iterator_tag)
{
  while (__first != __last) { ++__first; ++__n; }
}

template <class _RandomAccessIterator, class _Distance>
inline void __distance(_RandomAccessIterator __first, 
                       _RandomAccessIterator __last, 
                       _Distance& __n, std::random_access_iterator_tag)
{
  __n += __last - __first;
}

template <class _InputIterator, class _Distance>
inline void distance(_InputIterator __first, 
                     _InputIterator __last, _Distance& __n)
{
 typedef typename std::iterator_traits<_InputIterator>::iterator_category _Category;
  __distance(__first, __last, __n, _Category());
}
#else
//注： 这里需要放在一个新的namespace中，否则可能会与STL中的相冲突	
namespace DT{
template<class InputIterator>
inline typename std::iterator_traits<InputIterator>::difference_type distance(InputIterator first, InputIterator last){
	typedef typename std::iterator_traits<InputIterator>::iterator_category _Category;
	return __distance(first, last, _Category());
}
template<class InputIterator>
inline typename std::iterator_traits<InputIterator>::difference_type __distance(InputIterator first, InputIterator last, std::input_iterator_tag){
	typename std::iterator_traits<InputIterator>::difference_type n = 0;
	while (first != last){
		++first; ++n;
	}
	return n;
}

template<class InputIterator>
inline typename std::iterator_traits<InputIterator>::difference_type \
__distance(InputIterator first, InputIterator last, std::random_access_iterator_tag){
	return last - first;
}
}	
#endif


int main(int argc, char *argv[])
{

	int a[] = {1,2,3,4};
	std::vector<int> vec;
	vec.push_back(1);
	vec.push_back(2);
	vec.push_back(3);
	vec.push_back(4);
	
	std::list<int> lst;
	lst.push_back(1);
	lst.push_back(2);
	lst.push_back(3);
	lst.push_back(4);
	

	# if 0
		int vec_distance = 0, lst_distance = 0, carr_distance = 0;
		distance(vec.begin(), vec.end(), vec_distance);
		distance(lst.begin(), lst.end(), lst_distance);
		distance(a, a + sizeof(a)/sizeof(*a), carr_distance);
		
		std::cout<<"vec distance:"<<vec_distance<<std::endl;
		std::cout<<"lst distance:"<<lst_distance<<std::endl;
		std::cout<<"c-array distance:"<<carr_distance<<std::endl;
	#else
		std::cout<<"vec distance:"<<DT::distance(vec.begin(), vec.end())<<std::endl;
		std::cout<<"lst distance:"<<DT::distance(lst.begin(), lst.end())<<std::endl;
		std::cout<<"c-array distance:"<<DT::distance(a, a + sizeof(a)/sizeof(*a))<<std::endl;
	#endif
	
}
#+END_SRC
编译运行：
#+BEGIN_EXAMPLE
# gcc -o distance distance.cpp -lstdc++
# ./distance 
vec distance:4
lst distance:4
c-array distance:4
#+END_EXAMPLE
上面通过STL定义的iterator_traits模板可以萃取不同种类的迭代器特性，iterator_traits还对指针和常量指针有特化版本，因此也可以萃取原生指针的特性。具体实现如下：
#+BEGIN_SRC c++
template <class _Tp, class _Distance> struct input_iterator {
  typedef input_iterator_tag iterator_category;
  typedef _Tp                value_type;
  typedef _Distance          difference_type;
  typedef _Tp*               pointer;
  typedef _Tp&               reference;
};

struct output_iterator {
  typedef output_iterator_tag iterator_category;
  typedef void                value_type;
  typedef void                difference_type;
  typedef void                pointer;
  typedef void                reference;
};

template <class _Tp, class _Distance> struct forward_iterator {
  typedef forward_iterator_tag iterator_category;
  typedef _Tp                  value_type;
  typedef _Distance            difference_type;
  typedef _Tp*                 pointer;
  typedef _Tp&                 reference;
};


template <class _Tp, class _Distance> struct bidirectional_iterator {
  typedef bidirectional_iterator_tag iterator_category;
  typedef _Tp                        value_type;
  typedef _Distance                  difference_type;
  typedef _Tp*                       pointer;
  typedef _Tp&                       reference;
};

template <class _Tp, class _Distance> struct random_access_iterator {
  typedef random_access_iterator_tag iterator_category;
  typedef _Tp                        value_type;
  typedef _Distance                  difference_type;
  typedef _Tp*                       pointer;
  typedef _Tp&                       reference;
};

template <class _Iterator>
struct iterator_traits {
  typedef typename _Iterator::iterator_category iterator_category;
  typedef typename _Iterator::value_type        value_type;
  typedef typename _Iterator::difference_type   difference_type;
  typedef typename _Iterator::pointer           pointer;
  typedef typename _Iterator::reference         reference;
};

template <class _Tp>
struct iterator_traits<_Tp*> {
  typedef random_access_iterator_tag iterator_category;
  typedef _Tp                         value_type;
  typedef ptrdiff_t                   difference_type;
  typedef _Tp*                        pointer;
  typedef _Tp&                        reference;
};

template <class _Tp>
struct iterator_traits<const _Tp*> {
  typedef random_access_iterator_tag iterator_category;
  typedef _Tp                         value_type;
  typedef ptrdiff_t                   difference_type;
  typedef const _Tp*                  pointer;
  typedef const _Tp&                  reference;
};
#+END_SRC

*** 3.5 小结
STL使用迭代器算法和容器结合，利用迭代器型别可以针对不同迭代器编写更加高效的算法，这一点很重要的思想就是： 利用C++重载机制和参数推导机制将运行期决议问题提前到编译期决议，也就是说，我们不需要在运行时判断迭代器的类型，而是在编译期就已经决定。这很符合C++模板编程的理念。在后续STL学习中，我们会实现自己的各种容器，也必须实现各种各样的迭代器，因此迭代器的学习还远没有停止。
** C++中模板使用时候typename和class的区别
在C++ Template中很多地方都用到了typename与class这两个关键字，而且好像可以替换，是不是这两个关键字完全一样呢？ 相信学习C++的人对class这个关键字都非常明白，class用于定义类，在C++中引入模板后，最初定义模板的方法为：
#+BEGIN_EXAMPLE
template<class T>....
#+END_EXAMPLE
在这里class关键字表明T是一个类型，后来为了避免class在这两个地方的使用可能给人带来混淆，所以引入typename这个关键字，它的作用同class一样表明后面的符号为一个类型，这样在定义模板的时候就可以使用下面的方式了：
#+BEGIN_EXAMPLE
template<typename T>...
#+END_EXAMPLE
在模板定义语法中关键字class与typename的作用完全一样。

typename难道仅仅在模板定义中起作用吗？ 其实不是这样，typename另外一个作用为： 使用嵌套依赖类型(nested depended name), 如下所示
#+BEGIN_SRC c++
class MyArray{
public:
	typedef int LengthType;
	....
};

template<class T>
void MyMethod(T myarr){
	typedef typename T::LengthType LengthType;
	LengthType length = myarr.GetLength();
}
#+END_SRC
这个时候typename的作用就是告诉C++编译器，typename后面的字符串为一个类型名称，而不是成员函数或者成员变量。这个时候如果前面没有typename，编译器没有任何办法知道T::LengthType是一个类型还是一个成员名称(静态数据成员或者静态函数），所以编译不能够通过。
* set自定义去重和排序函数
** 方法一：使用std::set内置的less比较函数（直接定义内置类型的set对象）

这种方法适用于：1）比较int、char等内置类型。2）只能针对某一个内置类型去重和排序：如果想通过id（int）去重，并通过hot(int)排序，该种方法就束手无策了。代码如下：
#+BEGIN_SRC c++
#include <iostream>
#include <set>
using namespace std;
void main()
{
    std::set<int> mySet;    // 直接定义内置类型set集合
    mySet.insert(10);       // 默认比较函数为less
    mySet.insert(20);       // 从小到大排序
    for(auto it:mySet)
    {
        std::cout<<it<<std::endl;
    }
    std::cout<<"end"<<std::endl;

}
#+END_SRC
#+BEGIN_EXAMPLE
结果如下：
output：
            10
            20
            end
#+END_EXAMPLE

** 方法二：自定义类（结构体）比较函数

前文提到：直接定义内置类型的set对象，即使用std::set内置的默认的less比较函数，可能不能满足我们的实际需求。例如：现在有一批结构体对象，需要将其插入set集合，并按照id去重，按照热度hot进行排序。这个时候，就需要重新自定义比较函数了。有两种方法可以自定义比较函数：
*** 重载<操作符
甚么要重载<运算符呢？能不能重载"<="或者">="运算符？答案是不可以。几乎所有的方法或容器都需要排序来满足数学意义上的标准严格弱序化，否则这些方法或容器的行为将不可预知。假设f(x,y)是一个比较函数。 如果该函数满足如下条件则它是严格弱序化的。
1. f(x,x) = false; 
2. if f(x,y) then !f(y,x)
3. if f(x,y) and f(y,z) then f(x,z)
4. if !f(x,y)&&!f(y,x) then x==y; if x==y and y==z then x==z;

看上去有点晕乎，不过不用担心，只要你的比较方法能够满足对相等元素永远返回false（记住一个准则：永远让比较函数对相同元素返回false），那你的方法就满足要求了。

其实，set容器在判定已有元素a和新插入元素b是否相等时，是这么做的：
1. 将a作为左操作数，b作为有操作数，调用比较函数，并返回比较值  
2. 将b作为左操作数，a作为有操作数，再调用一次比较函数，并返回比较值。如果1、2两步的返回值都是false，则认为a、b是相等的，则b不会被插入set容器中；

如果1、2两步的返回值都是true，则可能发生未知行为，因此，记住一个准则：永远让比较函数对相同元素返回false。
#+BEGIN_SRC c++
#include <iostream>
#include <set>
using namespace std;
struct song
{
    int m_id;
    int m_hot;
    song(int id,int hot)
    {

        this->m_id = id;
        this->m_hot = hot;
    }
    bool operator<(const struct song & right)const   //重载<运算符
    {
        if(this->m_id == right.m_id)     //根据id去重
            return false;
        else
        {
            if(this->m_hot != right.m_hot)
            {
                return this->m_hot > right.m_hot;      //降序
            }
            else
            {
                return this->m_id > right.m_id;     
            }
        }
    }
};
void main()
{
    std::set<song> mySet;
    song s1(10,100);
    song s2(20,200);
    song s3(20,300);
    song s4(30,200);
    mySet.insert(s1);    //插入s1
    mySet.insert(s2);    //插入s2
    mySet.insert(s3);    //s3和s2的id相同，不插入
    mySet.insert(s4);    //插入s4
    for(auto it:mySet)
    {
        std::cout<<"id:"<<it.m_id<<",hot:"<<it.m_hot<<std::endl;
    }
    std::cout<<"end"<<std::endl;
;}
#+END_SRC
#+BEGIN_EXAMPLE
结果如下：
id：30，hot ： 200
id：20，hot ： 200
id：10，hot ： 100
end
#+END_EXAMPLE
*** 重载（）运算符
具体代码如下：
#+BEGIN_SRC c++
#include <iostream>
#include <set>
using namespace std;
struct song
{
    int m_id;
    int m_hot;
    song(int id,int hot)
    {

        this->m_id = id;
        this->m_hot = hot;
    }
    /*
    bool operator<(const struct song & right)const   //重载<运算符
    {
        if(this->m_id == right.m_id)     //根据id去重
            return false;
        else
        {
            if(this->m_hot != right.m_hot)
            {
                return this->m_hot > right.m_hot;      //降序
            }
            else
            {
                return this->m_id > right.m_id;
            }
        }
    }
    */
};
struct comp
{
    bool operator()(struct song left,struct song  right)  //重载（）运算符
    {

        if(left.m_id == right.m_id)     //根据id去重
            return false;
        else
        {
            if(left.m_hot != right.m_hot)
            {
                return left.m_hot > right.m_hot;      //降序
            }
            else
            {
                return left.m_id > right.m_id;
            }

        }
    }

};
void main()
{
    std::set<song,comp> mySet;      //写法和2.1中的的区别
    song s1(10,100);
    song s2(20,200);
    song s3(20,300);
    song s4(30,200);
    mySet.insert(s1);    //插入s1
    mySet.insert(s2);    //插入s2
    mySet.insert(s3);    //s3和s2的id相同，不插入
    mySet.insert(s4);    //插入s4
    for(auto it:mySet)
    {
        std::cout<<"id:"<<it.m_id<<",hot:"<<it.m_hot<<std::endl;
    }
    std::cout<<"end"<<std::endl;
};
#+END_SRC
#+BEGIN_EXAMPLE
结果如下：
id：30，hot ： 200
id：20，hot ： 200
id：10，hot ： 100
end
#+END_EXAMPLE
* SFML
SFML 是多媒体库，它为PC的各个组件提供简单的界面，用来简化游戏和多媒体应用程序的开发。 主要由五个模块组成，分别是：系统，窗口，图形，音频和网络。

SFML 是跨平台的，通过 SFML，你的应用程序可以在最常见的操作系统上进行编译和运行：Windows，Linux，macOS以及Android和iOS。

SFML 支持多种语言，具体可以在官网查看支持的语言。
* std
** 介绍
std::是个名称空间标识符，C++标准库中的函数或者对象都是在命名空间std中定义的，所以我们要使用标准库中的函数或者对象都要用std来限定。

至于为什么将cout放到名字空间std中，是因为象cout这样的对象在实际操作中或许会有好多个，比如说你自己也可能会不小心定义一个对象叫cout，那么这两个cout对象就会产生冲突。


一般来说，std都是要调用C++标准库时使用。比如：使用标准库文件iostream时，要写上std;使用非标准库文件iostream.h，不用写。如图引入非标准库iostream.h时，省去了std::
#+BEGIN_SRC c++
#include <iostream.h>
#+END_SRC

当然使用标准库时，也是可以省略的，不过需要进行处理

1. 分别将cout和endl释放出来
#+BEGIN_SRC c++
#include <iostream>
using std::cout;
using std::endl;
#+END_SRC

2. 将命名空间释放出来

注：using namespace std 告诉编辑器我们将要使用名字空间std中的函数或者对象，所以cout和endl前面不用注明他们是std这个名字空间中的cout和endl
#+BEGIN_SRC c++
#include <iostream>
using namespace std;
#+END_SRC

** transform
transform函数的作用是：将某操作应用于指定范围的每个元素。transform函数有两个重载版本：

transform(first,last,result,op);//first是容器的首迭代器，last为容器的末迭代器，result为存放结果的容器，op为要进行操作的一元函数对象或sturct、class。

transform(first1,last1,first2,result,binary_op);//first1是第一个容器的首迭代 器，last1为第一个容器的末迭代器，first2为第二个容器的首迭代器，result为存放结果的容器，binary_op为要进行操作的二元函数 对象或sturct、class。

注意：第二个重载版本必须要保证两个容器的元素个数相等才行，否则会抛出异常
*** 例子
看一个例子：利用transform函数将一个给定的字符串中的小写字母改写成大写字母，并将结果保存在一个叫second的数组里，原字符串内容不变。
我们只需要使用transform的第一个重载函数，当然我们也可以使用for_each函数来完成再copy几次就行了，现在来看一下代码：
#+BEGIN_SRC c++
#include <iostream>
#include <algorithm>
using namespace std;
char op(char ch)
{

   if(ch>='A'&&ch<='Z')
        return ch+32;
    else
        return ch;
}
int main()
{
    string first,second;
    cin>>first;
    second.resize(first.size());
    transform(first.begin(),first.end(),second.begin(),op);
    cout<<second<<endl;
    return 0;
}
#+END_SRC

再看一个例子：给你两个vector向量（元素个数相等），请你利用transform函数将两个vector的每个元素相乘，并输出相乘的结果。
代码：
foreach的用法
#+BEGIN_SRC c++
#include <iostream>
#include <algorithm>
#include <vector>
using namespace std;
void print(int &elem){cout<<elem<<" ";}
int op(int a,int b){return a*b;}
int main()
{
    vector <int> A,B,SUM;
    int n;
    cin>>n;
    for(int i=0;i<n;i++)
    {
        int t;
        cin>>t;
        A.push_back(t);
    }
    for(int i=0;i<n;i++)
    {
        int t;
        cin>>t;
        B.push_back(t);
    }
    SUM.resize(n);
    transform(A.begin(),A.end(),B.begin(),SUM.begin(),op);
    for_each(SUM.begin(),SUM.end(),print);
    return 0;
}
#+END_SRC
** to_string
** all_of
all_of() 算法会返回 true，前提是序列中的所有元素都可以使谓词返回 true。

*** 实例
下面是一段代码，用来展示用 all_of() 检查 ages 容器中的元素： 
#+BEGIN_SRC c++
int good_age{100};
std::cout << (std::all_of(std::begin(ages), std::end(ages),[good_age] (int age) { return age < good_age; }) ? "None": "Some") << " of the people are centenarians." << std::endl;
#+END_SRC
这个 lambda 表达式会将 ages 中的元素和 good_age 的值作比较，good_age 的值为 100。所有的元素都小于 100，所以 all_of() 会返回 true，而且输出消息会正确报告没有记录的百岁老人。
** accumulate
accumulate定义在#include<numeric>中，作用有两个，一个是累加求和，另一个是自定义类型数据的处理

1. 累加求和
~int sum = accumulate(vec.begin() , vec.end() , 42);~

accumulate带有三个形参：头两个形参指定要累加的元素范围，第三个形参则是累加的初值。

accumulate函数将它的一个内部变量设置为指定的初始值，然后在此初值上累加输入范围内所有元素的值。accumulate算法返回累加的结果，其返回类型就是其第三个实参的类型。

可以使用accumulate把string型的vector容器中的元素连接起来：

~string sum = accumulate(v.begin() , v.end() , string(" "));~

这个函数调用的效果是：从空字符串开始，把vec里的每个元素连接成一个字符串。

2. 自定义数据类型的处理

C++ STL中有一个通用的数值类型计算函数— accumulate(),可以用来直接计算数组或者容器中C++内置数据类型，例如：
#+BEGIN_SRC c++
#include <numeric>  
int arr[]={10,20,30,40,50};  
vector<int> va(&arr[0],&arr[5]);  
int sum=accumulate(va.begin(),va.end(),0);  //sum = 150  
#+END_SRC
但是对于自定义数据类型，我们就需要自己动手写一个回调函数来实现自定义数据的处理，然后让它作为accumulate()的第四个参数，accumulate()的原型为
#+BEGIN_SRC c++
template<class _InIt, class _Ty,  class _Fn2> 
inline _Ty _Accumulate(_InIt _First, _InIt _Last, _Ty _Val, _Fn2 _Func)  
{   // return sum of _Val and all in [_First, _Last), using _Func  
    for (; _First != _Last; ++_First)  
        _Val = _Func(_Val, *_First);  
    return (_Val);  
}
#+END_SRC
下面是例子：
#+BEGIN_SRC c++

#include <vector>  
#include <string>  
using namespace std;  
  
struct Grade  
{  
    string name;  
    int grade;  
};  
  
int main()  
{  
    Grade subject[3] = {  
        { "English", 80 },  
        { "Biology", 70 },  
        { "History", 90 }  
    };  
  
    int sum = accumulate(subject, subject + 3, 0, [](int a, Grade b){return a + b.grade; });  
    cout << sum << endl;  
  
    system("pause");  
    return 0;  
} 
#+END_SRC
* typedef
** 定义类型
* typeid
typeid可以返回数据类型。

语法
#+begin_src cpp
#include <typeinfo>

typeid ( type );
typeid ( expression );
#+end_src

** 例子
#+begin_src cpp
  // C++ program to show the use of typeid operator

#include <iostream>
#include <typeinfo>
using namespace std;

int main()
{
    int i, j;
    char c;

    // Get the type info using typeid operator
    const type_info& ti1 = typeid(i);
    const type_info& ti2 = typeid(j);
    const type_info& ti3 = typeid(c);

    // Check if both types are same
    if (ti1 == ti2)
        cout << "i and j are of"
             << " similar type" << endl;
    else
        cout << "i and j are of"
             << " different type" << endl;

    // Check if both types are same
    if (ti2 == ti3)
        cout << "j and c are of"
             << " similar type" << endl;
    else
        cout << "j and c are of"
             << " different type" << endl;

    return 0;
}
#+end_src
Output
#+begin_example
i and j are of similar type
j and c are of different type
#+end_example
#+begin_src cpp
// C++ program to show the use of typeid operator

#include <iostream>
#include <typeinfo>
using namespace std;

int main()
{
    int i = 5;
    float j = 1.0;
    char c = 'a';

    // Get the type info using typeid operator
    const type_info& ti1 = typeid(i * j);
    const type_info& ti2 = typeid(i * c);
    const type_info& ti3 = typeid(c);

    // Print the types
    cout << "ti1 is of type "
         << ti1.name() << endl;

    cout << "ti2 is of type "
         << ti2.name() << endl;

    cout << "ti3 is of type "
         << ti3.name() << endl;

    return 0;
}
#+end_src
Output:
#+begin_example
ti1 is of type f
ti2 is of type i
ti3 is of type c
#+end_example

* vector
** 初始化
vector<int> ilist1;

默认初始化，vector为空， size为0，表明容器中没有元素，而且 capacity 也返回 0，意味着还没有分配内存空间。这种初始化方式适用于元素个数未知，需要在程序中动态添加的情况。

vector<int> ilist2(ilist);

vector<int> ilist2  = ilist; 

两种方式等价 ，ilist2 初始化为ilist 的拷贝，ilist必须与ilist2 类型相同，也就是同为int的vector类型，ilist2将具有和ilist相同的容量和元素

vector<int> ilist = {1,2,3.0,4,5,6,7};

vector<int> ilist {1,2,3.0,4,5,6,7};

ilist 初始化为列表中元素的拷贝，列表中元素必须与ilist的元素类型相容，本例中必须是与整数类型相容的类型，整形会直接拷贝，其他类型会进行类型转换。

vector<int> ilist3(ilist.begin()+2,ilist.end()-1);

ilist3初始化为两个迭代器指定范围中元素的拷贝，范围中的元素类型必须与ilist3 的元素类型相容，在本例中ilist3被初始化为{3,4,5,6}。注意：由于只要求范围中的元素类型与待初始化的容器的元素类型相容，因此迭代器来自不同的容器是可能的，例如，用一个double的list的范围来初始化ilist3是可行的。另外由于构造函数只是读取范围中的元素进行拷贝，因此使用普通迭代器还是const迭代器来指出范围并没有区别。这种初始化方法特别适合于获取一个序列的子序列。

vector<int> ilist4(7);

默认值初始化，ilist4中将包含7个元素，每个元素进行缺省的值初始化，对于int，也就是被赋值为0，因此ilist4被初始化为包含7个0。当程序运行初期元素大致数量可预知，而元素的值需要动态获取的时候，可采用这种初始化方式。

vector<int> ilist5(7,3);

指定值初始化，ilist5被初始化为包含7个值为3的int
* volatile
** 为什么要用volatile？
volatile 关键字是一种类型修饰符，用它声明的类型变量表示可以被某些编译器未知的因素更改。比如：操作系统、硬件或者其它线程等。遇到这个关键字声明的变量，编译器对访问该变量的代码就不再进行优化，从而可以提供对特殊地址的稳定访问。

声明时语法：volatile int vInt;

当要求使用 volatile 声明的变量的值的时候，系统总是重新从它所在的内存读取数据，即使它前面的指令刚刚从该处读取过数据。例如：
#+begin_src c++
volatile int i=10;
int a = i;
int b = i; 
#+END_SRC
volatile 指出 i 是随时可能发生变化的，每次使用它的时候必须从 i的地址中读取，因而编译器生成的汇编代码会重新从i的地址读取数据放在 b 中。而优化做法是，由于编译器发现两次从 i读数据的代码之间的代码没有对 i 进行过操作，它会自动把上次读的数据放在 b 中。而不是重新从 i 里面读。这样以来，如果 i是一个寄存器变量或者表示一个端口数据就容易出错，所以说 volatile 可以保证对特殊地址的稳定访问。

下面通过插入汇编代码，测试有无 volatile 关键字，对程序最终代码的影响：
#+begin_src c++
#include <stdio.h>
void main()
{
    int i = 10;
    int a = i;

    printf("i = %d", a);

    // 下面汇编语句的作用就是改变内存中 i 的值
    // 但是又不让编译器知道
    __asm {
        mov dword ptr [ebp-4], 20h
    }

    int b = i;
    printf("i = %d", b);
}
#+END_SRC
然后，在 Debug 版本模式运行程序，输出结果如下：
#+BEGIN_EXAMPLE
i = 10
i = 32
#+END_EXAMPLE
然后，在 Release 版本模式运行程序，输出结果如下：
#+BEGIN_EXAMPLE
i = 10
i = 10
#+END_EXAMPLE

输出的结果明显表明，Release 模式下，编译器对代码进行了优化，第二次没有输出正确的 i 值。下面，我们把 i 的声明加上 volatile 关键字，看看有什么变化：
#+begin_src c++
#include <stdio.h>
void main()
{
    volatile int i = 10;
    int a = i;

    printf("i = %d", a);

    // 下面汇编语句的作用就是改变内存中 i 的值
    // 但是又不让编译器知道
    __asm {
        mov dword ptr [ebp-4], 20h
    }

    int b = i;
    printf("i = %d", b);
}
#+END_SRC
分别在 Debug 和 Release 版本运行程序，输出都是：
#+begin_src c++
i = 10
i = 32
#+END_SRC
这说明这个 volatile 关键字发挥了它的作用。其实不只是“内嵌汇编操纵栈”这种方式属于编译无法识别的变量改变，另外更多的可能是多线程并发访问共享变量时，一个线程改变了变量的值，怎样让改变后的值对其它线程 visible。一般说来，volatile用在如下的几个地方：
1. 中断服务程序中修改的供其它程序检测的变量需要加volatile；
2. 多任务环境下各任务间共享的标志应该加volatile；
3. 存储器映射的硬件寄存器通常也要加volatile说明，因为每次对它的读写都可能由不同意义；

** 参考文章
[[https://zhuanlan.zhihu.com/p/62060524][C/C++ 中的 volatile-知乎]]

* 友元
友元可以是一个函数，该函数被称为友元函数；友元也可以是一个类，该类被称为友元类，在这种情况下，整个类及其所有成员都是友元。

类的友元函数是定义在类外部，但有权访问类的所有私有（private）成员和保护（protected）成员。尽管友元函数的原型有在类的定义中出现过，但是友元函数并不是成员函数。

** 友元函数
将全局函数声明为友元的写法如下：
#+begin_src c++
friend  返回值类型  函数名(参数表);
#+END_SRC

将其他类的成员函数声明为友元的写法如下：
#+begin_src c++
friend  返回值类型  其他类的类名::成员函数名(参数表);
#+END_SRC

但是，不能把其他类的私有成员函数声明为友元。

#+begin_src c++
#include<iostream>
using namespace std;
class CCar;  //提前声明CCar类，以便后面的CDriver类使用
class CDriver
{
public:
    void ModifyCar(CCar* pCar);  //改装汽车
};
class CCar
{
private:
    int price;
    friend int MostExpensiveCar(CCar cars[], int total);  //声明友元
    friend void CDriver::ModifyCar(CCar* pCar);  //声明友元
};
void CDriver::ModifyCar(CCar* pCar)
{
    pCar->price += 1000;  //汽车改装后价值增加
}
int MostExpensiveCar(CCar cars[], int total)  //求最贵气车的价格
{
    int tmpMax = -1;
    for (int i = 0; i<total; ++i)
        if (cars[i].price > tmpMax)
            tmpMax = cars[i].price;
    return tmpMax;
}
int main()
{
    return 0;
}
#+END_SRC
这个程序只是为了展示友元的用法，所以 main 函数什么也不做。

第 3 行声明了 CCar 类，CCar 类的定义在后面。之所以要提前声明，是因为 CDriver 类的定义中用到了 CCar 类型（第7行），而此时 CCar 类还没有定义，编译会报错。

不要第 3 行，而把 CCar 类的定义写在 CDriver 类的前面，是解决不了这个问题的，因为 CCar 类中也用到了 CDriver 类型（第14行），
把 CCar 类的定义写在前面会导致第 14 行的 CDriver 因没有定义而报错。C++ 为此提供的解决办法是：可以简单地将一个类的名字提前声明，写法如下：

class  类名;

尽管可以提前声明，但是在一个类的定义出现之前，仍然不能有任何会导致该类对象被生成的语句。但使用该类的指针或引用是没有问题的。

第 13 行将全局函数 MostExpensiveCar 声明为 CCar 类的友元，因此在第 24 行可以访问 cars[i] 的私有成员 price。
同理，第 14 行将 CDriver 类的 ModifyCar 成员函数声明为友元，因此在第 18 行可以访问 pCar 指针所指向的对象的私有成员变量 price。
** 友元类
一个类 A 可以将另一个类 B 声明为自己的友元，类 B 的所有成员函数就都可以访问类 A 对象的私有成员。在类定义中声明友元类的写法如下：
#+begin_src c++
friend  class  类名;
#+END_SRC
来看如下例程：
#+begin_src c++
class CCar
{
private:
    int price;
    friend class CDriver;  //声明 CDriver 为友元类
};
class CDriver
{
public:
    CCar myCar;
    void ModifyCar()  //改装汽车
    {
        myCar.price += 1000;  //因CDriver是CCar的友元类，故此处可以访问其私有成员
    }
};
int main()
{
    return 0;
}

#+END_SRC
第 5 行将 CDriver 声明为 CCar 的友元类。这条语句本来就是在声明 CDriver 是一个类，所以 CCar 类定义前面就不用声明 CDriver 类了。
第 5 行使得 CDriver 类的所有成员函数都能访问 CCar 对象的私有成员。如果没有第 5 行，第 13 行对 myCar 私有成员 price 的访问就会导致编译错误。

一般来说，类 A 将类 B 声明为友元类，则类 B 最好从逻辑上和类 A 有比较接近的关系。
例如上面的例子，CDriver 代表司机，CCar 代表车，司机拥有车，所以 CDriver 类和 CCar 类从逻辑上来讲关系比较密切，把 CDriver 类声明为 CCar 类的友元比较合理。

友元关系在类之间不能传递，即类 A 是类 B 的友元，类 B 是类 C 的友元，并不能导出类 A 是类 C 的友元。
“咱俩是朋友，所以你的朋友就是我的朋友”这句话在 C++ 的友元关系上 不成立。
** 继承关系
*** 基类中的友元函数行为
C++中, 友元是不会继承的。如果基类有一个友元函数，则此函数不会成为子类的友元函数。

例如下面程序会编译失败，因为函数show()是基类A的友元函数，但无法访问子类B的私有数据。
#+begin_src c++
#include <iostream>
using namespace std;
class A {
protected:
    int x;
public:
    A() { x = 222; }
    friend void show();
};
 
class B : public A {
public:
    B() : y(111) {}
private:
    int y;
};
 
void show() {
    B b;
    cout << "The default value of A::x = " << b.x;
 
    // 编译失败。无法访问类'B'中的私有数据
    cout << "The default value of B::y = " << b.y;
}
 
int main() {
    show();
    return 0;
}

#+END_SRC

编译失败。第2行cout中，无法打印b.y。
编译提示(visual studio 2015)：
error C2248: “B::y”: 无法访问 private 成员(在“B”类中声明)

如果注释掉第2行cout，则编译通过，运行结果为：
The default value of A::x = 222
*** 子类中的友元函数的行为
反之，如果在子类中定义了一个友元函数，则它可以访问基类中的public以及protected数据。
因为子类B是公有继承A的，A中的public以及protected数据可以被B的对象访问。

如下面例子所示：
#+begin_src c++
#include <iostream>
using namespace std;
 
class A {
protected:
    int x;
public:
    A() { x = 22; z = 33; }
    int z;
};
 
class B : public A {
public:
    B() : y(11) {}
    friend void show();
private:
    int y;
};
 
void show() {
    B b;
    cout << "The default value of A::x = " << b.x << std::endl;
    cout << "The default value of A::z = " << b.z << std::endl;
    cout << "The default value of B::y = " << b.y << std::endl;
}
 
int main() {
    show();
    return 0;
}
#+END_SRC
输出：
#+begin_src c++
The default value of A::x = 22
The default value of A::z = 33
The default value of B::y = 11
#+END_SRC

** 参考文章
[[http://c.biancheng.net/view/169.html][C++友元函数和友元类（C++ friend）解详]]
[[https://www.runoob.com/cplusplus/cpp-friend-functions.html][C++ 友元函数]]
* 内存泄露
new 和 delete 是 C++ 用于管理堆内存的两个运算符，对应于C语言中的 malloc 和 free，但是 malloc 和 free 是函数，而new 和 delete 是运算符。除此之外，new 在申请内存的同时，还会调用对象的构造函数，而 malloc 只会申请内存；同样，delete 在释放内存之前，会调用对象的析构函数，而 free 只会释放内存。

new运算符申请内存：将调用相应的 operator new(size_t) 函数动态分配内存，在分配到的动态内存块上 初始化 相应类型的对象（构造函数）并返回其首地址。如果调用构造函数初始化对象时抛出异常，则自动调用 operator delete(void*, void*) 函数释放已经分配到的内存。

delete运算符释放内存：调用相应类型的析构函数，处理类内部可能涉及的资源释放，调用相应的 operator delete(void *) 函数。
** 内存是如何泄露的
在 C++ 程序中，主要涉及到的内存就是“栈”和“堆”

#+DOWNLOADED: file:F%3A/org/%E5%9B%BE%E7%89%87/v2-f3189547daa4548bc4ab6fdd13eeea6d_720w.png @ 2020-06-13 19:16:48
[[file:%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2/2020-06-13_19-16-48_v2-f3189547daa4548bc4ab6fdd13eeea6d_720w.png]]

通常来说，一个线程的栈内存是有限的，通常来说是 8M 左右（取决于运行的环境）。栈上的内存通常是由编译器来自动管理的。当在栈上分配一个新的变量时，或进入一个函数时，栈的指针会下移，相当于在栈上分配了一块内存。我们把一个变量分配在栈上，也就是利用了栈上的内存空间。当这个变量的生命周期结束时，栈的指针会上移，相同于回收了内存。

由于栈上的内存的分配和回收都是由编译器控制的，所以在栈上是不会发生内存泄露的，只会发生栈溢出（Stack Overflow），也就是分配的空间超过了规定的栈大小。

而堆上的内存是由程序直接控制的，程序可以通过 malloc/free 或 new/delete 来分配和回收内存，如果程序中通过 malloc/new 分配了一块内存，但忘记使用 free/delete 来回收内存，就发生了内存泄露。

*** 经验 #1：尽量避免在堆上分配内存
既然只有堆上会发生内存泄露，那第一原则肯定是避免在堆上面进行内存分配，尽可能的使用栈上的内存，由编译器进行分配和回收，这样当然就不会有内存泄露了。

然而，只在栈上分配内存，在有 IO 的情况下是存在一定局限性的。

举个例子，为了完成一个请求，我们通常会为这个请求构造一个 Context 对象，用于描述和这个请求有关的一些上下文。例如下面一段代码：
#+BEGIN_SRC c++
void Foo(Reuqest* req) {
    RequestContext ctx(req);
    HandleRequest(&ctx);
}
#+END_SRC
如果 HandleRequest 是一个同步函数，当这个函数返回时，请求就可以被处理完成，那么显然 ctx 是可以被分配在栈上的。

但如果 HandleRequest 是一个异步函数，例如：
#+BEGIN_SRC c++
void HandleRequest(RequestContext* ctx, Callback cb);
#+END_SRC
那么显然，ctx 是不能被分配在栈上的，因为如果 ctx 被分配在栈上，那么当 Foo 函数推出后，ctx 对象的生命周期也就结束了。而 FooCB 中显然会使用到 ctx 对象。
#+BEGIN_SRC c++
void HandleRequest(RequestContext* ctx, Callback cb);

void Foo(Reuqest* req) {
    auto ctx = new RequestContext(req);
    HandleRequest(ctx, FooCB);
}

void FooCB(RequestContext* ctx) {
    FinishRequest(ctx);
    delete ctx;
}
#+END_SRC
在这种情况下，如果忘记在 FooCB 中调用 delete ctx，则就会触发内存泄露。尽管我们可以借助一些静态检查工具对代码进行检查，但往往异步程序的逻辑是极其复杂的，一个请求的生命周期中，也需要进行大量的内存分配操作，静态检查工具往往无法发现所有的内存泄露情况。

那么怎么才能避免这种情况的产生呢？引入智能指针显然是一种可行的方法，但引入 shared_ptr 往往引入了额外的性能开销，并不十分理想。

在 SmartX，我们通常采用两种方法来应对这种情况。

*** 经验 #2：使用 Arena
Arena 是一种统一化管理内存生命周期的方法。所有需要在堆上分配的内存，不通过 malloc/new，而是通过 Arena 的 CreateObject 接口。同时，不需要手动的执行 free/delete，而是在 Arena 被销毁的时候，统一释放所有通过 Arena 对象申请的内存。所以，只需要确保 Arena 对象一定被销毁就可以了，而不用再关心其他对象是否有漏掉的 free/delete。这样显然降低了内存管理的复杂度。

此外，我们还可以将 Arena 的生命周期与 Request 的生命周期绑定，一个 Request 生命周期内的所有内存分配都通过 Arena 完成。这样的好处是，我们可以在构造 Arena 的时候，大概预估出处理完成这个 Request 会消耗多少内存，并提前将会使用到的内存一次性的申请完成，从而减少了在处理一个请求的过程中，分配和回收内存的次数，从而优化了性能。

我们最早看到 Arena 的思想，是在 LevelDB 的代码中。这段代码相当简单，建议大家直接阅读。

*** 经验 #3：使用 Coroutine
Coroutine 相信大家并不陌生，那 Coroutine 的本质是什么？我认为 Coroutine 的本质，是使得一个线程中可以存在多个上下文，并可以由用户控制在多个上下文之间进行切换。而在上下文中，一个重要的组成部分，就是栈指针。使用 Coroutine，意味着我们在一个线程中，可以创造（或模拟）多个栈。

有了多个栈，意味着当我们要做一个异步处理时，不需要释放当前栈上的内存，而只需要切换到另一个栈上，就可以继续做其他的事情了，当异步处理完成时，可以再切换回到这个栈上，将这个请求处理完成。

还是以刚才的代码为示例:
#+BEGIN_SRC c++
void Foo(Reuqest* req) {
    RequestContext ctx(req);
    HandleRequest(&ctx);
}

void HandleRequest(RequestCtx* ctx) {
    SubmitAsync(ctx);
    Coroutine::Self()->Yield();
    CompleteRequest(ctx);
}
#+END_SRC
这里的精髓在于，尽管 Coroutine::Self()->Yield() 被调用时，程序可以跳出 HandleRequest 函数去执行其他代码逻辑，但当前的栈却被保存了下来，所以 ctx 对象是安全的，并没有被释放。

这样一来，我们就可以完全抛弃在堆上申请内存，只是用栈上的内存，就可以完成请求的处理，完全不用考虑内存泄露的问题。然而这种假设过于理想，由于在栈上申请内存存在一定的限制，例如栈大小的限制，以及需要在编译是知道分配内存的大小，所以在实际场景中，我们通常会结合使用 Arena 和 Coroutine 两种技术一起使用。

有人可能会提到，想要多个栈用多个线程不就可以了？然而用多线程实现多个栈的问题在于，线程的创建和销毁的开销极大，且线程间切块，也就是在栈之间进行切换的代销需要经过操作系统，这个开销也是极大的。所以想用线程模拟多个栈的想法在实际场景中是走不通的。

关于 Coroutine 有很多开源的实现方式，大家可以在 github 上找到很多，C++20 标准也会包含 Coroutine 的支持。在 SmartX 内部，我们很早就实现了 Coroutine，并对所有异步 IO 操作进行了封装，示例可参考我们之前的一篇文章 smartx：基于 Coroutine 的异步 RPC 框架示例（C++）

这里需要强调一下，Coroutine 确实会带来一定的性能开销，通常 Coroutine 切换的开销在 20ns 以内，然而我们依然在对性能要求很苛刻的场景使用 Coroutine，一方面是因为 20ns 的性能开销是相对很小的，另一方面是因为 Coroutine 极大的降低了异步编程的复杂度，降低了内存泄露的可能性，使得编写异步程序像编写同步程序一样简单，降低了程序员心智的开销。

*** 经验 #4：善用 RAII
尽管在有些场景使用了 Coroutine，但还是可能会有在堆上申请内存的需要，而此时有可能 Arena 也并不适用。在这种情况下，善用 RAII（Resource Acquisition Is Initialization）思想会帮助我们解决很多问题。

简单来说，RAII 可以帮助我们将管理堆上的内存，简化为管理栈上的内存，从而达到利用编译器自动解决内存回收问题的效果。此外，RAII 可以简化的还不仅仅是内存管理，还可以简化对资源的管理，例如 fd，锁，引用计数等等。

当我们需要在堆上分配内存时，我们可以同时在栈上面分配一个对象，让栈上面的对象对堆上面的对象进行封装，用时通过在栈对象的析构函数中释放堆内存的方式，将栈对象的生命周期和堆内存进行绑定。

unique_ptr 就是一种很典型的例子。然而 unique_ptr 管理的对象类型只能是指针，对于其他的资源，例如 fd，我们可以通过将 fd 封装成另外一个 FileHandle 对象的方式管理，也可以采用一些更通用的方式。例如，在我们内部的 C++ 基础库中实现了 Defer 类，想法类似于 Go 中 defer。
#+BEGIN_SRC c++
void Foo() {
    int fd = open();
    Defer d = [=]() { close(fd); }
    // do something with fd
}
#+END_SRC

*** 经验 #5：便于 Debug
在特定的情况下，我们难免还是要手动管理堆上的内存。然而当我们面临一个正在发生内存泄露线上程序时，我们应该怎么处理呢？

当然不是简单的『重启大法好』，毕竟重启后还是可能会产生泄露，而且最宝贵的现场也被破坏了。最佳的方式，还是利用现场进行 Debug，这就要求程序具有便于 Debug 的能力。

这里不得不提到一个经典而强大的工具 gperftools。gperftools 是 google 开源的一个工具集，包含了 tcmalloc，heap profiler，heap checker，cpu profiler 等等。gperftools 的作者之一，就是大名鼎鼎的 Sanjay Ghemawat，没错，就是与 Jeff Dean 齐名，并和他一起写 MapReduce 的那个 Sanjay。

gperftools 的一些经典用法，我们就不在这里进行介绍了，大家可以自行查看文档。而使用 gperftools 可以在不重启程序的情况下，进行内存泄露检查，这个恐怕是很少有人了解。

实际上我们 Release 版本的 C++ 程序可执行文件在编译时全部都链接了 gperftools。在 gperftools 的 heap profiler 中，提供了 HeapProfilerStart 和 HeapProfilerStop 的接口，使得我们可以在运行时启动和停止 heap profiler。同时，我们每个程序都暴露了 RPC 接口，用于接收控制命令和调试命令。在调试命令中，我们就增加了调用 HeapProfilerStart 和 HeapProfilerStop 的命令。由于链接了 tcmalloc，所以 tcmalloc 可以获取所有内存分配和回收的信息。当 heap profiler 启动后，就会定期的将程序内存分配和回收的行为 dump 到一个临时文件中。

当程序运行一段时间后，你将得到一组 heap profile 文件
#+BEGIN_SRC bash
  profile.0001.heap
  profile.0002.heap
  ...
  profile.0100.heap
#+END_SRC
每个 profile 文件中都包含了一段时间内，程序中内存分配和回收的记录。如果想要找到内存泄露的线索，可以通过使用
#+BEGIN_SRC bash
pprof --base=profile.0001.heap /usr/bin/xxx profile.0100.heap --text
#+END_SRC
来进行查看，也可以生成 pdf 文件，会更直观一些。
#+DOWNLOADED: file:F%3A/org/%E5%9B%BE%E7%89%87/v2-a8eedcc8f07691a31707f5f8921acfa8_720w.png @ 2020-06-13 19:27:10
[[file:%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2/2020-06-13_19-27-10_v2-a8eedcc8f07691a31707f5f8921acfa8_720w.png]]
* 指针
** 字符指针
字符指针是指向字符或字符串的指针,例如 char*。
数组名存放的是首元素的地址，而指针同理存放的是首字符的地址。
但不同的是，字符型数组在初始化时会开辟新的内存块，用相同的常量字符串初始化不同数组也会开辟出不同的内存块。
而字符指针是指向一个地址，也就是说，不论是多少个字符指针，只要你指向的是同一个常量字符串，那么实际你指向的内存地址是不会发生变化的，因为作为常量的字符串有着它独一份不会改变的地址。

下面是一道非常经典的例题：
#+begin_src C
#include <stdio.h>
int main()
{
	char str1[] = "hello world.";
	char str2[] = "hello world.";
	char *str3  = "hello world.";
	char *str4  = "hello world.";

	if (str1 == str2)
	{
		printf("str1 and str2 are same\n");
	}
	else
	{
		printf("str1 and str2 are not same\n");
	}

	if (str3 == str4)
	{
		printf("str3 and str4 are same\n");
	}
	else
	{
		printf("str3 and str4 are not same\n");
	}
	return 0;
}
#+end_src
结果为:

#+DOWNLOADED: screenshot @ 2022-12-25 20:20:11
[[file:images/指针/2022-12-25_20-20-11_screenshot.png]]
由于str1和str2是数组名，表示数组首元素的地址，而他们在初始化时开辟的是不同的内存块，所以地址不同；而str3 和 str4是指针，指向的是首字符的地址，但作为字符串常量，它的地址是不变的，所以这两个字符指针所存放的地址是相同的。
** 指针数组和数组指针
指针数组是存放指针的数组。如int *arr[3] ,其中 [3] 的优先级高，确定它为一个数组，数组名为arr，类型为 int * 。

数组指针是指向数组的指针。如int (*p)[3], (*p)的优先级最高，确定它为一个指针，而指针指向的 [3] 是一个数组，数组类型为 int。

刚开始我们可能不太好分清楚指针数组和数组指针，他们的名字很相似，不免会使人混乱。那么如何分清指针数组与数组指针呢？答案就是优先级。我们可以将其拆分开来，最先定义优先级高的，一般判断出最高的优先级时，我们就能初步判定出它到底是数组还是指针，由此便可得出它的类型。

&数组名和数组名的区分 int arr[10]

我们都知道数组名表示数组首元素的地址，这在前面的字符数组中也提到过。例如 arr 表示 arr[10] 这个数组的首元素地址，即arr[1] 的地址。但当我们用 %p 去分别打印 arr 和 &arr 的地址时，会发现他们两个的地址是一样的。但他们的实际意义是相同的吗？我们可以通过下面一段代码来验证。
#+begin_src C
#include <stdio.h>
int main()
{
	int arr[10] = { 0 };
	printf("arr = %p\n", arr);
	printf("&arr = %p\n", &arr);
	printf("arr + 1 = %p\n", arr + 1);
	printf("&arr + 1 = %p\n", &arr + 1);
	return 0;
}
#+end_src
这段代码分别打印了 arr 、&arr 、arr+1 和 &arr+1 的地址。
结果为：

#+DOWNLOADED: screenshot @ 2022-12-25 20:21:17
[[file:images/指针/2022-12-25_20-21-17_screenshot.png]]
我们可以看到，当他们各自 +1 以后的结果不同，可知实际意义也有所不同。arr 与 arr+1 的差值为4，是一个int类型的大小，也就是跳过了一个元素。&arr 则表示的是数组的地址。数组的地址 +1 ，跳了整个数组的大小，而该数组有10个元素，每个元素都是int类型，所以 &arr+1 相对于 &arr 的差值刚好为40。由此可知，&arr 的类型为数组指针，他可以等同于 *int (p)[10] 。

** 函数指针
函数指针是能够指向函数的指针，例如 void (*Fun) ()。Fun 先和 * 结合，确定 Fun 为指针，而指针指向的是一个函数，指向的函数无参数，返回值类型为 void 。函数在调用时需要开辟栈帧，这时就会开辟出新的地址，而函数名就代表函数地址，函数指针则存储函数的地址。

在《c陷阱与缺陷》中，有这样两个代码：
#+begin_src c
(*(void (*)())0)();
#+end_src
这个代码看上去确实给人一种很混乱的感觉，毕竟有这么多的括号在内，但只要找到它的优先级，还是很好理解的。我们可以看到，其中中间的(void (*)())作为一部分整体是在0的前面，也就是对0进行一个类型的转换，将0强转为一个地址，(*)的优先级最高，表明它是一个指针，而指针指向的是一个函数()，函数的返回值为void。所以它转换后的地址的类型就是“指向返回值为void的函数的指针”。而整体就是调用0地址处的函数。

再来看另外一个代码：
#+begin_src c
void (*signal(int , void(*)(int)))(int);
#+end_src
同样是一段看上去比较复杂的代码,首先signal先与后面小括号结合，说明它是一个函数，它的参数是signal后面括号内的int和 void(*)(int)。而除了signal函数的其他部分表示的是函数的返回值，void(*) (int)，是一个函数指针。所以这个代码实际上就表示的是一个signal函数，函数的参数为 (int , void(*)(int)),函数的返回值是一个函数指针void(*) (int)。当然这个函数有简化的方式：
#+begin_src c
typedef void(*pfun_t)(int);
pfun_t signal(int , pfun_t);
#+end_src
第一个语句通过 typedef 将 pfun_t 定义为函数指针的类型，而第二个语句就十分明了，signal函数的参数为int 和 pfun_t，返回值为 pfun_t。
** 函数指针数组
我们知道了函数指针是指向函数的指针，那函数指针数组也就是存放函数指针的数组。
例如 int (*parr[10])()。首先它必须是一个数组，所以要先和中括号结合，拆分开来就是 parr[10]，它的优先级最高确定它是一个数组。其次是 * ，表明指针，而指向的内容就是后面的函数 () ，数组类型为 int 。

函数指针数组最大的用途：转移表。
#+begin_src c
#define _CRT_SECURE_NO_WARNINGS 1
#include <stdio.h>
int Add(int x, int y)
{
	return x + y;
}
int Sub(int x, int y)
{
	return x - y;
}
int Mul(int x, int y)
{
	return x * y;
}
int Div(int x, int y)
{
	return x / y;
}
//以上为加减乘除四个函数
void menu()
{
	printf("1.Add\n2.Sub\n3.Mul\n4.Div\n");
}
int main()
{
	int input = 0;//input用来做不同计算函数的选项
	int a = 0;
	int b = 0;
	int(*Pfun[5])(int, int) = { 0, Add, Sub, Mul, Div };
	//第一个元素为0,使元素下标1234分别代表加减乘除函数
	do
	{
		menu();
		printf("请输入菜单选项: ");
		scanf("%d", &input);
		if (input >= 1 && input <= 4)
		{
			printf("请输入两个操作数：");
			scanf("%d %d", &a, &b);
			printf("%d\n", Pfun[input](a, b));
			//Pfun[input](a, b)直接调用下标为input的函数
		}
	} while (input);
	return 0;
}
#+end_src
由以上代码我们可以看到，使用转移表会很大程度上去节省我们调用函数的空间，只需要通过函数指针数组访问元素下标地址去调用，而不用一一去调用，能让代码避免更加冗余。
** 指向函数指针数组的指针
在理解了函数指针数组之后，那么指向函数指针数组的指针也不难掌握。首先它是一个指针，指针指向一个数组，数组中的元素是函数指针。其实只要将每一层由内到外逐层分析理解，就不难分辨。

例如上文的函数指针数组int (*parr[10])(),那么 我们再增加一个指向该数组的指针，也就是
#+begin_src c
int (*(*parr)[10])()这是一个指向存放十个函数指针元素数组的指针。
#+end_src
** 二重指针
char**是二重指针，bai也就是指向指针变量的指针。 而char*是一维指针，即指向zhi字符变量的指针。

其区别在于，指向地址dao所存储的值不同。

对于char **p1, *p1的类型为char*型，而**p1的类型才是char型。

对于char*类指针p2，*p2就是char 型。
** .和->的区别
编译器会将p->member变成访问p+offset_member这个内存地址的变量

编译器会将s.member变成访问&s+offset_member这个内存地址的变量
** 参考文章
[[https://blog.csdn.net/weixin_44058932/article/details/90767275][C语言中不同类型指针的区别]]

* 字符串
** 字符串数组
#+BEGIN_SRC c++
char a[] = "hello";   //字符串数组，存放的是字符,a表示字符h的地址
#+END_SRC
*** 初始化
#+BEGIN_SRC c++
char a[10] ="hello";//字符串以'\0'结尾，这种方式系统会自动在数组未填值的地方添加'\0'
char b[] = {'h', 'e' , 'l', 'l', '\0'};//类似于初始化整型数组，必须要手动在后面添加'\0'
#+END_SRC
** 字符串指针数组
#+BEGIN_SRC c++
char *b[] = {"hello", "world"};//字符串指针数组，数组b总共有两个4字节的元素,第一个元素存储字符串"hello"的地址,即指向字符h的指针,第二个元素存储字符串"world"的地址,即指向字符w的指针.
#+END_SRC
* 谓词
A predicate is an expression that can be called and that returns a value that can be used as a condition. The predicates used by library algorithms are either unary predicates (meaning they have a single parameter) or binary predicates (meaning they have two parameters).

The version of sort that takes a binary predicate uses the given predicate in place of < to compare elements.

#+BEGIN_SRC c++
// comparison function to be used to sort by word length
bool isShorter(const string &s1, const string &s2)
C++ Primer, Fifth Edition
{
return s1.size() < s2.size();
}
// sort on word length, shortest to longest
sort(words.begin(), words.end(), isShorter);
#+END_SRC
* 模板
** 模板类
*** 模板类的继承
在模板类的继承中，需要注意以下两点：
- 如果父类自定义了构造函数，记得子类要使用构造函数列表来初始化
- 继承的时候，如果子类不是模板类，则必须指明当前的父类的类型，因为要分配内存空间
- 继承的时候，如果子类是模板类，要么指定父类的类型，要么用子类的泛型来指定父类

#+begin_src cpp
template <typename T>
class Parent{
public:
    Parent(T p)
    {
        this->p = p;
    }

private:
    T p;
};

//如果子类不是模板类，需要指明父类的具体类型
class ChildOne:public Parent<int>{

public:
    ChildOne(int a,int b):Parent(b)
    {
        this->cone = a;
    }

private:
    int cone;
};


//如果子类是模板类，可以用子类的泛型来表示父类
template <typename T>
class ChildTwo:public Parent<T>{

public:
    ChildTwo(T a, T b):Parent<T>(b)
    {
        this->ctwo = a;
    }

private:
    T ctwo;
};
#+end_src
* 默认实参
一旦某个实参被赋予了默认值，它后面所有的形参都必须有默认值。
** 默认实参声明
多次声明同一个函数是合法的，但是在给定的作用域中一个形参只能被赋予一次默认参数。
#+begin_src c++
  string screen(sz,sz,char=' ');
  string screen(sz,sz,char='*');//错误，重复声明。不能修改一个已经存在的默认值
  string screen(sz=24,sz=80,char);//正确，可以重复声明添加默认实参
#+END_SRC
** 默认实参初始值

* 右值
** 右值引用
右值引用的标志是&&，顾名思义，右值引用专门为右值而生，可以指向右值，不能指向左值：
#+begin_src c++
int &&ref_a_right = 5; // ok

int a = 5;
int &&ref_a_left = a; // 编译不过，右值引用不可以指向左值

ref_a_right = 6; // 右值引用的用途：可以修改右值
#+end_src
*** 指向左值
std::move可以让右值引用指向左值
#+begin_src c++
int a = 5; // a是个左值
int &ref_a_left = a; // 左值引用指向左值
int &&ref_a_right = std::move(a); // 通过std::move将左值转化为右值，可以被右值引用指向

cout << a; // 打印结果：5
#+end_src
std::move的功能是把左值强制转化为右值，让右值引用可以指向左值,其实现等同于一个类型转换：static_cast<T&&>(lvalue)。

同样的，右值引用能指向右值，本质上也是把右值提升为一个左值，并定义一个右值引用通过std::move指向该左值：
#+begin_src c++
int &&ref_a = 5;
ref_a = 6;

等同于以下代码：

int temp = 5;
int &&ref_a = std::move(temp);
ref_a = 6;
#+end_src
*** 右值引用本身是左值
被声明出来的左、右值引用都是左值。 因为被声明出的左右值引用是有地址的，也位于等号左边。仔细看下边代码：
#+begin_src c++
// 形参是个右值引用
void change(int&& right_value) {
    right_value = 8;
}

int main() {
    int a = 5; // a是个左值
    int &ref_a_left = a; // ref_a_left是个左值引用
    int &&ref_a_right = std::move(a); // ref_a_right是个右值引用

    change(a); // 编译不过，a是左值，change参数要求右值
    change(ref_a_left); // 编译不过，左值引用ref_a_left本身也是个左值
    change(ref_a_right); // 编译不过，右值引用ref_a_right本身也是个左值

    change(std::move(a)); // 编译通过
    change(std::move(ref_a_right)); // 编译通过
    change(std::move(ref_a_left)); // 编译通过

    change(5); // 当然可以直接接右值，编译通过

    cout << &a << ' ';
    cout << &ref_a_left << ' ';
    cout << &ref_a_right;
    // 打印这三个左值的地址，都是一样的
}
#+end_src
右值引用既可以是左值也可以是右值，如果有名称则为左值，否则是右值。
*** 左右值引用的异同
1. 从性能上讲，左右值引用没有区别，传参使用左右值引用都可以避免拷贝。
2. 右值引用可以直接指向右值，也可以通过std::move指向左值；而左值引用只能指向左值(const左值引用也能指向右值)。
3. 作为函数形参时，右值引用更灵活。虽然const左值引用也可以做到左右值都接受，但它无法修改，有一定局限性。
#+begin_src c++
  void f(const int& n) {
      n += 1; // 编译失败，const左值引用不能修改指向变量
  }

  void f2(int && n) {
      n += 1; // ok
  }


  int main() {
      f(5);
      f2(5);
  }
#+end_src
*** 右值引用和std::move的应用场景
*** 参考文章
[[https://zhuanlan.zhihu.com/p/335994370][一文读懂C++右值引用和std::move]]
按上文分析，std::move只是类型转换工具，不会对性能有好处；右值引用在作为函数形参时更具灵活性，看上去还是挺鸡肋的。他们有什么实际应用场景吗？

3.1 实现移动语义
在实际场景中，右值引用和std::move被广泛用于在STL和自定义类中实现移动语义，避免拷贝，从而提升程序性能。 在没有右值引用之前，一个简单的数组类通常实现如下，有构造函数、拷贝构造函数、赋值运算符重载、析构函数等。深拷贝/浅拷贝在此不做讲解。

class Array {
public:
    Array(int size) : size_(size) {
        data = new int[size_];
    }
     
    // 深拷贝构造
    Array(const Array& temp_array) {
        size_ = temp_array.size_;
        data_ = new int[size_];
        for (int i = 0; i < size_; i ++) {
            data_[i] = temp_array.data_[i];
        }
    }
     
    // 深拷贝赋值
    Array& operator=(const Array& temp_array) {
        delete[] data_;
 
        size_ = temp_array.size_;
        data_ = new int[size_];
        for (int i = 0; i < size_; i ++) {
            data_[i] = temp_array.data_[i];
        }
    }
 
    ~Array() {
        delete[] data_;
    }
 
public:
    int *data_;
    int size_;
};
该类的拷贝构造函数、赋值运算符重载函数已经通过使用左值引用传参来避免一次多余拷贝了，但是内部实现要深拷贝，无法避免。 这时，有人提出一个想法：是不是可以提供一个移动构造函数，把被拷贝者的数据移动过来，被拷贝者后边就不要了，这样就可以避免深拷贝了，如：

class Array {
public:
    Array(int size) : size_(size) {
        data = new int[size_];
    }
     
    // 深拷贝构造
    Array(const Array& temp_array) {
        ...
    }
     
    // 深拷贝赋值
    Array& operator=(const Array& temp_array) {
        ...
    }
 
    // 移动构造函数，可以浅拷贝
    Array(const Array& temp_array, bool move) {
        data_ = temp_array.data_;
        size_ = temp_array.size_;
        // 为防止temp_array析构时delete data，提前置空其data_      
        temp_array.data_ = nullptr;
    }
     
 
    ~Array() {
        delete [] data_;
    }
 
public:
    int *data_;
    int size_;
};
这么做有2个问题：

不优雅，表示移动语义还需要一个额外的参数(或者其他方式)。
无法实现！temp_array是个const左值引用，无法被修改，所以temp_array.data_ = nullptr;这行会编译不过。当然函数参数可以改成非const：Array(Array& temp_array, bool move){...}，这样也有问题，由于左值引用不能接右值，Array a = Array(Array(), true);这种调用方式就没法用了。
可以发现左值引用真是用的很不爽，右值引用的出现解决了这个问题，在STL的很多容器中，都实现了以右值引用为参数的移动构造函数和移动赋值重载函数，或者其他函数，最常见的如std::vector的push_back和emplace_back。参数为左值引用意味着拷贝，为右值引用意味着移动。

class Array {
public:
    ......
 
    // 优雅
    Array(Array&& temp_array) {
        data_ = temp_array.data_;
        size_ = temp_array.size_;
        // 为防止temp_array析构时delete data，提前置空其data_      
        temp_array.data_ = nullptr;
    }
     
 
public:
    int *data_;
    int size_;
};
如何使用：

// 例1：Array用法
int main(){
    Array a;
 
    // 做一些操作
    .....
     
    // 左值a，用std::move转化为右值
    Array b(std::move(a));
}
3.2 实例：vector::push_back使用std::move提高性能
// 例2：std::vector和std::string的实际例子
int main() {
    std::string str1 = "aacasxs";
    std::vector<std::string> vec;
     
    vec.push_back(str1); // 传统方法，copy
    vec.push_back(std::move(str1)); // 调用移动语义的push_back方法，避免拷贝，str1会失去原有值，变成空字符串
    vec.emplace_back(std::move(str1)); // emplace_back效果相同，str1会失去原有值
    vec.emplace_back("axcsddcas"); // 当然可以直接接右值
}
 
// std::vector方法定义
void push_back (const value_type& val);
void push_back (value_type&& val);
 
void emplace_back (Args&&... args);
在vector和string这个场景，加个std::move会调用到移动语义函数，避免了深拷贝。

除非设计不允许移动，STL类大都支持移动语义函数，即可移动的。 另外，编译器会默认在用户自定义的class和struct中生成移动语义函数，但前提是用户没有主动定义该类的拷贝构造等函数(具体规则自行百度哈)。 因此，可移动对象在<需要拷贝且被拷贝者之后不再被需要>的场景，建议使用std::move触发移动语义，提升性能。

moveable_objecta = moveable_objectb; 
改为： 
moveable_objecta = std::move(moveable_objectb);
还有些STL类是move-only的，比如unique_ptr，这种类只有移动构造函数，因此只能移动(转移内部对象所有权，或者叫浅拷贝)，不能拷贝(深拷贝):

std::unique_ptr<A> ptr_a = std::make_unique<A>();

std::unique_ptr<A> ptr_b = std::move(ptr_a); // unique_ptr只有‘移动赋值重载函数‘，参数是&& ，只能接右值，因此必须用std::move转换类型

std::unique_ptr<A> ptr_b = ptr_a; // 编译不通过
std::move本身只做类型转换，对性能无影响。 我们可以在自己的类中实现移动语义，避免深拷贝，充分利用右值引用和std::move的语言特性。

4. 完美转发 std::forward
和std::move一样，它的兄弟std::forward也充满了迷惑性，虽然名字含义是转发，但他并不会做转发，同样也是做类型转换.

与move相比，forward更强大，move只能转出来右值，forward都可以。

std::forward<T>(u)有两个参数：T与 u。 a. 当T为左值引用类型时，u将被转换为T类型的左值； b. 否则u将被转换为T类型右值。
举个例子，有main，A，B三个函数，调用关系为：main->A->B，建议先看懂2.3节对左右值引用本身是左值还是右值的讨论再看这里：

void B(int&& ref_r) {
    ref_r = 1;
}
 
// A、B的入参是右值引用
// 有名字的右值引用是左值，因此ref_r是左值
void A(int&& ref_r) {
    B(ref_r);  // 错误，B的入参是右值引用，需要接右值，ref_r是左值，编译失败
     
    B(std::move(ref_r)); // ok，std::move把左值转为右值，编译通过
    B(std::forward<int>(ref_r));  // ok，std::forward的T是int类型，属于条件b，因此会把ref_r转为右值
}
 
int main() {
    int a = 5;
    A(std::move(a));
}
例2：

void change2(int&& ref_r) {
    ref_r = 1;
}
 
void change3(int& ref_l) {
    ref_l = 1;
}
 
// change的入参是右值引用
// 有名字的右值引用是 左值，因此ref_r是左值
void change(int&& ref_r) {
    change2(ref_r);  // 错误，change2的入参是右值引用，需要接右值，ref_r是左值，编译失败
     
    change2(std::move(ref_r)); // ok，std::move把左值转为右值，编译通过
    change2(std::forward<int &&>(ref_r));  // ok，std::forward的T是右值引用类型(int &&)，符合条件b，因此u(ref_r)会被转换为右值，编译通过
     
    change3(ref_r); // ok，change3的入参是左值引用，需要接左值，ref_r是左值，编译通过
    change3(std::forward<int &>(ref_r)); // ok，std::forward的T是左值引用类型(int &)，符合条件a，因此u(ref_r)会被转换为左值，编译通过
    // 可见，forward可以把值转换为左值或者右值
}
 
int main() {
    int a = 5;
    change(std::move(a));
}
上边的示例在日常编程中基本不会用到，std::forward最主要运于模版编程的参数转发中，想深入了解需要学习万能引用(T &&)和引用折叠(eg:& && → ?)等知识，本文就不详细介绍这些了。
* 结构化绑定声明
结构化绑定声明，是指在一次声明中同时引入多个变量，同时绑定初始化表达式的各个子对象的语法形式。
结构化绑定声明使用auto来声明多个变量，所有变量都必须用中括号括起来。
#+begin_example
cv-auto+引用 [变量1, 变量2, ... 变量n ] = 初始化表达式;
cv-auto+引用 [变量1, 变量2, ... 变量n ] (初始化表达式);
cv-auto+引用 [变量1, 变量2, ... 变量n ] {初始化表达式};
// 这里 cv-auto+引用 包含 auto, auto const, auto &, auto&& 等等形式
#+end_example
结构化绑定所声明的变量有两种形式：
1. 非引用变量，此时初始化表达式对象需要拷贝一份，变量所绑定的是初始化表达式对象拷贝的各个子对象。
2. 引用变量，此时初始化表达式对象不需要拷贝，变量所绑定的是初始化表达式对象本身的各个子对象。

结构化绑定中的初始化表达式有三种类型：
1. 数组类型，此时变量所绑定的是数组的各个元素。
2. pair tuple等支持 tuple_size<E> 的类型，此时变量所绑定的是 get<0>(e)，get<1>(e)，get<2>(e)…
这里E是指类型，e是指对象。
3. 带有 public 成员的结构类型，此时变量所绑定的是结构对象的各个 public 成员。

C++17代码
#+begin_src c++ 
#include <iostream>
#include <utility>
#include <set>
#include <map>

using namespace std;

struct S {
    int a, b;
};

map<string, int> get_map()
{
    return {
        { "hello", 1 },
        { "world", 2 },
        { "it's",  3 },
        { "me",    4 },
    };
}

int main()
{
    auto [a, b] = pair(2, "3"s);
    cout << a << b << endl; // 23

    set<string> myset;
    if (auto [iter, success] = myset.insert("Hello"); success) 
       cout << *iter << endl; // Hello

    int arr[] = {1, 2};
    const auto& [m, n] = arr;
    cout << m << n << endl; //12

    S s = {4, 5};
    auto& [x, y] = s;
    x = 0, y = 1;
    cout << s.a << s.b << endl; // 01

    for (auto&& [k, v] : get_map())
        cout << "k=" << k << " v=" << v << endl;
    // k=hello v=1
    // k=it's v=3
    // k=me v=4
    // k=world v=2
}
#+end_src
代码说明
代码第25行采用结构化绑定声明了 int 类型的 a 和 string 类型的 b，分别绑定了初始化表达式中 pair 对象的 first 和 second。
代码第29行采用结构化绑定声明了迭代类型的 iter 和 bool 类型的 success，分别绑定了初始化表达式中 pair 对象的 first 和 second。
代码第33行采用结构化绑定声明了 const int& 类型的 m 和 n，分别绑定了初始化表达式中 arr 数组的两个元素。
代码第37行采用结构化绑定声明了 int& 类型的 x 和 y，分别绑定了初始化表达式中 s 对象的两个数据成员 a 和 b。
代码第41行采用结构化绑定声明了 string&& 类型的 k 和 int 类型的 v，分别绑定了初始化表达式中 pair 对象的 first 和 second。

C++14等价代码
#+begin_src c++ 
#include <iostream>
#include <utility>
#include <set>
#include <map>

using namespace std;

struct S {
    int a, b;
};

map<string, int> get_map()
{
    return {
        { "hello", 1 },
        { "world", 2 },
        { "it's",  3 },
        { "me",    4 },
    };
}

int main()
{
    auto kv = make_pair(2, "3"s);
    auto& a = kv.first; auto& b = kv.second;

    set<string> myset;
    set<string>::iterator iter;
    bool success;
    tie(iter, success) = myset.insert("Hello");
    if (success) 
       cout << *iter << endl; // Hello

    int arr[] = {1, 2};
    const auto &m = arr[0], &n = arr[1];
    cout << m << n << endl; //12

    S s = {4, 5};
    auto &x = s.a, &y = s.b;
    x = 0, y = 1;
    cout << s.a << s.b << endl; // 01

    for (auto&& kv : get_map()) {
        auto&& k = forward<decltype(kv.first)>(kv.first);
        auto&& v = forward<decltype(kv.second)>(kv.second);
        cout << "k=" << k << " v=" << v << endl;
    }
    // k=hello v=1
    // k=it's v=3
    // k=me v=4
    // k=world v=2
}
#+end_src
** 参考文章
[[https://blog.csdn.net/zwvista/article/details/78111346][C++17尝鲜：结构化绑定声明（Structured Binding Declaration）]]
* 转换
** 算术转换
*** 整型提升
bool\char\signed char\unsigned char\short\unsigned short等类型:
- 如果可以存在int里,则转换成int(例如bool转成0或1)
- 如果不能存在int里,则转换成unsigned int

较大的char类型(wchar_t\char16_t\char32_t)提升成int\unsigned int\long\unsigned long\long long\unsigned long long中最小的一种类型,前提是要能容纳原类型所有可能的值.

**** 从汇编层面理解
从一个简单的例子开始：
#+begin_src c++
int main(void)
{
    unsigned char a = 0xff;
    char b = 0xff;
    int c = a + b;
    return 0;
}

#+END_SRC
反汇编结果是：
#+begin_src c++
movl    {% math_inline %}0, -4(%rbp)        # The return value of main is 0
movb    {% endmath_inline %}-1, -5(%rbp)       # unsigned char a = 0xff;
movb    {% math_inline %}-1, -6(%rbp)       # char b = 0xff;
movzbl  -5(%rbp), %eax
movsbl  -6(%rbp), %ecx
addl    %eax, %ecx          # int c = a + b
movl    %ecx, -12(%rbp)     # store c onto the stack
movl    -4(%rbp), %eax
popq    %rbp
ret                         # return value 0 from eax
#+END_SRC
如果你的GAS语法不熟悉，可以查看X86 Assembly/GAS Syntax。
GAS语法指令通常以“b”, “s”, “w”, “l”, “q” 和“t” 为后缀，以区分操作数在大小。
#+begin_src c++
b = byte (8 bit)
s = short (16 bit integer) or single (32-bit floating point)
w = word (16 bit)
l = long (32 bit integer or 64-bit floating point)
q = quad (64 bit)
t = 10 bytes (80-bit floating point)

#+END_SRC
GAS语法中的mov是把参数从左边移到右边。例如： movl {% endmath_inline %}0, -4(%rbp)的意思是把 0x00000000 移到地址 -4(%rbp)处。

指令 movzbl 表示把一个byte变成long并将空位零填充 。movzbl -5(%rbp), %eax 把 0xff 移到寄存器 %eax 上，并把空位补0。寄存器 %eax 的值变成了 0x000000ff。

指令 movsbl 表示把一个byte变成long并将空位符号填充。movsbl -6(%rbp), %ecx 把 0xff 移到寄存器 %eax ，然后把空位补成有符号的数值，这使得寄存器 %ecx 值变为 0xffffffff。最后， addl %eax, %ecx 执行加法操作， movl %ecx, -12(%rbp) 把结果存到栈上。

现在，你可以把整型提升理解为把C语言类型直接映射到机器指令的一种机制了。所有算术操作的操作数被转成有符号或无符号int后，都会被当作一个小的int的计算。你可以这么想：尽管short和char只占一两个字节，当它们在进行算术运算时，都是当作int的。这种转成int规则被称为整型提升。

总结:
通常情况下，在对int类型的数值作运算时，CPU的运算速度是最快的。在x86上，32位算术运算的速度比16位算术运算的速度快一倍。C语言是一个注重效率的语言，所以它会作整型提升，使得程序的运行速度尽可能地快。因此，你必须记住整型提升规则，以免发生一些整型溢出的问题。
**** 参考文章
[[https://windmissing.github.io/cpp_notes/grammar/2015-08-25-Integer-Promotion.html][c语言进阶：整型提升]]

*** 浮点类型提升
float将会提升到double类型再进行运算

*** 无符号类型的运算对象
如果某个运算符左右两边的运算对象类型不一致,那么这些运算对象将转换成同一种类型.
1. 执行整型提升后,如果两边的运算对象的类型一样,则无须进一步的转换;
2. 如果一个是无符号,一个是有符号,并且无符号类型大于等于带符号类型,那么带符号类型转换成无符号类型;
3. 如果一个是无符号,一个是有符号,并且无符号类型小于带符号类型,此时转换的结果取决于机器.如果无符号类型所有值都可以存在带符号类型里,则无符号转成有符号,
*** 转换优先级
优先级逐步提升，同一级的类型优先级相同：
1. bool
2. char,signed char,unsigned char
3. short,unsigned short
4. int,unsigned int
5. long,unsigned long
6. long long,unsigned long long

** 显式转换
*** 命名的强制类型转换
格式:cast-name<type>(expression);
如果type是引用类型,则结果是左值.

cast-name是static_cast\dynamic_cast\const_cast和reinterpret_cast中的一种.
**** const_cast
const_cast 用来移除变量的 const 或volatile限定符.
const_cast只能改变运算对象的底层const.

#+begin_src c++
  const char *pc;
  char *p=const_cast<char*>(pc);//正确,但是通过p写值是未定义的行为
#+END_SRC
如果对象本身不时一个常量,使用强制类型转换获得写权限是合法的行为.但是如果对象是一个常量,再使用const_cast执行写操作就会产生未定义的后果.
* gtest
** assertion
在gtest中，是通过断言（assertion）来判断代码实现的功能是否符合预期。断言的结果分为success、non-fatal failture和fatal failture。

根据断言失败的种类，gtest提供了两种断言函数：
- success：即断言成功，程序的行为符合预期，程序继续向下允许。
- non-fatal failure：即断言失败，但是程序没有直接crash，而是继续向下运行。

gtest提供了宏函数EXPECT_XXX(expected, actual)：如果condition(expected, actual)返回false，则EXPECT_XXX产生的就是non-fatal failure错误，并显示相关错误。
- fatal failure：断言失败，程序直接crash，后续的测试案例不会被运行。

gtest提供了宏函数ASSERT_XXX(expected, actual)。

在写单元测试时，更加倾向于使用EXPECT_XXX，因为ASSERT_XXX是直接crash退出的，可能会导致一些内存、文件资源没有释放，因此可能会引入一些bug。

具体的EXPECT_XXX、ASSERT_XXX函数及其判断条件，如下两个表。
#+DOWNLOADED: screenshot @ 2022-08-23 22:35:24
[[file:images/c++/gtest/2022-08-23_22-35-24_screenshot.png]]
** 参考文章
[[https://zhuanlan.zhihu.com/p/369466622][手把手教你使用gtest写单元测试]]
* leetcode笔记
** 优先队列
 1046题

 priority_queue<Type, Container, Functional>

 Type 就是数据类型，Container 就是容器类型（Container必须是用数组实现的容器，比如vector,deque等等，但不能用 list。STL里面默认用的是vector），Functional 就是比较的方式。

当需要用自定义的数据类型时才需要传入这三个参数，使用基本数据类型时，只需要传入数据类型，默认是大顶堆
 #+BEGIN_SRC c++
 #include <queue>
 //升序队列
 priority_queue <int,vector<int>,greater<int> > q;
 //降序队列
 priority_queue <int,vector<int>,less<int> >q;

 //greater和less是std实现的两个仿函数（就是使一个类的使用看上去像一个函数。其实现就是类中实现一个operator()，这个类就有了类似函数的行为，就是一个仿函数类了）
 #+END_SRC
*** 自定义比较函数
***** 方式一：struct重载运算符()
通过struct重载()操作符，定义了一个函数对象
#+DOWNLOADED: screenshot @ 2022-11-10 22:37:33
[[file:images/c++/leetcode%E7%AC%94%E8%AE%B0/2022-11-10_22-37-33_screenshot.png]]
这是属于传入 函数对象 的方式
***** 方式二：class重载运算符()
通过class重载()操作符，定义了一个函数对象
注意要加public

#+DOWNLOADED: screenshot @ 2022-11-10 22:37:46
[[file:images/c++/leetcode%E7%AC%94%E8%AE%B0/2022-11-10_22-37-46_screenshot.png]]
这是属于传入 函数对象 的方式
***** 方式三：定义函数
首先定义一个比较函数
#+DOWNLOADED: screenshot @ 2022-11-10 22:37:54
[[file:images/c++/leetcode%E7%AC%94%E8%AE%B0/2022-11-10_22-37-54_screenshot.png]]
decltype()是用于获得函数指针的 类型的。在模板中也要传入它们的类型。
decltype()要传入的是一个对象的地址，因此需要对cmp加取值符，&cmp为对象的地址
在这里插入图片描述
因此可以由函数地址cmp 转为函数指针 类型 decltype(&cmp)
#+DOWNLOADED: screenshot @ 2022-11-10 22:38:05
[[file:images/c++/leetcode%E7%AC%94%E8%AE%B0/2022-11-10_22-38-05_screenshot.png]]
写法一：
#+DOWNLOADED: screenshot @ 2022-11-10 22:38:15
[[file:images/c++/leetcode%E7%AC%94%E8%AE%B0/2022-11-10_22-38-15_screenshot.png]]
写法二：
如果作为类成员函数，一定要声明static
#+DOWNLOADED: screenshot @ 2022-11-10 22:38:24
[[file:images/c++/leetcode%E7%AC%94%E8%AE%B0/2022-11-10_22-38-24_screenshot.png]]
这是属于传入 函数指针的方式。
***** 方式四：lambda表达式
#+DOWNLOADED: screenshot @ 2022-11-10 22:38:32
[[file:images/c++/leetcode%E7%AC%94%E8%AE%B0/2022-11-10_22-38-32_screenshot.png]]
这是属于传入 函数指针的方式。
***** 方式五：function包装lambda表达式
要加入头文件#include<functional>

由于function对lambda函数进行了包装 ,cmp本身就是一个对象地址。（function对象）
直接decltype(cmp)获得函数指针 的类型。
#+DOWNLOADED: screenshot @ 2022-11-10 22:38:41
[[file:images/c++/leetcode%E7%AC%94%E8%AE%B0/2022-11-10_22-38-41_screenshot.png]]
这是属于传入 函数指针的方式。
*** 参考文章
[[https://blog.csdn.net/qq_21539375/article/details/122128445][c++优先队列priority_queue（自定义比较函数）]]
** 多维数组的定义
 #+BEGIN_SRC c++
 //二维
 vector<vector<int>> a;

 //三维
 vector< vector< vector<int> > > b;
 #+END_SRC
** 数组的初始化
 #+BEGIN_SRC c++
 //一维
 vector<int> a(5,1)  //定义了5维数组,其中的值都为1
 //二维
 vector<vector<int>> a(5，vector<int>(2,1)) //定义了二维数组，第一个维度为5，第二个维度里的每一个数组的维度都为2，值都为1
 //三维
 vector<vector<vector<int>>> dp(2, vector<vector<int>>(3, vector<int>(4, 5)));
 #+END_SRC
** multiset
 set和multiset会根据特定的排序准则，自动将元素进行排序。不同的是后者允许元素重复而前者不允许。
 #+BEGIN_SRC c++
 #include <set>
 multiset<int> st;
 #+END_SRC
 和所有关联式容器类似，通常使用平衡二叉树完成。事实上，set和multiset通常以红黑树实作而成。

 自动排序的优点是使得搜寻元素时具有良好的性能，具有对数时间复杂度。但是造成的一个缺点就是：
 - 不能直接改变元素值。因为这样会打乱原有的顺序。
 - 改变元素值的方法是：先删除旧元素，再插入新元素。
 - 存取元素只能通过迭代器，从迭代器的角度看，元素值是常数。

** 快速排序
 记得要从右边开始循环

 下面这种快速选择的算法也是可以参考的(第215题)：
 #+BEGIN_SRC c++
 int search(vector<int>& nums, int left, int right) {
         int x = rand() % (right - left + 1) + left; //随机化选择
         swap(nums[x], nums[left]);
         int p = nums[left];
         int j = left;
         for (int i = left+1; i<=right; i++)
         {
             if (nums[i] < p) {
                 j++;
                 swap(nums[j], nums[i]);
             }
         }
         swap(nums[j], nums[left]);
         return j;
     }
 #+END_SRC

** 随机化
 srand()是给随机数产生器一个种子，time(NULL)就是把当前的时间值作为种子。
 要取得[a,b)的随机整数，使用 ~(rand() % (b-a))+ a~;
 要取得[a,b]的随机整数，使用 ~(rand() % (b-a+1))+ a~;
 要取得(a,b]的随机整数，使用 ~(rand() % (b-a))+ a + 1~;
** c++类型转换
 #+BEGIN_SRC c++
 long long z = static_cast<long long>(nums[right]);
 #+END_SRC
** KMP算法
 第28题
 #+BEGIN_SRC c++
 class Solution {
 public:
     void create(vector<int>& next, string needle) {
         next[0] = -1;
         int j = -1;
         for (int i = 1; i < needle.size(); i++)
         {
             while (j != -1 && needle[i] != needle[j + 1])j = next[j];
             if (needle[i] == needle[j + 1])j++;
             next[i] = j;
         }
     }
     int strStr(string haystack, string needle) {
         if (needle.size() == 0)return 0;
         if (haystack.size() == 0)return -1;
         int n = haystack.size(), m = needle.size();
         vector<int> next(m);
         create(next, needle);
         int j = -1;
         for (int i = 0; i < n; i++) {
             while (j != -1 && haystack[i] != needle[j + 1])j = next[j];
             if (haystack[i] == needle[j + 1])j++;
             if (j == m - 1)return i - m+1;
         }
         return -1;
     }
 };
 #+END_SRC

** reverse
 #+BEGIN_SRC c++
 //给定 matrix = 
 //[
 //  [1,4,7],
 //  [2,5,8],
 //  [3,6,9]
 //]
 //对其以中轴线进行翻转
 for (auto& row : matrix)
     reverse(row.begin(), row.end());
 //结果为：
 //[
 //  [7,4,1],
 //  [8,5,2],
 //  [9,6,3]
 //]
 #+END_SRC
** C++ vector 的 begin()、end()、front()、back() 区别
 一、begin函数

 函数原型:

 iterator begin();

 const_iterator begin();

 功能：

 返回一个当前vector容器中起始元素的迭代器。

 

 二、end函数

 函数原型：

 iterator end();

 const_iterator end();

 功能：

 返回一个当前vector容器中末尾元素的迭代器。

 

 三、front函数

 函数原型：

 reference front();

 const_reference front();

 功能：

 返回当前vector容器中起始元素的引用。

 

 四、back函数

 函数原型：

 reference back();

 const_reference back();

 功能：

 返回当前vector容器中末尾元素的引用。

 leetcode 第56题
 #+BEGIN_SRC c++
 class Solution {
 public:
     vector<vector<int>> merge(vector<vector<int>>& intervals) {
         if (intervals.size() == 0)return {};
         sort(intervals.begin(), intervals.end());
         vector<vector<int>> merged;
         for (int i = 0; i < intervals.size(); i++) {
             int l = intervals[i][0], r = intervals[i][1];
             if (!merged.size() || merged.back()[1] < l) {
                 merged.push_back({ l,r });
             }
             else {
                 merged.back()[1] = max(merged.back()[1], r);
             }
         }
         return merged;
     }
 };
 #+END_SRC
** 形参传值和传引用运行速度的差异
 C++在做递归回溯算法相关题目时，递归函数形参传值和传引用运行速度有很大的差异。

 这是我第79题dfs函数的声明，主要区别是visited和word，一个是传值，一个是传引用。前者执行超时，后者在本题是32ms.

 个人理解为传值时每次递归调用都要在内存中新建立一个vector 来保存visit传入的值，但是传引用直接在visited原始位置操作，不需要进行新建变量与赋值，节省了代码运行的空间与时间开销。
 #+BEGIN_SRC c++
 void dfs(vector<vector<char>>& board,vector<vector<int>>visited,int x,int y,int n,string word,bool& flag)
 void dfs(vector<vector<char>>& board,vector<vector<int>>& visited,int x,int y,int n
 #+END_SRC

** map的迭代器用法
 第90题
 #+BEGIN_SRC c++
 class Solution {
 public:
     vector<vector<int>> subsetsWithDup(vector<int>& nums) {
         map<int,int> num;
         for (int i = 0; i < nums.size(); i++)
         {
             num[nums[i]]++;
         }
         vector<vector<int>> ans = { {} };
         for (auto t : num) {
             int n = ans.size();
             for (int i = 0; i < n; i++) {
                 vector<int> temp = ans[i];
                 for (int j = 0; j < t.second; j++)
                 {
                     temp.push_back(t.first);
                     ans.push_back(temp);
                 }
             }
         }
         return ans;
     }
 };
 #+END_SRC
** 字符串
*** 字符串连接
  string res = ""
  可以用 res+="V" 表示字符串 "V"
*** 关于insert和erase的用法
 #+BEGIN_SRC c++
 class Solution {
 public:
     vector<string> ans;
     vector<string> restoreIpAddresses(string s) {
         string cur = s;
         int n = s.size();
         helper(0, -1, n, s, cur);
         return ans;
     }
     void helper(int point_count,int last_point,int n,string &s,string &cur) {
         if (point_count == 3) {
             if (check(last_point + 1, n - 1, s)) {
                 ans.push_back(cur);
             }
             return;
         }
         for (int i = last_point+1; i < n-1; i++)
         {
             if (check(last_point + 1, i, s)) {
                 //注意这里Insert加了cur.being(),而后面的erase()没加
                 cur.insert(cur.begin() + i + point_count + 1, '.');
                 helper(point_count + 1, i,n, s, cur);
                 cur.erase(i + point_count + 1, 1);
             }
         }
         return;
     }
     bool check(int left, int right, string& s) {
         int num = 0;
         for (int i = left; i <=right; i++)
         {
             if (s[left] == '0' && left != right)return false;
             num = num * 10 + s[i] - '0';
             if (num > 255)return false;
         }
         return true;
     }
 };
 #+END_SRC
** 用迭代实现二叉树中序遍历
 第94题

 核心思想:
 - 使用颜色标记节点的状态，新节点为白色，已访问的节点为灰色。
 - 如果遇到的节点为白色，则将其标记为灰色，然后将其右子节点、自身、左子节点依次入栈。
 - 如果遇到的节点为灰色，则将节点的值输出。

 python版本:
 #+BEGIN_SRC python
 class Solution:
     def inorderTraversal(self, root: TreeNode) -> List[int]:
         WHITE, GRAY = 0, 1
         res = []
         stack = [(WHITE, root)]
         while stack:
             color, node = stack.pop()
             if node is None: continue
             if color == WHITE:
                 stack.append((WHITE, node.right))
                 stack.append((GRAY, node))
                 stack.append((WHITE, node.left))
             else:
                 res.append(node.val)
         return res
 #+END_SRC
 c++版本
 #+BEGIN_SRC c++
 class Solution {
	 vector<int>ans;
 public:
	 vector<int> inorderTraversal(TreeNode* root) {
		 int white = 0;
		 int gray = 1;
		 stack<pair<int, TreeNode*>>s;
		 s.push(make_pair(white,root));
		 while (!s.empty())
		 {
			 int color = s.top().first;
			 TreeNode* t = s.top().second;
			 s.pop();
			 if (t == NULL) continue;
			 if (color == white)
			 {
				 s.push(make_pair(white, t->right));
				 s.push(make_pair(gray, t));
				 s.push(make_pair(white, t->left));
			 }
			 else ans.push_back(t->val);
		 }
		 return ans;
	 }
 };
 #+END_SRC
** 函数返回指针
 第116题
 #+BEGIN_SRC c++
 class Solution {
 public:
     Node* connect(Node* root) {
         if (root == NULL)return NULL;
         auto left = root->left;
         auto right = root->right;
         while (left!=NULL)
         {
             left->next = right;
             left = left->right;
             right = right->left;
         }
         connect(root->left);  //注意这里不需要设置一个向量来存储函数范围的指针
         connect(root->right); //注意这里不需要设置一个向量来存储函数范围的指针
         return root;
     }
 };
 #+END_SRC
** 如何把一个整数转化为string
*** string转int的方式
 采用最原始的string, 然后按照十进制的特点进行算术运算得到int，但是这种方式太麻烦，这里不介绍了。

 采用标准库中atoi函数。

 string s = "12"; 
 int a = atoi(s.c_str()); 
 对于其他类型也都有相应的标准库函数，比如浮点型atof(),long型atol()等等。

 采用sstream头文件中定义的字符串流对象来实现转换。

 istringstream is("12"); //构造输入字符串流，流的内容初始化为“12”的字符串 
 int i; 
 is >> i; //从is流中读入一个int整数存入i中

*** int转string的方式
 采用标准库中的to_string函数。

 int i = 12; 
 cout << std::to_string(i) << endl; 
 不需要包含任何头文件，应该是在utility中，但无需包含，直接使用，还定义任何其他内置类型转为string的重载函数，很方便。

 采用sstream中定义的字符串流对象来实现。

 ostringstream os; //构造一个输出字符串流，流内容为空 
 int i = 12; 
 os << i; //向输出字符串流中输出int整数i的内容 
 cout << os.str() << endl; //利用字符串流的str函数获取流中的内容 
 字符串流对象的str函数对于istringstream和ostringstream都适用，都可以获取流中的内容。

** c++ 将一个char 转化为string
 #+BEGIN_SRC c++
 const char c = 'a';
 //1.使用 string 的构造函数
 string s(1,c);
 //2.声明string 后将char push_back
 string s1;
 s1.push_back(c);
 //3.使用stringstream
 stringstream ss;
 ss << c;
 string str2 = ss.str();

 //注意 使用to_string 方法会转化为char对应的ascii码
 //原因是 to_string 没有接受char型参数的函数原型，有一个参数类型
 //为int 的函数原型，所以传入char型字符 实际是先将char 转化
 //为int 型的ascii 码，然后再转变为string
 //以下输出结果为 97
 cout << to_string(c) << endl;
 #+END_SRC
** 除留余数法
 给定一个正整数，返回它在 Excel 表中相对应的列名称。

 例如，

     1 -> A
     2 -> B
     3 -> C
     ...
     26 -> Z
     27 -> AA
     28 -> AB 
     ...
 示例 1:

 输入: 1
 输出: "A"
 示例 2:

 输入: 28
 输出: "AB"
 示例 3:

 输入: 701
 输出: "ZY"
 #+BEGIN_SRC c++
 class Solution {
 public:
	 string convertToTitle(int n) {
		 string ans;
		 while (n != 0)
		 {
			 n--;
			 char c = n% 26 + 'A';
			 string temp(1, c);
			 ans = temp + ans;
			 n /= 26;
		 }
		 return ans;
	 }
 };  
 #+END_SRC
 下面是我的错误解法：
 #+BEGIN_SRC c++
 class Solution {
 public:
	 string convertToTitle(int n) {
		 string ans;
		 while (n != 0)
		 {
			 char c = (n-1)% 26 + 'A';
			 string temp(1, c);
			 ans = temp + ans;
			 n /= 26;
		 }
		 return ans;
	 }
 };  
 #+END_SRC
 这种解法在n=701(zy)时输出的结果为AZY，是错误的。
** 谓词、lambda表达式

 第179题

 给定一组非负整数 nums，重新排列它们每位数字的顺序使之组成一个最大的整数。

 注意：输出结果可能非常大，所以你需要返回一个字符串而不是整数。

  

 示例 1：

 输入：nums = [10,2]
 输出："210"
 示例 2：

 输入：nums = [3,30,34,5,9]
 输出："9534330"
 示例 3：

 输入：nums = [1]
 输出："1"
 示例 4：

 输入：nums = [10]
 输出："10"
  

 提示：

 1 <= nums.length <= 100
 0 <= nums[i] <= 109

 来源：力扣（LeetCode）
 链接：https://leetcode-cn.com/problems/largest-number
 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

 #+BEGIN_SRC c++
 class Solution {
 public:
     string largestNumber(vector<int>& nums) {
         if (all_of(nums.begin(), nums.end(), [](int x) {return x == 0; })) {
             return string("0");
         }
         vector<string> strNums(nums.size());
         std::transform(nums.begin(), nums.end(), strNums.begin(), [](int x) {return std::to_string(x); });
         std::sort(strNums.begin(), strNums.end(), [](const string& x, const string& y) {   //这里string& x不加&也是可以通过的
             return x + y > y + x;
             });
         return std::accumulate(strNums.begin(), strNums.end(), string());
     }
 };
 #+END_SRC
** 桶排序
 第220题

 在整数数组 nums 中，是否存在两个下标 i 和 j，使得 nums [i] 和 nums [j] 的差的绝对值小于等于 t ，且满足 i 和 j 的差的绝对值也小于等于 ķ 。

 如果存在则返回 true，不存在返回 false。

 示例 1:

 输入: nums = [1,2,3,1], k = 3, t = 0
 输出: true
 示例 2:

 输入: nums = [1,0,1,1], k = 1, t = 2
 输出: true
 示例 3:

 输入: nums = [1,5,9,1,5,9], k = 2, t = 3
 输出: false

 #+BEGIN_EXAMPLE
 我们将数据分到 M 个桶 中。
 每个数字nums[i] 都被我们分配到一个桶中
 分配的依据就是 nums[i] // (t + 1)
 这样相邻桶内的数字最多相差2 * t + 1
 不相邻的桶一定不满足相差小于等于t
 同一个桶内的数字最多相差t
 因此如果命中同一个桶内，那么直接返回True
 如果命中相邻桶，我们再判断一下是否满足 相差 <= t
 否则返回False
 需要注意的是，由于题目有索引相差k的要求，因此要维护一个大小为k的窗口，定期清除桶中过期的数字。
 #+END_EXAMPLE

 #+BEGIN_SRC c++
 class Solution {
 public:
     bool containsNearbyAlmostDuplicate(vector<int>& nums, int k, int t) {
         if(t<0) return false;
         //t+1可能会溢出，所以要+ 1LL
         long long mod = t + 1LL;
         unordered_map<long long,long long> buck;
         for(int i=0;i<nums.size();i++)
         {
             long long nth = nums[i] / mod;
             //可能nums[i]为负数，比如-4 / 5 以及 -4 / 5都等于0，所以负数要向下移动一位
             if(nums[i] < 0) nth--;
             //这里要用find 不能直接[],因为可能本身存储的数字就为0
             if(buck.find(nth)!=buck.end()) 
                 return true;
             else if(buck.find(nth-1)!=buck.end() && abs(nums[i] - buck[nth-1]) <= t)
                 return true;
             else if(buck.find(nth+1)!=buck.end() && abs(nums[i] - buck[nth+1]) <= t)
                 return true;
             buck[nth] = nums[i];
             if(i >= k)
             {
                 buck.erase(nums[i - k] / mod);
             }
         }
         return false;
     }
 };
 #+END_SRC

** 由vector创建set
 217. 存在重复元素

 #+BEGIN_EXAMPLE
 给定一个整数数组，判断是否存在重复元素。

 如果任意一值在数组中出现至少两次，函数返回 true 。如果数组中每个元素都不相同，则返回 false 。

  

 示例 1:

 输入: [1,2,3,1]
 输出: true
 示例 2:

 输入: [1,2,3,4]
 输出: false
 示例 3:

 输入: [1,1,1,3,3,4,3,2,4,2]
 输出: true

 #+END_EXAMPLE
 利用集合，与原数组比较大小
 #+BEGIN_SRC c++
 class Solution {
 public:
     bool containsDuplicate(vector<int>& nums) {

          return nums.size() > unordered_set<int>(nums.begin(), nums.end()).size(); 
          //如果原数组的大小>集合的大小，则说明存在重复元素
     }
 };
 #+END_SRC
** 取中点避免溢出的技巧
 二分查找中，计算 mid 时需要防止溢出，代码中 left + (right - left) / 2 就和 (left + right) / 2 的结果相同，但是有效防止了 left 和 right 太大直接相加导致溢出。
** 异或运算
 异或运算有以下三个性质。
 - 任何数和 0 做异或运算，结果仍然是原来的数
 - 任何数和其自身做异或运算，结果是 0 .
 - 异或运算满足交换律和结合律.

** stol用法
 std::stol()：此函数将参数提供的字符串转换为long long。它解析str并将其内容解释为指定基数的整数，并将其作为long long类型的值返回。

 Convert string to long long

 Parses str interpreting its content as an integral number of the specified base, which is returned as a value of type long long.

 If idx is not a null pointer, the function also sets the value of idx to the position of the first character in str after the number.

 The function uses strtoll (or wcstoll) to perform the conversion (see strtol for more details on the process).
 #+BEGIN_SRC c++
 long long stoll (const string&  str, size_t* idx = 0, int base = 10);
 long long stoll (const wstring& str, size_t* idx = 0, int base = 10);
 #+END_SRC
 参数：
 - str
 String object with the representation of an integral number.
 - idx
 Pointer to an object of type size_t, whose value is set by the function to position of the next character in str after the numerical value.
 This parameter can also be a null pointer, in which case it is not used.
 - base
 Numerical base (radix) that determines the valid characters and their interpretation.
 If this is 0, the base used is determined by the format in the sequence (see strtol for details). Notice that by default this argument is 10, not 0.

 #+BEGIN_SRC c++
 // stoll example
 #include <iostream>   // std::cout
 #include <string>     // std::string, std::stoll

 int main ()
 {
   std::string str = "8246821 0xffff 020";

   std::string::size_type sz = 0;   // alias of size_t

   while (!str.empty()) {
     long long ll = std::stoll (str,&sz,0);
     std::cout << str.substr(0,sz) << " interpreted as " << ll << '\n';
     str = str.substr(sz);
   }

   return 0;
 }
 #+END_SRC

 #+BEGIN_EXAMPLE
 8246821 interpreted as 8246821
  0xffff interpreted as 65535
  020 interpreted as 16
 #+END_EXAMPLE
** 一个包含所有c++的头文件的头文件

 #include<bits/stdc++.h>包含了目前c++所包含的所有头文件
** pair
 337题 打家劫舍III

 在上次打劫完一条街道之后和一圈房屋后，小偷又发现了一个新的可行窃的地区。这个地区只有一个入口，我们称之为“根”。 除了“根”之外，每栋房子有且只有一个“父“房子与之相连。一番侦察之后，聪明的小偷意识到“这个地方的所有房屋的排列类似于一棵二叉树”。 如果两个直接相连的房子在同一天晚上被打劫，房屋将自动报警。

 计算在不触动警报的情况下，小偷一晚能够盗取的最高金额。

 示例 1:

 输入: [3,2,3,null,3,null,1]

      3
     / \
    2   3
     \   \ 
      3   1

 输出: 7 
 解释: 小偷一晚能够盗取的最高金额 = 3 + 3 + 1 = 7.
 示例 2:

 输入: [3,4,5,1,3,null,1]

      3
     / \
    4   5
   / \   \ 
  1   3   1

 输出: 9
 解释: 小偷一晚能够盗取的最高金额 = 4 + 5 = 9.


 创建元组：
 #+BEGIN_EXAMPLE
 make_pair(0,0);
 pair<int, int> left = helper(root->left);
 #+END_EXAMPLE



 #+BEGIN_SRC c++
 #include <pair>
 class Solution {
 public:
     pair<int, int> helper(TreeNode* root) {
         if (root == NULL)return make_pair(0,0);
         pair<int, int> left = helper(root->left);
         pair<int, int> right = helper(root->right);

         return make_pair(root->val + left.second + right.second, max(left.first, left.second) + max(right.first, right.second));
     }
     int rob(TreeNode* root) {
         pair<int, int> ans = helper(root);
         return max(ans.first, ans.second);
     }
 };
 #+END_SRC

