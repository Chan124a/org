* 内存
** 危险的堆操作及带来的风险
*** 危险的堆操作
内存拷贝时未判断目标长度的的有效性（目标内存过小）

内存申请完毕后未判断空指针（空指针引用）

使用已经释放的内存

调用不匹配的内存管理操作（new、delete与malloc，free混用）

重复释放内存

引用未初始化的内存：申请内存后用memset进行初始化

使用负数申请内存：负数会被当做一个很大的无符号整数，从而导致申请内存过大。

使用alloca申请内存：POSIX和C99均未定义alloca的行为，在不支持的平台上运行会有未定义的后果。

指针释放后未置NULL：悬挂指针可能导致双重释放以及访问已释放内存的危险，消除这些风险的有效方法就是对释放的指针置NULL或者指向另一个合法对象。

使用realloc调整内存大小：realloc是一个有设计缺陷的函数，容易引入各种BUG，应当使用malloc代替realloc。
*** 堆管理不当带来的风险
- 拒绝服务攻击
- 执行任意代码


* 命令注入
C程序可通过system或者popen函数来调用命令解释器执行命令。

命令解释器支持命令分隔符、管道符。当命令输入参数中含有外部输入，则可能执行任意命令从而导致命令注入攻击。

应对方法：
- 不适用system()函数，可以使用Win32 API中CreatProcess()函数或POSIX的exec系列函数来替代。
- 若使用system()函数，这应该使用硬编码的函数入参或对外部输入中的命令分隔符进行过滤或者转义。
* 多线程下使用线程不安全函数
** 线程不安全函数
- strtok：strtok是一个线程不安全函数，在多线程环境中应该禁止使用
- print和cout混用：printf无缓冲区，而std::out有；printf在对标准输出作任何处理前先加锁，而std::out在实际向标准输出打印时方才加锁；二者存在微弱的时序差异，两者混用可能导致未知错误。
- 信号处理程序中使用异步不安全函数：I/O函数、自定义的异步不安全函数

** 线程不安全函数造成的危害
- 拒绝服务
- 执行任意代码

* 文件操作安全
** 常见文件操作问题
文件操作返回值判断有误

文件创建时没有指定合适的文件权限

对文件的路径校验不够安全

对同一文件的操作使用文件名的方式进行引用

对输入的文件路径没有进行标准化（即转换成绝对路径）：如果必须使用相对路径，需要对文件名中的特殊字符进行过滤，如“.”和“/”；内部文件名最好硬编码参数到应用程序中
** 条件竞争漏洞
条件竞争漏洞从检查到文件资源到使用文件的这段时间空隙，可以用来发动一次扩大权限的攻击，即所谓TOCTOU（time-of-check time-of-use）漏洞。
* 不安全的随机数使用
rand()的随机性较差，可以采用以下方法生成随机数：
- Unix/Linux平台采用读取"/dev/random"获取随机数
- Windows平台推荐采用CryptGenRandom()生成随机数
- 采用“硬件随机数”代替PRNG
* 敏感信息清理
C++的string类中的数据赋值是重新分配数据拷贝的方式保存，对string类中数据的操作隐藏了内存重新分配的过程，因此无法显示清理历史内存。（C++17机制有变化）

C编译器无法识别内存清理动作，对写后未读的内存指令可能被编译器优化而丧失清理作用。
